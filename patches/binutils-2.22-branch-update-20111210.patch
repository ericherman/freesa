From cd47dcc2841eadf9a54df4673679ba7fb2e18524 Mon Sep 17 00:00:00 2001
From: Brett Neumeier <brett@neumeier.us>
Date: Tue, 13 Dec 2011 21:29:24 -0600
Subject: [PATCH] branch updates

Updates from the binutils 2.22 branch from the 2.22 tag through
2011-12-10.
---
 ChangeLog                        |   52 +++++++++++
 bfd/ChangeLog                    |   52 +++++++++++
 bfd/Makefile.am                  |    2 +-
 bfd/Makefile.in                  |    2 +-
 bfd/configure                    |    2 +-
 bfd/configure.in                 |    2 +-
 bfd/elf32-cris.c                 |   11 +-
 bfd/elf32-m68k.c                 |    8 +-
 bfd/elf32-ppc.c                  |   14 ++-
 bfd/elf64-ppc.c                  |   14 ++-
 bfd/elflink.c                    |    9 +-
 bfd/elfxx-mips.c                 |   53 +++++------
 bfd/version.h                    |    2 +-
 ld/testsuite/ChangeLog           |    5 +
 ld/testsuite/ld-cris/pic-gc-72.d |    7 +-
 opcodes/ChangeLog                |    5 +
 opcodes/mips-dis.c               |  188 +++++++++++++++++++-------------------
 17 files changed, 274 insertions(+), 154 deletions(-)

diff --git a/ChangeLog b/ChangeLog
index e572d95..0db1265 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,55 @@
+2011-12-10  David Daney  <david.daney@cavium.com>
+
+	Backport from mainline:
+
+	2011-12-10  David Daney  <david.daney@cavium.com>
+
+	* elfxx-mips.c (mips_elf_link_hash_table.rld_value): Remove.
+	(mips_elf_link_hash_table.rld_symbol): New field;
+	(MIPS_ELF_RLD_MAP_SIZE): New macro.
+	(_bfd_mips_elf_add_symbol_hook): Remember __rld_obj_head symbol
+	in rld_symbol.
+	(_bfd_mips_elf_create_dynamic_sections): Remember __rld_map symbol
+	in rld_symbol.
+	(_bfd_mips_elf_size_dynamic_sections): Set correct size for .rld_map.
+	(_bfd_mips_elf_finish_dynamic_symbol): Remove .rld_map handling.
+	(_bfd_mips_elf_finish_dynamic_sections): Use rld_symbol to
+	calculate DT_MIPS_RLD_MAP value.
+	(_bfd_mips_elf_link_hash_table_create): Initialize rld_symbol,
+	quit initializing rld_value.
+
+2011-12-03  Alan Modra  <amodra@gmail.com>
+
+	PR ld/13468
+	* elflink.c (bfd_elf_final_link): Don't segfault when checking
+	for DT_TEXTREL and .dynamic does not exist.
+
+2011-12-03  Alan Modra  <amodra@gmail.com>
+
+	PR ld/13470
+	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Revert substantive
+	change in 2011-07-01 commit.  Comment.
+	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
+
+2011-12-01  Mikael Pettersson  <mikpe@it.uu.se>
+
+	Apply mainline patches
+	* elf32-m68k.c (elf_m68k_check_relocs) <R_68K_8, R68K_16, R_68K_32>: For
+	non-SEC_ALLOC sections break before GOT and PLT accounting.
+
+2011-12-01  Hans-Peter Nilsson  <hp@axis.com>
+
+	Apply mainline patches
+	* elf32-cris.c (cris_elf_check_relocs) <plt accounting for
+	R_CRIS_8, R_CRIS_16, and R_CRIS_32>: Move early break for
+	non-SEC_ALLOC sections before GOT and PLT accounting.
+
+2011-11-21  Tristan Gingold  <gingold@adacore.com>
+
+	* configure.in: Bump version to 2.22.0
+	* Makefile.am (RELEASE): Unset.
+	* configure, Makefile.in: Regenerate.
+
 2011-08-19  Joel Brobecker  <brobecker@adacore.com>
 
 	* src-release (GDB_SUPPORT_DIRS): Add 'cpu'.
diff --git a/bfd/ChangeLog b/bfd/ChangeLog
index 65db027..a7199ae 100644
--- a/bfd/ChangeLog
+++ b/bfd/ChangeLog
@@ -1,3 +1,55 @@
+2011-12-10  David Daney  <david.daney@cavium.com>
+
+	Backport from mainline:
+
+	2011-12-10  David Daney  <david.daney@cavium.com>
+
+	* elfxx-mips.c (mips_elf_link_hash_table.rld_value): Remove.
+	(mips_elf_link_hash_table.rld_symbol): New field;
+	(MIPS_ELF_RLD_MAP_SIZE): New macro.
+	(_bfd_mips_elf_add_symbol_hook): Remember __rld_obj_head symbol
+	in rld_symbol.
+	(_bfd_mips_elf_create_dynamic_sections): Remember __rld_map symbol
+	in rld_symbol.
+	(_bfd_mips_elf_size_dynamic_sections): Set correct size for .rld_map.
+	(_bfd_mips_elf_finish_dynamic_symbol): Remove .rld_map handling.
+	(_bfd_mips_elf_finish_dynamic_sections): Use rld_symbol to
+	calculate DT_MIPS_RLD_MAP value.
+	(_bfd_mips_elf_link_hash_table_create): Initialize rld_symbol,
+	quit initializing rld_value.
+
+2011-12-03  Alan Modra  <amodra@gmail.com>
+
+	PR ld/13468
+	* elflink.c (bfd_elf_final_link): Don't segfault when checking
+	for DT_TEXTREL and .dynamic does not exist.
+
+2011-12-03  Alan Modra  <amodra@gmail.com>
+
+	PR ld/13470
+	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Revert substantive
+	change in 2011-07-01 commit.  Comment.
+	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
+
+2011-12-01  Mikael Pettersson  <mikpe@it.uu.se>
+
+	Apply mainline patches
+	* elf32-m68k.c (elf_m68k_check_relocs) <R_68K_8, R68K_16, R_68K_32>: For
+	non-SEC_ALLOC sections break before GOT and PLT accounting.
+
+2011-12-01  Hans-Peter Nilsson  <hp@axis.com>
+
+	Apply mainline patches
+	* elf32-cris.c (cris_elf_check_relocs) <plt accounting for
+	R_CRIS_8, R_CRIS_16, and R_CRIS_32>: Move early break for
+	non-SEC_ALLOC sections before GOT and PLT accounting.
+
+2011-11-21  Tristan Gingold  <gingold@adacore.com>
+
+	* configure.in: Bump version to 2.22.0
+	* Makefile.am (RELEASE): Unset.
+	* configure, Makefile.in: Regenerate.
+
 2011-11-21  Tristan Gingold  <gingold@adacore.com>
 
 	* configure.in: Bump version to 2.22
diff --git a/bfd/Makefile.am b/bfd/Makefile.am
index ea4fd28..8610d5e 100644
--- a/bfd/Makefile.am
+++ b/bfd/Makefile.am
@@ -4,7 +4,7 @@ AUTOMAKE_OPTIONS = 1.11 no-dist foreign
 ACLOCAL_AMFLAGS = -I . -I .. -I ../config
 
 # Uncomment the following line when doing a release.
-RELEASE=y
+# RELEASE=y
 
 INCDIR = $(srcdir)/../include
 CSEARCH = -I. -I$(srcdir) -I$(INCDIR)
diff --git a/bfd/Makefile.in b/bfd/Makefile.in
index 741809c..34196aa 100644
--- a/bfd/Makefile.in
+++ b/bfd/Makefile.in
@@ -320,7 +320,7 @@ AUTOMAKE_OPTIONS = 1.11 no-dist foreign
 ACLOCAL_AMFLAGS = -I . -I .. -I ../config
 
 # Uncomment the following line when doing a release.
-RELEASE = y
+# RELEASE=y
 INCDIR = $(srcdir)/../include
 CSEARCH = -I. -I$(srcdir) -I$(INCDIR)
 SUBDIRS = doc po
diff --git a/bfd/configure b/bfd/configure
index bc242b9..d31f0d9 100755
--- a/bfd/configure
+++ b/bfd/configure
@@ -3988,7 +3988,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE=bfd
- VERSION=2.22
+ VERSION=2.22.0
 
 
 cat >>confdefs.h <<_ACEOF
diff --git a/bfd/configure.in b/bfd/configure.in
index 435aaaa..9ba3000 100644
--- a/bfd/configure.in
+++ b/bfd/configure.in
@@ -8,7 +8,7 @@ AC_CONFIG_SRCDIR([libbfd.c])
 AC_CANONICAL_TARGET
 AC_ISC_POSIX
 
-AM_INIT_AUTOMAKE(bfd, 2.22)
+AM_INIT_AUTOMAKE(bfd, 2.22.0)
 
 dnl These must be called before LT_INIT, because it may want
 dnl to call AC_CHECK_PROG.
diff --git a/bfd/elf32-cris.c b/bfd/elf32-cris.c
index 243a8ec..310f6d1 100644
--- a/bfd/elf32-cris.c
+++ b/bfd/elf32-cris.c
@@ -3579,6 +3579,12 @@ cris_elf_check_relocs (bfd *abfd,
 		 sec,
 		 cris_elf_howto_table[r_type].name);
 	    }
+
+	  /* We don't need to handle relocs into sections not going into
+	     the "real" output.  */
+	  if ((sec->flags & SEC_ALLOC) == 0)
+	    break;
+
 	  if (h != NULL)
 	    {
 	      h->non_got_ref = 1;
@@ -3608,11 +3614,6 @@ cris_elf_check_relocs (bfd *abfd,
 	  if (! info->shared)
 	    break;
 
-	  /* We don't need to handle relocs into sections not going into
-	     the "real" output.  */
-	  if ((sec->flags & SEC_ALLOC) == 0)
-	    break;
-
 	  /* We may need to create a reloc section in the dynobj and made room
 	     for this reloc.  */
 	  if (sreloc == NULL)
diff --git a/bfd/elf32-m68k.c b/bfd/elf32-m68k.c
index 612525c..3e9ada9 100644
--- a/bfd/elf32-m68k.c
+++ b/bfd/elf32-m68k.c
@@ -2816,6 +2816,11 @@ elf_m68k_check_relocs (abfd, info, sec, relocs)
 	case R_68K_8:
 	case R_68K_16:
 	case R_68K_32:
+	  /* We don't need to handle relocs into sections not going into
+	     the "real" output.  */
+	  if ((sec->flags & SEC_ALLOC) == 0)
+	      break;
+
 	  if (h != NULL)
 	    {
 	      /* Make sure a plt entry is created for this symbol if it
@@ -2829,8 +2834,7 @@ elf_m68k_check_relocs (abfd, info, sec, relocs)
 
 	  /* If we are creating a shared library, we need to copy the
 	     reloc into the shared library.  */
-	  if (info->shared
-	      && (sec->flags & SEC_ALLOC) != 0)
+	  if (info->shared)
 	    {
 	      /* When creating a shared object, we must copy these
 		 reloc types into the output file.  We create a reloc
diff --git a/bfd/elf32-ppc.c b/bfd/elf32-ppc.c
index 0c25c3e..574cd98 100644
--- a/bfd/elf32-ppc.c
+++ b/bfd/elf32-ppc.c
@@ -2987,10 +2987,6 @@ ppc_elf_copy_indirect_symbol (struct bfd_link_info *info,
   edir->elf.needs_plt |= eind->elf.needs_plt;
   edir->elf.pointer_equality_needed |= eind->elf.pointer_equality_needed;
 
-  /* If we were called to copy over info for a weak sym, that's all.  */
-  if (eind->elf.root.type != bfd_link_hash_indirect)
-    return;
-
   if (eind->dyn_relocs != NULL)
     {
       if (edir->dyn_relocs != NULL)
@@ -3022,6 +3018,16 @@ ppc_elf_copy_indirect_symbol (struct bfd_link_info *info,
       eind->dyn_relocs = NULL;
     }
 
+  /* If we were called to copy over info for a weak sym, that's all.
+     You might think dyn_relocs need not be copied over;  After all,
+     both syms will be dynamic or both non-dynamic so we're just
+     moving reloc accounting around.  However, ELIMINATE_COPY_RELOCS 
+     code in ppc_elf_adjust_dynamic_symbol needs to check for
+     dyn_relocs in read-only sections, and it does so on what is the
+     DIR sym here.  */
+  if (eind->elf.root.type != bfd_link_hash_indirect)
+    return;
+
   /* Copy over the GOT refcount entries that we may have already seen to
      the symbol which just became indirect.  */
   edir->elf.got.refcount += eind->elf.got.refcount;
diff --git a/bfd/elf64-ppc.c b/bfd/elf64-ppc.c
index 93d1314..32a3430 100644
--- a/bfd/elf64-ppc.c
+++ b/bfd/elf64-ppc.c
@@ -4435,10 +4435,6 @@ ppc64_elf_copy_indirect_symbol (struct bfd_link_info *info,
   edir->elf.ref_regular_nonweak |= eind->elf.ref_regular_nonweak;
   edir->elf.needs_plt |= eind->elf.needs_plt;
 
-  /* If we were called to copy over info for a weak sym, that's all.  */
-  if (eind->elf.root.type != bfd_link_hash_indirect)
-    return;
-
   /* Copy over any dynamic relocs we may have on the indirect sym.  */
   if (eind->dyn_relocs != NULL)
     {
@@ -4471,6 +4467,16 @@ ppc64_elf_copy_indirect_symbol (struct bfd_link_info *info,
       eind->dyn_relocs = NULL;
     }
 
+  /* If we were called to copy over info for a weak sym, that's all.
+     You might think dyn_relocs need not be copied over;  After all,
+     both syms will be dynamic or both non-dynamic so we're just
+     moving reloc accounting around.  However, ELIMINATE_COPY_RELOCS 
+     code in ppc64_elf_adjust_dynamic_symbol needs to check for
+     dyn_relocs in read-only sections, and it does so on what is the
+     DIR sym here.  */
+  if (eind->elf.root.type != bfd_link_hash_indirect)
+    return;
+
   /* Copy over got entries that we may have already seen to the
      symbol which just became indirect.  */
   if (eind->elf.got.glist != NULL)
diff --git a/bfd/elflink.c b/bfd/elflink.c
index fc4266b..8556cec 100644
--- a/bfd/elflink.c
+++ b/bfd/elflink.c
@@ -11188,15 +11188,12 @@ bfd_elf_final_link (bfd *abfd, struct bfd_link_info *info)
 	goto error_return;
 
       /* Check for DT_TEXTREL (late, in case the backend removes it).  */
-      if ((info->warn_shared_textrel && info->shared)
-	  || info->error_textrel)
+      if (((info->warn_shared_textrel && info->shared)
+	   || info->error_textrel)
+	  && (o = bfd_get_section_by_name (dynobj, ".dynamic")) != NULL)
 	{
 	  bfd_byte *dyncon, *dynconend;
 
-	  /* Fix up .dynamic entries.  */
-	  o = bfd_get_section_by_name (dynobj, ".dynamic");
-	  BFD_ASSERT (o != NULL);
-
 	  dyncon = o->contents;
 	  dynconend = o->contents + o->size;
 	  for (; dyncon < dynconend; dyncon += bed->s->sizeof_dyn)
diff --git a/bfd/elfxx-mips.c b/bfd/elfxx-mips.c
index 33a454d..6b908ad 100644
--- a/bfd/elfxx-mips.c
+++ b/bfd/elfxx-mips.c
@@ -436,8 +436,8 @@ struct mips_elf_link_hash_table
      entry is set to the address of __rld_obj_head as in IRIX5.  */
   bfd_boolean use_rld_obj_head;
 
-  /* This is the value of the __rld_map or __rld_obj_head symbol.  */
-  bfd_vma rld_value;
+  /* The  __rld_map or __rld_obj_head symbol. */
+  struct elf_link_hash_entry *rld_symbol;
 
   /* This is set if we see any mips16 stub sections.  */
   bfd_boolean mips16_stubs_seen;
@@ -768,6 +768,10 @@ static bfd *reldyn_sorting_bfd;
 #define MIPS_ELF_GOT_SIZE(abfd) \
   (get_elf_backend_data (abfd)->s->arch_size / 8)
 
+/* The size of the .rld_map section. */
+#define MIPS_ELF_RLD_MAP_SIZE(abfd) \
+  (get_elf_backend_data (abfd)->s->arch_size / 8)
+
 /* The size of a symbol-table entry.  */
 #define MIPS_ELF_SYM_SIZE(abfd) \
   (get_elf_backend_data (abfd)->s->sizeof_sym)
@@ -7081,6 +7085,7 @@ _bfd_mips_elf_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
 	return FALSE;
 
       mips_elf_hash_table (info)->use_rld_obj_head = TRUE;
+      mips_elf_hash_table (info)->rld_symbol = h;
     }
 
   /* If this is a mips16 text symbol, add 1 to the value to make it
@@ -7266,6 +7271,7 @@ _bfd_mips_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
 
 	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
 	    return FALSE;
+	  mips_elf_hash_table (info)->rld_symbol = h;
 	}
     }
 
@@ -9027,7 +9033,7 @@ _bfd_mips_elf_size_dynamic_sections (bfd *output_bfd,
 	{
 	  /* We add a room for __rld_map.  It will be filled in by the
 	     rtld to contain a pointer to the _r_debug structure.  */
-	  s->size += 4;
+	  s->size += MIPS_ELF_RLD_MAP_SIZE (output_bfd);
 	}
       else if (SGI_COMPAT (output_bfd)
 	       && CONST_STRNEQ (name, ".compact_rel"))
@@ -10030,31 +10036,6 @@ _bfd_mips_elf_finish_dynamic_symbol (bfd *output_bfd,
   if (IRIX_COMPAT (output_bfd) == ict_irix6)
     mips_elf_irix6_finish_dynamic_symbol (output_bfd, name, sym);
 
-  if (! info->shared)
-    {
-      if (! mips_elf_hash_table (info)->use_rld_obj_head
-	  && (strcmp (name, "__rld_map") == 0
-	      || strcmp (name, "__RLD_MAP") == 0))
-	{
-	  asection *s = bfd_get_section_by_name (dynobj, ".rld_map");
-	  BFD_ASSERT (s != NULL);
-	  sym->st_value = s->output_section->vma + s->output_offset;
-	  bfd_put_32 (output_bfd, 0, s->contents);
-	  if (mips_elf_hash_table (info)->rld_value == 0)
-	    mips_elf_hash_table (info)->rld_value = sym->st_value;
-	}
-      else if (mips_elf_hash_table (info)->use_rld_obj_head
-	       && strcmp (name, "__rld_obj_head") == 0)
-	{
-	  /* IRIX6 does not use a .rld_map section.  */
-	  if (IRIX_COMPAT (output_bfd) == ict_irix5
-              || IRIX_COMPAT (output_bfd) == ict_none)
-	    BFD_ASSERT (bfd_get_section_by_name (dynobj, ".rld_map")
-			!= NULL);
-	  mips_elf_hash_table (info)->rld_value = sym->st_value;
-	}
-    }
-
   /* Keep dynamic MIPS16 symbols odd.  This allows the dynamic linker to
      treat MIPS16 symbols like any other.  */
   if (ELF_ST_IS_MIPS16 (sym->st_other))
@@ -10517,7 +10498,19 @@ _bfd_mips_elf_finish_dynamic_sections (bfd *output_bfd,
 	      break;
 
 	    case DT_MIPS_RLD_MAP:
-	      dyn.d_un.d_ptr = mips_elf_hash_table (info)->rld_value;
+	      {
+		struct elf_link_hash_entry *h;
+		h = mips_elf_hash_table (info)->rld_symbol;
+		if (!h)
+		  {
+		    dyn_to_skip = MIPS_ELF_DYN_SIZE (dynobj);
+		    swap_out_p = FALSE;
+		    break;
+		  }
+		s = h->root.u.def.section;
+		dyn.d_un.d_ptr = (s->output_section->vma + s->output_offset
+				  + h->root.u.def.value);
+	      }
 	      break;
 
 	    case DT_MIPS_OPTIONS:
@@ -12794,7 +12787,7 @@ _bfd_mips_elf_link_hash_table_create (bfd *abfd)
   ret->procedure_count = 0;
   ret->compact_rel_size = 0;
   ret->use_rld_obj_head = FALSE;
-  ret->rld_value = 0;
+  ret->rld_symbol = NULL;
   ret->mips16_stubs_seen = FALSE;
   ret->use_plts_and_copy_relocs = FALSE;
   ret->is_vxworks = FALSE;
diff --git a/bfd/version.h b/bfd/version.h
index c6800ec..f246094 100644
--- a/bfd/version.h
+++ b/bfd/version.h
@@ -1,4 +1,4 @@
-#define BFD_VERSION_DATE 20111121
+#define BFD_VERSION_DATE 20111213
 #define BFD_VERSION @bfd_version@
 #define BFD_VERSION_STRING  @bfd_version_package@ @bfd_version_string@
 #define REPORT_BUGS_TO @report_bugs_to@
diff --git a/ld/testsuite/ChangeLog b/ld/testsuite/ChangeLog
index 233d962..1b84638 100644
--- a/ld/testsuite/ChangeLog
+++ b/ld/testsuite/ChangeLog
@@ -1,3 +1,8 @@
+2011-12-01  Hans-Peter Nilsson  <hp@axis.com>
+
+	* ld-cris/pic-gc-72.d: Revert last change to adjust for reverted
+	cause for last change.
+
 2011-11-10  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>
 
 	Apply mainline patches.
diff --git a/ld/testsuite/ld-cris/pic-gc-72.d b/ld/testsuite/ld-cris/pic-gc-72.d
index 7e72752..7c30980 100644
--- a/ld/testsuite/ld-cris/pic-gc-72.d
+++ b/ld/testsuite/ld-cris/pic-gc-72.d
@@ -19,11 +19,10 @@ Contents of section .dynsym:
 Contents of section .dynstr:
 #...
 Contents of section .text:
- 016e 0f050f05                             .*
+ 0188 0f050f05                             .*
 Contents of section .dynamic:
- 2174 .*
 #...
 Contents of section .got:
- 21cc 74210000 00000000 00000000           .*
+ 21e4 8c210000 00000000 00000000           .*
 Contents of section .data:
- 21d8 00000000                             .*
+ 21f0 00000000                             .*
diff --git a/opcodes/ChangeLog b/opcodes/ChangeLog
index a445030..26f759e 100644
--- a/opcodes/ChangeLog
+++ b/opcodes/ChangeLog
@@ -1,3 +1,8 @@
+2011-11-25  Pierre Muller  <muller@ics.u-strasbg.fr>
+
+	* mips-dis.c (print_insn_micromips): Rename local variable iprintf
+	to infprintf to avoid shadow warning.
+
 2011-10-27  Peter Bergner  <bergner@vnet.ibm.com>
 
 	* ppc-opc.c (powerpc_opcodes) <drrndq, drrndq., dtstexq, dctqpq,
diff --git a/opcodes/mips-dis.c b/opcodes/mips-dis.c
index 4e18d8a..72285de 100644
--- a/opcodes/mips-dis.c
+++ b/opcodes/mips-dis.c
@@ -2260,7 +2260,7 @@ print_insn_mips16 (bfd_vma memaddr, struct disassemble_info *info)
 static int
 print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
 {
-  const fprintf_ftype iprintf = info->fprintf_func;
+  const fprintf_ftype infprintf = info->fprintf_func;
   const struct mips_opcode *op, *opend;
   unsigned int lsb, msbd, msb;
   void *is = info->stream;
@@ -2307,7 +2307,7 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
       status = (*info->read_memory_func) (memaddr + 2, buffer, 2, info);
       if (status != 0)
 	{
-	  iprintf (is, "micromips 0x%x", higher);
+	  infprintf (is, "micromips 0x%x", higher);
 	  (*info->memory_error_func) (status, memaddr + 2, info);
 	  return -1;
 	}
@@ -2320,7 +2320,7 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
       status = (*info->read_memory_func) (memaddr + 4, buffer, 2, info);
       if (status != 0)
 	{
-	  iprintf (is, "micromips 0x%x", higher);
+	  infprintf (is, "micromips 0x%x", higher);
 	  (*info->memory_error_func) (status, memaddr + 4, info);
 	  return -1;
 	}
@@ -2328,7 +2328,7 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
 	insn = bfd_getb16 (buffer);
       else
 	insn = bfd_getl16 (buffer);
-      iprintf (is, "0x%x%04x (48-bit insn)", higher, insn);
+      infprintf (is, "0x%x%04x (48-bit insn)", higher, insn);
 
       info->insn_type = dis_noninsn;
       return 6;
@@ -2341,7 +2341,7 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
       status = (*info->read_memory_func) (memaddr + 2, buffer, 2, info);
       if (status != 0)
 	{
-	  iprintf (is, "micromips 0x%x", higher);
+	  infprintf (is, "micromips 0x%x", higher);
 	  (*info->memory_error_func) (status, memaddr + 2, info);
 	  return -1;
 	}
@@ -2371,9 +2371,9 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
 	{
 	  const char *s;
 
-	  iprintf (is, "%s", op->name);
+	  infprintf (is, "%s", op->name);
 	  if (op->args[0] != '\0')
-	    iprintf (is, "\t");
+	    infprintf (is, "\t");
 
 	  for (s = op->args; *s != '\0'; s++)
 	    {
@@ -2382,37 +2382,37 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
 		case ',':
 		case '(':
 		case ')':
-		  iprintf (is, "%c", *s);
+		  infprintf (is, "%c", *s);
 		  break;
 
 		case '.':
 		  delta = GET_OP (insn, OFFSET10);
 		  if (delta & 0x200)
 		    delta |= ~0x3ff;
-		  iprintf (is, "%d", delta);
+		  infprintf (is, "%d", delta);
 		  break;
 
 		case '1':
-		  iprintf (is, "0x%lx", GET_OP (insn, STYPE));
+		  infprintf (is, "0x%lx", GET_OP (insn, STYPE));
 		  break;
 
 		case '<':
-		  iprintf (is, "0x%lx", GET_OP (insn, SHAMT));
+		  infprintf (is, "0x%lx", GET_OP (insn, SHAMT));
 		  break;
 
 		case '\\':
-		  iprintf (is, "0x%lx", GET_OP (insn, 3BITPOS));
+		  infprintf (is, "0x%lx", GET_OP (insn, 3BITPOS));
 		  break;
 
 		case '|':
-		  iprintf (is, "0x%lx", GET_OP (insn, TRAP));
+		  infprintf (is, "0x%lx", GET_OP (insn, TRAP));
 		  break;
 
 		case '~':
 		  delta = GET_OP (insn, OFFSET12);
 		  if (delta & 0x800)
 		    delta |= ~0x7ff;
-		  iprintf (is, "%d", delta);
+		  infprintf (is, "%d", delta);
 		  break;
 
 		case 'a':
@@ -2433,34 +2433,34 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
 		case 'r':
 		case 's':
 		case 'v':
-		  iprintf (is, "%s", mips_gpr_names[GET_OP (insn, RS)]);
+		  infprintf (is, "%s", mips_gpr_names[GET_OP (insn, RS)]);
 		  break;
 
 		case 'c':
-		  iprintf (is, "0x%lx", GET_OP (insn, CODE));
+		  infprintf (is, "0x%lx", GET_OP (insn, CODE));
 		  break;
 
 		case 'd':
-		  iprintf (is, "%s", mips_gpr_names[GET_OP (insn, RD)]);
+		  infprintf (is, "%s", mips_gpr_names[GET_OP (insn, RD)]);
 		  break;
 
 		case 'h':
-		  iprintf (is, "0x%lx", GET_OP (insn, PREFX));
+		  infprintf (is, "0x%lx", GET_OP (insn, PREFX));
 		  break;
 
 		case 'i':
 		case 'u':
-		  iprintf (is, "0x%lx", GET_OP (insn, IMMEDIATE));
+		  infprintf (is, "0x%lx", GET_OP (insn, IMMEDIATE));
 		  break;
 
 		case 'j': /* Same as i, but sign-extended.  */
 		case 'o':
 		  delta = (GET_OP (insn, DELTA) ^ 0x8000) - 0x8000;
-		  iprintf (is, "%d", delta);
+		  infprintf (is, "%d", delta);
 		  break;
 
 		case 'k':
-		  iprintf (is, "0x%x", GET_OP (insn, CACHE));
+		  infprintf (is, "0x%x", GET_OP (insn, CACHE));
 		  break;
 
 		case 'n':
@@ -2472,26 +2472,26 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
 		    if (s_reg_encode != 0)
 		      {
 			if (s_reg_encode == 1)
-			  iprintf (is, "%s", mips_gpr_names[16]);
+			  infprintf (is, "%s", mips_gpr_names[16]);
 			else if (s_reg_encode < 9)
-			  iprintf (is, "%s-%s",
+			  infprintf (is, "%s-%s",
 				   mips_gpr_names[16],
 				   mips_gpr_names[15 + s_reg_encode]);
 			else if (s_reg_encode == 9)
-			  iprintf (is, "%s-%s,%s",
+			  infprintf (is, "%s-%s,%s",
 				   mips_gpr_names[16],
 				   mips_gpr_names[23],
 				   mips_gpr_names[30]);
 			else
-			  iprintf (is, "UNKNOWN");
+			  infprintf (is, "UNKNOWN");
 		      }
 
 		    if (immed & 0x10) /* For ra.  */
 		      {
 			if (s_reg_encode == 0)
-			  iprintf (is, "%s", mips_gpr_names[31]);
+			  infprintf (is, "%s", mips_gpr_names[31]);
 			else
-			  iprintf (is, ",%s", mips_gpr_names[31]);
+			  infprintf (is, ",%s", mips_gpr_names[31]);
 		      }
 		    break;
 		  }
@@ -2504,32 +2504,32 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
 		  break;
 
 		case 'q':
-		  iprintf (is, "0x%lx", GET_OP (insn, CODE2));
+		  infprintf (is, "0x%lx", GET_OP (insn, CODE2));
 		  break;
 
 		case 't':
 		case 'w':
-		  iprintf (is, "%s", mips_gpr_names[GET_OP (insn, RT)]);
+		  infprintf (is, "%s", mips_gpr_names[GET_OP (insn, RT)]);
 		  break;
 
 		case 'y':
-		  iprintf (is, "%s", mips_gpr_names[GET_OP (insn, RS3)]);
+		  infprintf (is, "%s", mips_gpr_names[GET_OP (insn, RS3)]);
 		  break;
 
 		case 'z':
-		  iprintf (is, "%s", mips_gpr_names[0]);
+		  infprintf (is, "%s", mips_gpr_names[0]);
 		  break;
 
 		case 'B':
-		  iprintf (is, "0x%lx", GET_OP (insn, CODE10));
+		  infprintf (is, "0x%lx", GET_OP (insn, CODE10));
 		  break;
 
 		case 'C':
-		  iprintf (is, "0x%lx", GET_OP (insn, COPZ));
+		  infprintf (is, "0x%lx", GET_OP (insn, COPZ));
 		  break;
 
 		case 'D':
-		  iprintf (is, "%s", mips_fpr_names[GET_OP (insn, FD)]);
+		  infprintf (is, "%s", mips_fpr_names[GET_OP (insn, FD)]);
 		  break;
 
 		case 'E':
@@ -2540,7 +2540,7 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
 		    'T' format.  Therefore, until we gain understanding of
 		    cp2 register names, we can simply print the register
 		    numbers.  */
-		  iprintf (is, "$%ld", GET_OP (insn, RT));
+		  infprintf (is, "$%ld", GET_OP (insn, RT));
 		  break;
 
 		case 'G':
@@ -2559,44 +2559,44 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
 		    case 0x000002fc:				/* mtc0  */
 		    case 0x580000fc:				/* dmfc0 */
 		    case 0x580002fc:				/* dmtc0 */
-		      iprintf (is, "%s", mips_cp0_names[GET_OP (insn, RS)]);
+		      infprintf (is, "%s", mips_cp0_names[GET_OP (insn, RS)]);
 		      break;
 		    default:
-		      iprintf (is, "$%ld", GET_OP (insn, RS));
+		      infprintf (is, "$%ld", GET_OP (insn, RS));
 		      break;
 		    }
 		  break;
 
 		case 'H':
-		  iprintf (is, "%ld", GET_OP (insn, SEL));
+		  infprintf (is, "%ld", GET_OP (insn, SEL));
 		  break;
 
 		case 'K':
-		  iprintf (is, "%s", mips_hwr_names[GET_OP (insn, RS)]);
+		  infprintf (is, "%s", mips_hwr_names[GET_OP (insn, RS)]);
 		  break;
 
 		case 'M':
-		  iprintf (is, "$fcc%ld", GET_OP (insn, CCC));
+		  infprintf (is, "$fcc%ld", GET_OP (insn, CCC));
 		  break;
 
 		case 'N':
-		  iprintf (is,
+		  infprintf (is,
 			   (op->pinfo & (FP_D | FP_S)) != 0
 			   ? "$fcc%ld" : "$cc%ld",
 			   GET_OP (insn, BCC));
 		  break;
 
 		case 'R':
-		  iprintf (is, "%s", mips_fpr_names[GET_OP (insn, FR)]);
+		  infprintf (is, "%s", mips_fpr_names[GET_OP (insn, FR)]);
 		  break;
 
 		case 'S':
 		case 'V':
-		  iprintf (is, "%s", mips_fpr_names[GET_OP (insn, FS)]);
+		  infprintf (is, "%s", mips_fpr_names[GET_OP (insn, FS)]);
 		  break;
 
 		case 'T':
-		  iprintf (is, "%s", mips_fpr_names[GET_OP (insn, FT)]);
+		  infprintf (is, "%s", mips_fpr_names[GET_OP (insn, FT)]);
 		  break;
 
 		case '+':
@@ -2606,18 +2606,18 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
 		    {
 		    case 'A':
 		      lsb = GET_OP (insn, EXTLSB);
-		      iprintf (is, "0x%x", lsb);
+		      infprintf (is, "0x%x", lsb);
 		      break;
 
 		    case 'B':
 		      msb = GET_OP (insn, INSMSB);
-		      iprintf (is, "0x%x", msb - lsb + 1);
+		      infprintf (is, "0x%x", msb - lsb + 1);
 		      break;
 
 		    case 'C':
 		    case 'H':
 		      msbd = GET_OP (insn, EXTMSBD);
-		      iprintf (is, "0x%x", msbd + 1);
+		      infprintf (is, "0x%x", msbd + 1);
 		      break;
 
 		    case 'D':
@@ -2637,30 +2637,30 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
 						     mips_cp0sel_names_len,
 						     cp0reg, sel);
 			if (n != NULL)
-			  iprintf (is, "%s", n->name);
+			  infprintf (is, "%s", n->name);
 			else
-			  iprintf (is, "$%d,%d", cp0reg, sel);
+			  infprintf (is, "$%d,%d", cp0reg, sel);
 			break;
 		      }
 
 		    case 'E':
 		      lsb = GET_OP (insn, EXTLSB) + 32;
-		      iprintf (is, "0x%x", lsb);
+		      infprintf (is, "0x%x", lsb);
 		      break;
 
 		    case 'F':
 		      msb = GET_OP (insn, INSMSB) + 32;
-		      iprintf (is, "0x%x", msb - lsb + 1);
+		      infprintf (is, "0x%x", msb - lsb + 1);
 		      break;
 
 		    case 'G':
 		      msbd = GET_OP (insn, EXTMSBD) + 32;
-		      iprintf (is, "0x%x", msbd + 1);
+		      infprintf (is, "0x%x", msbd + 1);
 		      break;
 
 		    default:
 		      /* xgettext:c-format */
-		      iprintf (is,
+		      infprintf (is,
 			       _("# internal disassembler error, "
 				 "unrecognized modifier (+%c)"),
 			       *s);
@@ -2674,111 +2674,111 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
 		  switch (*s)
 		    {
 		    case 'a':	/* global pointer.  */
-		      iprintf (is, "%s", mips_gpr_names[28]);
+		      infprintf (is, "%s", mips_gpr_names[28]);
 		      break;
 
 		    case 'b':
 		      regno = micromips_to_32_reg_b_map[GET_OP (insn, MB)];
-		      iprintf (is, "%s", mips_gpr_names[regno]);
+		      infprintf (is, "%s", mips_gpr_names[regno]);
 		      break;
 
 		    case 'c':
 		      regno = micromips_to_32_reg_c_map[GET_OP (insn, MC)];
-		      iprintf (is, "%s", mips_gpr_names[regno]);
+		      infprintf (is, "%s", mips_gpr_names[regno]);
 		      break;
 
 		    case 'd':
 		      regno = micromips_to_32_reg_d_map[GET_OP (insn, MD)];
-		      iprintf (is, "%s", mips_gpr_names[regno]);
+		      infprintf (is, "%s", mips_gpr_names[regno]);
 		      break;
 
 		    case 'e':
 		      regno = micromips_to_32_reg_e_map[GET_OP (insn, ME)];
-		      iprintf (is, "%s", mips_gpr_names[regno]);
+		      infprintf (is, "%s", mips_gpr_names[regno]);
 		      break;
 
 		    case 'f':
 		      /* Save lastregno for "mt" to print out later.  */
 		      lastregno = micromips_to_32_reg_f_map[GET_OP (insn, MF)];
-		      iprintf (is, "%s", mips_gpr_names[lastregno]);
+		      infprintf (is, "%s", mips_gpr_names[lastregno]);
 		      break;
 
 		    case 'g':
 		      regno = micromips_to_32_reg_g_map[GET_OP (insn, MG)];
-		      iprintf (is, "%s", mips_gpr_names[regno]);
+		      infprintf (is, "%s", mips_gpr_names[regno]);
 		      break;
 
 		    case 'h':
 		      regno = micromips_to_32_reg_h_map[GET_OP (insn, MH)];
-		      iprintf (is, "%s", mips_gpr_names[regno]);
+		      infprintf (is, "%s", mips_gpr_names[regno]);
 		      break;
 
 		    case 'i':
 		      regno = micromips_to_32_reg_i_map[GET_OP (insn, MI)];
-		      iprintf (is, "%s", mips_gpr_names[regno]);
+		      infprintf (is, "%s", mips_gpr_names[regno]);
 		      break;
 
 		    case 'j':
-		      iprintf (is, "%s", mips_gpr_names[GET_OP (insn, MJ)]);
+		      infprintf (is, "%s", mips_gpr_names[GET_OP (insn, MJ)]);
 		      break;
 
 		    case 'l':
 		      regno = micromips_to_32_reg_l_map[GET_OP (insn, ML)];
-		      iprintf (is, "%s", mips_gpr_names[regno]);
+		      infprintf (is, "%s", mips_gpr_names[regno]);
 		      break;
 
 		    case 'm':
 		      regno = micromips_to_32_reg_m_map[GET_OP (insn, MM)];
-		      iprintf (is, "%s", mips_gpr_names[regno]);
+		      infprintf (is, "%s", mips_gpr_names[regno]);
 		      break;
 
 		    case 'n':
 		      regno = micromips_to_32_reg_n_map[GET_OP (insn, MN)];
-		      iprintf (is, "%s", mips_gpr_names[regno]);
+		      infprintf (is, "%s", mips_gpr_names[regno]);
 		      break;
 
 		    case 'p':
 		      /* Save lastregno for "mt" to print out later.  */
 		      lastregno = GET_OP (insn, MP);
-		      iprintf (is, "%s", mips_gpr_names[lastregno]);
+		      infprintf (is, "%s", mips_gpr_names[lastregno]);
 		      break;
 
 		    case 'q':
 		      regno = micromips_to_32_reg_q_map[GET_OP (insn, MQ)];
-		      iprintf (is, "%s", mips_gpr_names[regno]);
+		      infprintf (is, "%s", mips_gpr_names[regno]);
 		      break;
 
 		    case 'r':	/* program counter.  */
-		      iprintf (is, "$pc");
+		      infprintf (is, "$pc");
 		      break;
 
 		    case 's':	/* stack pointer.  */
 		      lastregno = 29;
-		      iprintf (is, "%s", mips_gpr_names[29]);
+		      infprintf (is, "%s", mips_gpr_names[29]);
 		      break;
 
 		    case 't':
-		      iprintf (is, "%s", mips_gpr_names[lastregno]);
+		      infprintf (is, "%s", mips_gpr_names[lastregno]);
 		      break;
 
 		    case 'z':	/* $0.  */
-		      iprintf (is, "%s", mips_gpr_names[0]);
+		      infprintf (is, "%s", mips_gpr_names[0]);
 		      break;
 
 		    case 'A':
 		      /* Sign-extend the immediate.  */
 		      immed = ((GET_OP (insn, IMMA) ^ 0x40) - 0x40) << 2;
-		      iprintf (is, "%d", immed);
+		      infprintf (is, "%d", immed);
 		      break;
 
 		    case 'B':
 		      immed = micromips_imm_b_map[GET_OP (insn, IMMB)];
-		      iprintf (is, "%d", immed);
+		      infprintf (is, "%d", immed);
 		      break;
 
 		    case 'C':
 		      immed = micromips_imm_c_map[GET_OP (insn, IMMC)];
-		      iprintf (is, "0x%lx", immed);
+		      infprintf (is, "0x%lx", immed);
 		      break;
 
 		    case 'D':
@@ -2797,50 +2797,50 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
 
 		    case 'F':
 		      immed = GET_OP (insn, IMMF);
-		      iprintf (is, "0x%x", immed);
+		      infprintf (is, "0x%x", immed);
 		      break;
 
 		    case 'G':
 		      immed = (insn >> MICROMIPSOP_SH_IMMG) + 1;
 		      immed = (immed & MICROMIPSOP_MASK_IMMG) - 1;
-		      iprintf (is, "%d", immed);
+		      infprintf (is, "%d", immed);
 		      break;
 
 		    case 'H':
 		      immed = GET_OP (insn, IMMH) << 1;
-		      iprintf (is, "%d", immed);
+		      infprintf (is, "%d", immed);
 		      break;
 
 		    case 'I':
 		      immed = (insn >> MICROMIPSOP_SH_IMMI) + 1;
 		      immed = (immed & MICROMIPSOP_MASK_IMMI) - 1;
-		      iprintf (is, "%d", immed);
+		      infprintf (is, "%d", immed);
 		      break;
 
 		    case 'J':
 		      immed = GET_OP (insn, IMMJ) << 2;
-		      iprintf (is, "%d", immed);
+		      infprintf (is, "%d", immed);
 		      break;
 
 		    case 'L':
 		      immed = GET_OP (insn, IMML);
-		      iprintf (is, "%d", immed);
+		      infprintf (is, "%d", immed);
 		      break;
 
 		    case 'M':
 		      immed = (insn >> MICROMIPSOP_SH_IMMM) - 1;
 		      immed = (immed & MICROMIPSOP_MASK_IMMM) + 1;
-		      iprintf (is, "%d", immed);
+		      infprintf (is, "%d", immed);
 		      break;
 
 		    case 'N':
 		      immed = GET_OP (insn, IMMN);
 		      if (immed == 0)
-			iprintf (is, "%s,%s",
+			infprintf (is, "%s,%s",
 				 mips_gpr_names[16],
 				 mips_gpr_names[31]);
 		      else
-			iprintf (is, "%s-%s,%s",
+			infprintf (is, "%s-%s,%s",
 				 mips_gpr_names[16],
 				 mips_gpr_names[16 + immed],
 				 mips_gpr_names[31]);
@@ -2848,35 +2848,35 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
 
 		    case 'O':
 		      immed = GET_OP (insn, IMMO);
-		      iprintf (is, "0x%x", immed);
+		      infprintf (is, "0x%x", immed);
 		      break;
 
 		    case 'P':
 		      immed = GET_OP (insn, IMMP) << 2;
-		      iprintf (is, "%d", immed);
+		      infprintf (is, "%d", immed);
 		      break;
 
 		    case 'Q':
 		      /* Sign-extend the immediate.  */
 		      immed = (GET_OP (insn, IMMQ) ^ 0x400000) - 0x400000;
 		      immed <<= 2;
-		      iprintf (is, "%d", immed);
+		      infprintf (is, "%d", immed);
 		      break;
 
 		    case 'U':
 		      immed = GET_OP (insn, IMMU) << 2;
-		      iprintf (is, "%d", immed);
+		      infprintf (is, "%d", immed);
 		      break;
 
 		    case 'W':
 		      immed = GET_OP (insn, IMMW) << 2;
-		      iprintf (is, "%d", immed);
+		      infprintf (is, "%d", immed);
 		      break;
 
 		    case 'X':
 		      /* Sign-extend the immediate.  */
 		      immed = (GET_OP (insn, IMMX) ^ 0x8) - 0x8;
-		      iprintf (is, "%d", immed);
+		      infprintf (is, "%d", immed);
 		      break;
 
 		    case 'Y':
@@ -2885,12 +2885,12 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
 		      if (immed >= -2 && immed <= 1)
 			immed ^= 0x100;
 		      immed = immed << 2;
-		      iprintf (is, "%d", immed);
+		      infprintf (is, "%d", immed);
 		      break;
 
 		    default:
 		      /* xgettext:c-format */
-		      iprintf (is,
+		      infprintf (is,
 			       _("# internal disassembler error, "
 				 "unrecognized modifier (m%c)"),
 			       *s);
@@ -2900,7 +2900,7 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
 
 		default:
 		  /* xgettext:c-format */
-		  iprintf (is,
+		  infprintf (is,
 			   _("# internal disassembler error, "
 			     "unrecognized modifier (%c)"),
 			   *s);
@@ -2937,7 +2937,7 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
     }
 #undef GET_OP
 
-  iprintf (is, "0x%x", insn);
+  infprintf (is, "0x%x", insn);
   info->insn_type = dis_noninsn;
 
   return length;
-- 
1.7.3.2

