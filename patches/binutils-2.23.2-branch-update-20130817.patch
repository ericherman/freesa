From af822e80bfbc768943687344a1b8ffb21c577751 Mon Sep 17 00:00:00 2001
From: Brett Neumeier <brett@neumeier.us>
Date: Sat, 17 Aug 2013 13:12:19 -0500
Subject: [PATCH] binutils 2.23.2 with branch updates through 2013-08-17

---
 bfd/ChangeLog                          |   50 +-
 bfd/Makefile.am                        |    2 +-
 bfd/Makefile.in                        |    2 +-
 bfd/bfd-in.h                           |    6 +-
 bfd/bfd-in2.h                          |    6 +-
 bfd/doc/bfd.info                       |  132 +-
 bfd/elf32-arm.c                        | 3005 ++++++++++++++++----------------
 bfd/elflink.c                          |  103 +-
 bfd/version.h                          |    2 +-
 gas/ChangeLog                          |   36 +
 gas/config/tc-aarch64.c                |   10 +-
 gas/config/tc-arm.c                    |   29 +-
 gas/testsuite/ChangeLog                |   43 +
 gas/testsuite/gas/aarch64/diagnostic.l |    4 +-
 gas/testsuite/gas/aarch64/diagnostic.s |    2 +-
 gas/testsuite/gas/aarch64/illegal.l    |    1 -
 gas/testsuite/gas/aarch64/movi.d       |    3 +
 gas/testsuite/gas/aarch64/movi.s       |    5 +
 gas/testsuite/gas/aarch64/sysreg.d     |    3 +
 gas/testsuite/gas/aarch64/sysreg.s     |    4 +
 gas/testsuite/gas/arm/macro-pld.d      |    1 +
 gas/testsuite/gas/arm/macro-pld.s      |    1 +
 gas/testsuite/gas/arm/neon-ldst-es.d   |    1 +
 gas/testsuite/gas/arm/neon-ldst-es.s   |    3 +
 gold/ChangeLog                         |   37 +
 gold/i386.cc                           |   12 +
 gold/layout.cc                         |   52 +-
 gold/options.cc                        |  233 +--
 gold/options.h                         |  454 ++---
 gold/parameters.cc                     |   16 +-
 gold/parameters.h                      |    5 +-
 gold/x86_64.cc                         |   13 +
 ld/ChangeLog                           |    5 +
 ld/emultempl/armelf.em                 |   55 +-
 ld/testsuite/ChangeLog                 |   30 +
 ld/testsuite/ld-arm/arm-elf.exp        |  365 ++--
 ld/testsuite/ld-arm/ifunc-1.rd         |    2 +-
 ld/testsuite/ld-arm/ifunc-2.rd         |    4 +-
 ld/testsuite/ld-arm/ifunc-5.rd         |    2 +-
 ld/testsuite/ld-arm/ifunc-6.rd         |    4 +-
 opcodes/ChangeLog                      |    9 +
 opcodes/aarch64-asm.c                  |    1 -
 opcodes/aarch64-opc.c                  |    6 +-
 43 files changed, 2608 insertions(+), 2151 deletions(-)

diff --git a/bfd/ChangeLog b/bfd/ChangeLog
index 8b584d9..58a119a 100644
--- a/bfd/ChangeLog
+++ b/bfd/ChangeLog
@@ -1,3 +1,51 @@
+2013-07-25  Alan Modra  <amodra@gmail.com>
+
+	PR ld/15762
+	PR ld/12761
+	* elflink.c (elf_link_add_object_symbols): Correct test in
+	last patch.  Remove unnecessary code.
+
+2013-07-20  Alan Modra  <amodra@gmail.com>
+
+	PR ld/15762
+	PR ld/12761
+	* elflink.c (elf_link_add_object_symbols): Don't clobber
+	.gnu.warning.symbol sections when shared.
+
+2013-07-18  Roland McGrath  <mcgrathr@google.com>
+
+	* elf32-arm.c (elf32_arm_stub_long_branch_arm_nacl): New variable.
+	(elf32_arm_stub_long_branch_arm_nacl_pic): New variable.
+	(arm_build_one_stub): Increase MAXRELOCS to 3.
+	(arm_type_of_stub): Use them if GLOBALS->nacl_p.
+	(struct elf32_arm_link_hash_table): Give add_stub_section member's
+	pointee type a third argument.
+	(elf32_arm_create_or_find_stub_sec): Update caller.
+	(elf32_arm_size_stubs): Update argument type.
+	* bfd-in.h (elf32_arm_size_stubs): Update decl.
+	* bfd-in2.h: Regenerate.
+	* libbfd.h: Regenerate.
+
+2013-05-28  Will Newton  <will.newton@linaro.org>
+
+	* elf32-arm.c (elf32_arm_populate_plt_entry): Call
+	elf32_arm_add_dynreloc when emitting R_ARM_IRELATIVE relocs.
+
+2013-04-24  Roland McGrath  <mcgrathr@google.com>
+
+	* elf32-arm.c (elf32_arm_allocate_plt_entry): If HTAB->nacl_p,
+	allocate space for PLT header even if IS_IPLT_ENTRY.
+	(arm_nacl_put_plt0): New function, broken out of ...
+	(elf32_arm_finish_dynamic_sections): ... here.  Call it.
+	If HTAB->nacl_p, set up the PLT header in .iplt too.
+	(elf32_arm_output_arch_local_syms): If HTAB->nacl_p, write
+	a mapping symbol for the start of .iplt too.
+
+2013-03-25  Tristan Gingold  <gingold@adacore.com>
+
+	* Makefile.am (RELEASE): Unset.
+	* Makefile.in: Regenerate.
+
 2013-03-25  Tristan Gingold  <gingold@adacore.com>
 
 	* configure.in: Bump version to 2.23.2
@@ -256,7 +304,7 @@
 
 2012-11-19  Joey Ye  <joey.ye@arm.com>
 
-	* elf32-arm.c (elf32_arm_final_link_relocate, 
+	* elf32-arm.c (elf32_arm_final_link_relocate,
 	case R_ARM_THM_ALU_PREL_11_0, case R_ARM_THM_PC12): Align address of
 	the place being relocated.
 	(elf32_arm_final_link_relocate, case R_ARM_THM_PC8): Align address
diff --git a/bfd/Makefile.am b/bfd/Makefile.am
index 9ab2aa9..49f9662 100644
--- a/bfd/Makefile.am
+++ b/bfd/Makefile.am
@@ -4,7 +4,7 @@ AUTOMAKE_OPTIONS = 1.11 no-dist foreign
 ACLOCAL_AMFLAGS = -I . -I .. -I ../config
 
 # Uncomment the following line when doing a release.
-RELEASE=y
+# RELEASE=y
 
 INCDIR = $(srcdir)/../include
 CSEARCH = -I. -I$(srcdir) -I$(INCDIR)
diff --git a/bfd/Makefile.in b/bfd/Makefile.in
index 9990275..5718fab 100644
--- a/bfd/Makefile.in
+++ b/bfd/Makefile.in
@@ -320,7 +320,7 @@ AUTOMAKE_OPTIONS = 1.11 no-dist foreign
 ACLOCAL_AMFLAGS = -I . -I .. -I ../config
 
 # Uncomment the following line when doing a release.
-RELEASE = y
+# RELEASE=y
 INCDIR = $(srcdir)/../include
 CSEARCH = -I. -I$(srcdir) -I$(INCDIR)
 SUBDIRS = doc po
diff --git a/bfd/bfd-in.h b/bfd/bfd-in.h
index a8c2db1..fa780d7 100644
--- a/bfd/bfd-in.h
+++ b/bfd/bfd-in.h
@@ -2,7 +2,7 @@
 
    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,
-   2012 Free Software Foundation, Inc.
+   2012, 2013 Free Software Foundation, Inc.
 
    Contributed by Cygnus Support.
 
@@ -909,7 +909,8 @@ extern void elf32_arm_next_input_section
   (struct bfd_link_info *, struct bfd_section *);
 extern bfd_boolean elf32_arm_size_stubs
   (bfd *, bfd *, struct bfd_link_info *, bfd_signed_vma,
-   struct bfd_section * (*) (const char *, struct bfd_section *), void (*) (void));
+   struct bfd_section * (*) (const char *, struct bfd_section *, unsigned int),
+   void (*) (void));
 extern bfd_boolean elf32_arm_build_stubs
   (struct bfd_link_info *);
 
@@ -991,4 +992,3 @@ struct coff_comdat_info
 
 extern struct coff_comdat_info *bfd_coff_get_comdat_section
   (bfd *, struct bfd_section *);
-
diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index e496083..82f265e 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -9,7 +9,7 @@
 
    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,
-   2012 Free Software Foundation, Inc.
+   2012, 2013 Free Software Foundation, Inc.
 
    Contributed by Cygnus Support.
 
@@ -916,7 +916,8 @@ extern void elf32_arm_next_input_section
   (struct bfd_link_info *, struct bfd_section *);
 extern bfd_boolean elf32_arm_size_stubs
   (bfd *, bfd *, struct bfd_link_info *, bfd_signed_vma,
-   struct bfd_section * (*) (const char *, struct bfd_section *), void (*) (void));
+   struct bfd_section * (*) (const char *, struct bfd_section *, unsigned int),
+   void (*) (void));
 extern bfd_boolean elf32_arm_build_stubs
   (struct bfd_link_info *);
 
@@ -998,7 +999,6 @@ struct coff_comdat_info
 
 extern struct coff_comdat_info *bfd_coff_get_comdat_section
   (bfd *, struct bfd_section *);
-
 /* Extracted from init.c.  */
 void bfd_init (void);
 
diff --git a/bfd/doc/bfd.info b/bfd/doc/bfd.info
index ce01eda..7e11660 100644
--- a/bfd/doc/bfd.info
+++ b/bfd/doc/bfd.info
@@ -1,4 +1,4 @@
-This is bfd.info, produced by makeinfo version 4.8 from bfd.texinfo.
+This is bfd.info, produced by makeinfo version 4.13 from bfd.texinfo.
 
 INFO-DIR-SECTION Software development
 START-INFO-DIR-ENTRY
@@ -8434,9 +8434,9 @@ The linker proper will call the `_bfd_link_add_symbols' entry point for
 each object file or archive which is to be linked (typically these are
 the files named on the command line, but some may also come from the
 linker script).  The entry point is responsible for examining the file.
-For an object file, BFD must add any relevant symbol information to
-the hash table.  For an archive, BFD must determine which elements of
-the archive should be used and adding them to the link.
+For an object file, BFD must add any relevant symbol information to the
+hash table.  For an archive, BFD must determine which elements of the
+archive should be used and adding them to the link.
 
    The a.out version of this entry point is
 `NAME(aout,link_add_symbols)'.
@@ -12742,67 +12742,67 @@ BFD Index
 
 
 Tag Table:
-Node: Top1089
-Node: Overview1428
-Node: History2479
-Node: How It Works3425
-Node: What BFD Version 2 Can Do4968
-Node: BFD information loss6283
-Node: Canonical format8815
-Node: BFD front end13187
-Node: Memory Usage47553
-Node: Initialization48781
-Node: Sections49240
-Node: Section Input49723
-Node: Section Output51088
-Node: typedef asection53574
-Node: section prototypes78781
-Node: Symbols89038
-Node: Reading Symbols90633
-Node: Writing Symbols91740
-Node: Mini Symbols93481
-Node: typedef asymbol94455
-Node: symbol handling functions100514
-Node: Archives105856
-Node: Formats109582
-Node: Relocations112530
-Node: typedef arelent113257
-Node: howto manager128893
-Node: Core Files227332
-Node: Targets229370
-Node: bfd_target231340
-Node: Architectures254562
-Node: Opening and Closing280438
-Node: Internal291957
-Node: File Caching298302
-Node: Linker Functions300216
-Node: Creating a Linker Hash Table301889
-Node: Adding Symbols to the Hash Table303627
-Node: Differing file formats304527
-Node: Adding symbols from an object file306252
-Node: Adding symbols from an archive308403
-Node: Performing the Final Link311332
-Node: Information provided by the linker312574
-Node: Relocating the section contents313728
-Node: Writing the symbol table315479
-Node: Hash Tables319865
-Node: Creating and Freeing a Hash Table321063
-Node: Looking Up or Entering a String322313
-Node: Traversing a Hash Table323566
-Node: Deriving a New Hash Table Type324355
-Node: Define the Derived Structures325421
-Node: Write the Derived Creation Routine326502
-Node: Write Other Derived Routines329126
-Node: BFD back ends330441
-Node: What to Put Where330711
-Node: aout330891
-Node: coff337209
-Node: elf365642
-Node: mmo366043
-Node: File layout366971
-Node: Symbol-table372618
-Node: mmo section mapping376387
-Node: GNU Free Documentation License380039
-Node: BFD Index405122
+Node: Top1090
+Node: Overview1429
+Node: History2480
+Node: How It Works3426
+Node: What BFD Version 2 Can Do4969
+Node: BFD information loss6284
+Node: Canonical format8816
+Node: BFD front end13188
+Node: Memory Usage47554
+Node: Initialization48782
+Node: Sections49241
+Node: Section Input49724
+Node: Section Output51089
+Node: typedef asection53575
+Node: section prototypes78782
+Node: Symbols89039
+Node: Reading Symbols90634
+Node: Writing Symbols91741
+Node: Mini Symbols93482
+Node: typedef asymbol94456
+Node: symbol handling functions100515
+Node: Archives105857
+Node: Formats109583
+Node: Relocations112531
+Node: typedef arelent113258
+Node: howto manager128894
+Node: Core Files227333
+Node: Targets229371
+Node: bfd_target231341
+Node: Architectures254563
+Node: Opening and Closing280439
+Node: Internal291958
+Node: File Caching298303
+Node: Linker Functions300217
+Node: Creating a Linker Hash Table301890
+Node: Adding Symbols to the Hash Table303628
+Node: Differing file formats304528
+Node: Adding symbols from an object file306253
+Node: Adding symbols from an archive308404
+Node: Performing the Final Link311333
+Node: Information provided by the linker312575
+Node: Relocating the section contents313729
+Node: Writing the symbol table315480
+Node: Hash Tables319866
+Node: Creating and Freeing a Hash Table321064
+Node: Looking Up or Entering a String322314
+Node: Traversing a Hash Table323567
+Node: Deriving a New Hash Table Type324356
+Node: Define the Derived Structures325422
+Node: Write the Derived Creation Routine326503
+Node: Write Other Derived Routines329127
+Node: BFD back ends330442
+Node: What to Put Where330712
+Node: aout330892
+Node: coff337210
+Node: elf365643
+Node: mmo366044
+Node: File layout366972
+Node: Symbol-table372619
+Node: mmo section mapping376388
+Node: GNU Free Documentation License380040
+Node: BFD Index405123
 
 End Tag Table
diff --git a/bfd/elf32-arm.c b/bfd/elf32-arm.c
index 2acf84c..c065945 100644
--- a/bfd/elf32-arm.c
+++ b/bfd/elf32-arm.c
@@ -1,6 +1,6 @@
 /* 32-bit ELF support for ARM
    Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
-   2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
+   2008, 2009, 2010, 2011, 2012, 2013 Free Software Foundation, Inc.
 
    This file is part of BFD, the Binary File Descriptor library.
 
@@ -327,160 +327,160 @@ static reloc_howto_type elf32_arm_howto_table_1[] =
   /* Dynamic TLS relocations.  */
 
   HOWTO (R_ARM_TLS_DTPMOD32,	/* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         32,                    /* bitsize */
-         FALSE,                 /* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_bitfield,/* complain_on_overflow */
-         bfd_elf_generic_reloc, /* special_function */
-         "R_ARM_TLS_DTPMOD32",	/* name */
-         TRUE,			/* partial_inplace */
-         0xffffffff,		/* src_mask */
-         0xffffffff,		/* dst_mask */
-         FALSE),                /* pcrel_offset */
+	 0,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 32,                    /* bitsize */
+	 FALSE,                 /* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_bitfield,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_ARM_TLS_DTPMOD32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),                /* pcrel_offset */
 
   HOWTO (R_ARM_TLS_DTPOFF32,	/* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         32,                    /* bitsize */
-         FALSE,                 /* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_bitfield,/* complain_on_overflow */
-         bfd_elf_generic_reloc, /* special_function */
-         "R_ARM_TLS_DTPOFF32",	/* name */
-         TRUE,			/* partial_inplace */
-         0xffffffff,		/* src_mask */
-         0xffffffff,		/* dst_mask */
-         FALSE),                /* pcrel_offset */
+	 0,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 32,                    /* bitsize */
+	 FALSE,                 /* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_bitfield,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_ARM_TLS_DTPOFF32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),                /* pcrel_offset */
 
   HOWTO (R_ARM_TLS_TPOFF32,	/* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         32,                    /* bitsize */
-         FALSE,                 /* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_bitfield,/* complain_on_overflow */
-         bfd_elf_generic_reloc, /* special_function */
-         "R_ARM_TLS_TPOFF32",	/* name */
-         TRUE,			/* partial_inplace */
-         0xffffffff,		/* src_mask */
-         0xffffffff,		/* dst_mask */
-         FALSE),                /* pcrel_offset */
+	 0,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 32,                    /* bitsize */
+	 FALSE,                 /* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_bitfield,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_ARM_TLS_TPOFF32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),                /* pcrel_offset */
 
   /* Relocs used in ARM Linux */
 
   HOWTO (R_ARM_COPY,		/* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         32,                    /* bitsize */
-         FALSE,                 /* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_bitfield,/* complain_on_overflow */
-         bfd_elf_generic_reloc, /* special_function */
-         "R_ARM_COPY",		/* name */
-         TRUE,			/* partial_inplace */
-         0xffffffff,		/* src_mask */
-         0xffffffff,		/* dst_mask */
-         FALSE),                /* pcrel_offset */
+	 0,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 32,                    /* bitsize */
+	 FALSE,                 /* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_bitfield,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_ARM_COPY",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),                /* pcrel_offset */
 
   HOWTO (R_ARM_GLOB_DAT,	/* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         32,                    /* bitsize */
-         FALSE,                 /* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_bitfield,/* complain_on_overflow */
-         bfd_elf_generic_reloc, /* special_function */
-         "R_ARM_GLOB_DAT",	/* name */
-         TRUE,			/* partial_inplace */
-         0xffffffff,		/* src_mask */
-         0xffffffff,		/* dst_mask */
-         FALSE),                /* pcrel_offset */
+	 0,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 32,                    /* bitsize */
+	 FALSE,                 /* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_bitfield,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_ARM_GLOB_DAT",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),                /* pcrel_offset */
 
   HOWTO (R_ARM_JUMP_SLOT,	/* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         32,                    /* bitsize */
-         FALSE,                 /* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_bitfield,/* complain_on_overflow */
-         bfd_elf_generic_reloc, /* special_function */
-         "R_ARM_JUMP_SLOT",	/* name */
-         TRUE,			/* partial_inplace */
-         0xffffffff,		/* src_mask */
-         0xffffffff,		/* dst_mask */
-         FALSE),                /* pcrel_offset */
+	 0,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 32,                    /* bitsize */
+	 FALSE,                 /* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_bitfield,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_ARM_JUMP_SLOT",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),                /* pcrel_offset */
 
   HOWTO (R_ARM_RELATIVE,	/* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         32,                    /* bitsize */
-         FALSE,                 /* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_bitfield,/* complain_on_overflow */
-         bfd_elf_generic_reloc, /* special_function */
-         "R_ARM_RELATIVE",	/* name */
-         TRUE,			/* partial_inplace */
-         0xffffffff,		/* src_mask */
-         0xffffffff,		/* dst_mask */
-         FALSE),                /* pcrel_offset */
+	 0,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 32,                    /* bitsize */
+	 FALSE,                 /* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_bitfield,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_ARM_RELATIVE",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),                /* pcrel_offset */
 
   HOWTO (R_ARM_GOTOFF32,	/* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         32,                    /* bitsize */
-         FALSE,                 /* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_bitfield,/* complain_on_overflow */
-         bfd_elf_generic_reloc, /* special_function */
-         "R_ARM_GOTOFF32",	/* name */
-         TRUE,			/* partial_inplace */
-         0xffffffff,		/* src_mask */
-         0xffffffff,		/* dst_mask */
-         FALSE),                /* pcrel_offset */
+	 0,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 32,                    /* bitsize */
+	 FALSE,                 /* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_bitfield,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_ARM_GOTOFF32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),                /* pcrel_offset */
 
   HOWTO (R_ARM_GOTPC,		/* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         32,                    /* bitsize */
-         TRUE,			/* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_bitfield,/* complain_on_overflow */
-         bfd_elf_generic_reloc, /* special_function */
-         "R_ARM_GOTPC",		/* name */
-         TRUE,			/* partial_inplace */
-         0xffffffff,		/* src_mask */
-         0xffffffff,		/* dst_mask */
-         TRUE),			/* pcrel_offset */
+	 0,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 32,                    /* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_bitfield,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_ARM_GOTPC",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
 
   HOWTO (R_ARM_GOT32,		/* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         32,                    /* bitsize */
-         FALSE,			/* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_bitfield,/* complain_on_overflow */
-         bfd_elf_generic_reloc, /* special_function */
-         "R_ARM_GOT32",		/* name */
-         TRUE,			/* partial_inplace */
-         0xffffffff,		/* src_mask */
-         0xffffffff,		/* dst_mask */
-         FALSE),		/* pcrel_offset */
+	 0,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 32,                    /* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_bitfield,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_ARM_GOT32",		/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
 
   HOWTO (R_ARM_PLT32,		/* type */
-         2,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         24,                    /* bitsize */
-         TRUE,			/* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_bitfield,/* complain_on_overflow */
-         bfd_elf_generic_reloc, /* special_function */
-         "R_ARM_PLT32",		/* name */
-         FALSE,			/* partial_inplace */
-         0x00ffffff,		/* src_mask */
-         0x00ffffff,		/* dst_mask */
-         TRUE),			/* pcrel_offset */
+	 2,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 24,                    /* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_bitfield,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_ARM_PLT32",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0x00ffffff,		/* src_mask */
+	 0x00ffffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
 
   HOWTO (R_ARM_CALL,		/* type */
 	 2,			/* rightshift */
@@ -1487,33 +1487,33 @@ static reloc_howto_type elf32_arm_howto_table_1[] =
 
   /* GNU extension to record C++ vtable member usage */
   HOWTO (R_ARM_GNU_VTENTRY,     /* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         0,                     /* bitsize */
-         FALSE,                 /* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_dont, /* complain_on_overflow */
-         _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
-         "R_ARM_GNU_VTENTRY",   /* name */
-         FALSE,                 /* partial_inplace */
-         0,                     /* src_mask */
-         0,                     /* dst_mask */
-         FALSE),                /* pcrel_offset */
+	 0,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 0,                     /* bitsize */
+	 FALSE,                 /* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
+	 "R_ARM_GNU_VTENTRY",   /* name */
+	 FALSE,                 /* partial_inplace */
+	 0,                     /* src_mask */
+	 0,                     /* dst_mask */
+	 FALSE),                /* pcrel_offset */
 
   /* GNU extension to record C++ vtable hierarchy */
   HOWTO (R_ARM_GNU_VTINHERIT, /* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         0,                     /* bitsize */
-         FALSE,                 /* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_dont, /* complain_on_overflow */
-         NULL,                  /* special_function */
-         "R_ARM_GNU_VTINHERIT", /* name */
-         FALSE,                 /* partial_inplace */
-         0,                     /* src_mask */
-         0,                     /* dst_mask */
-         FALSE),                /* pcrel_offset */
+	 0,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 0,                     /* bitsize */
+	 FALSE,                 /* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 NULL,                  /* special_function */
+	 "R_ARM_GNU_VTINHERIT", /* name */
+	 FALSE,                 /* partial_inplace */
+	 0,                     /* src_mask */
+	 0,                     /* dst_mask */
+	 FALSE),                /* pcrel_offset */
 
   HOWTO (R_ARM_THM_JUMP11,	/* type */
 	 1,			/* rightshift */
@@ -1545,74 +1545,74 @@ static reloc_howto_type elf32_arm_howto_table_1[] =
 
   /* TLS relocations */
   HOWTO (R_ARM_TLS_GD32,	/* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         32,                    /* bitsize */
-         FALSE,                 /* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_bitfield,/* complain_on_overflow */
-         NULL,			/* special_function */
-         "R_ARM_TLS_GD32",	/* name */
-         TRUE,			/* partial_inplace */
-         0xffffffff,		/* src_mask */
-         0xffffffff,		/* dst_mask */
-         FALSE),                /* pcrel_offset */
+	 0,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 32,                    /* bitsize */
+	 FALSE,                 /* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_bitfield,/* complain_on_overflow */
+	 NULL,			/* special_function */
+	 "R_ARM_TLS_GD32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),                /* pcrel_offset */
 
   HOWTO (R_ARM_TLS_LDM32,	/* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         32,                    /* bitsize */
-         FALSE,                 /* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_bitfield,/* complain_on_overflow */
-         bfd_elf_generic_reloc, /* special_function */
-         "R_ARM_TLS_LDM32",	/* name */
-         TRUE,			/* partial_inplace */
-         0xffffffff,		/* src_mask */
-         0xffffffff,		/* dst_mask */
-         FALSE),                /* pcrel_offset */
+	 0,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 32,                    /* bitsize */
+	 FALSE,                 /* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_bitfield,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_ARM_TLS_LDM32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),                /* pcrel_offset */
 
   HOWTO (R_ARM_TLS_LDO32,	/* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         32,                    /* bitsize */
-         FALSE,                 /* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_bitfield,/* complain_on_overflow */
-         bfd_elf_generic_reloc, /* special_function */
-         "R_ARM_TLS_LDO32",	/* name */
-         TRUE,			/* partial_inplace */
-         0xffffffff,		/* src_mask */
-         0xffffffff,		/* dst_mask */
-         FALSE),                /* pcrel_offset */
+	 0,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 32,                    /* bitsize */
+	 FALSE,                 /* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_bitfield,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_ARM_TLS_LDO32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),                /* pcrel_offset */
 
   HOWTO (R_ARM_TLS_IE32,	/* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         32,                    /* bitsize */
-         FALSE,                  /* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_bitfield,/* complain_on_overflow */
-         NULL,			/* special_function */
-         "R_ARM_TLS_IE32",	/* name */
-         TRUE,			/* partial_inplace */
-         0xffffffff,		/* src_mask */
-         0xffffffff,		/* dst_mask */
-         FALSE),                /* pcrel_offset */
+	 0,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 32,                    /* bitsize */
+	 FALSE,                  /* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_bitfield,/* complain_on_overflow */
+	 NULL,			/* special_function */
+	 "R_ARM_TLS_IE32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),                /* pcrel_offset */
 
   HOWTO (R_ARM_TLS_LE32,	/* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         32,                    /* bitsize */
-         FALSE,                 /* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_bitfield,/* complain_on_overflow */
-         bfd_elf_generic_reloc, /* special_function */
-         "R_ARM_TLS_LE32",	/* name */
-         TRUE,			/* partial_inplace */
-         0xffffffff,		/* src_mask */
-         0xffffffff,		/* dst_mask */
-         FALSE),                /* pcrel_offset */
+	 0,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 32,                    /* bitsize */
+	 FALSE,                 /* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_bitfield,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_ARM_TLS_LE32",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),                /* pcrel_offset */
 
   HOWTO (R_ARM_TLS_LDO12,	/* type */
 	 0,			/* rightshift */
@@ -1696,18 +1696,18 @@ static reloc_howto_type elf32_arm_howto_table_1[] =
 static reloc_howto_type elf32_arm_howto_table_2[1] =
 {
   HOWTO (R_ARM_IRELATIVE,	/* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         32,                    /* bitsize */
-         FALSE,                 /* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_bitfield,/* complain_on_overflow */
-         bfd_elf_generic_reloc, /* special_function */
-         "R_ARM_IRELATIVE",	/* name */
-         TRUE,			/* partial_inplace */
-         0xffffffff,		/* src_mask */
-         0xffffffff,		/* dst_mask */
-         FALSE)			/* pcrel_offset */
+	 0,                     /* rightshift */
+	 2,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 32,                    /* bitsize */
+	 FALSE,                 /* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_bitfield,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_ARM_IRELATIVE",	/* name */
+	 TRUE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE)			/* pcrel_offset */
 };
 
 /* 249-255 extended, currently unused, relocations:  */
@@ -2098,7 +2098,7 @@ static const unsigned long dl_tlsdesc_lazy_trampoline [] =
   0xe081100f, /* 2:   add     r1, pc			*/
   0xe12fff12, /*      bx      r2			*/
   0x00000014, /* 3:   .word  _GLOBAL_OFFSET_TABLE_ - 1b - 8
-		   		+ dl_tlsdesc_lazy_resolver(GOT)   */
+				+ dl_tlsdesc_lazy_resolver(GOT)   */
   0x00000018, /* 4:   .word  _GLOBAL_OFFSET_TABLE_ - 2b - 8 */
 };
 
@@ -2416,6 +2416,33 @@ static const insn_sequence elf32_arm_stub_long_branch_v4t_thumb_tls_pic[] =
   DATA_WORD (0, R_ARM_REL32, -4),    /* dcd  R_ARM_REL32(X) */
 };
 
+/* NaCl ARM -> ARM long branch stub.  */
+static const insn_sequence elf32_arm_stub_long_branch_arm_nacl[] =
+{
+  ARM_INSN (0xe59fc00c),		/* ldr	ip, [pc, #12] */
+  ARM_INSN (0xe3ccc13f),		/* bic	ip, ip, #0xc000000f */
+  ARM_INSN (0xe12fff1c),                /* bx	ip */
+  ARM_INSN (0xe320f000),                /* nop */
+  ARM_INSN (0xe125be70),                /* bkpt	0x5be0 */
+  DATA_WORD (0, R_ARM_ABS32, 0),        /* dcd	R_ARM_ABS32(X) */
+  DATA_WORD (0, R_ARM_NONE, 0),         /* .word 0 */
+  DATA_WORD (0, R_ARM_NONE, 0),         /* .word 0 */
+};
+
+/* NaCl ARM -> ARM long branch stub, PIC.  */
+static const insn_sequence elf32_arm_stub_long_branch_arm_nacl_pic[] =
+{
+  ARM_INSN (0xe59fc00c),		/* ldr	ip, [pc, #12] */
+  ARM_INSN (0xe08cc00f),                /* add	ip, ip, pc */
+  ARM_INSN (0xe3ccc13f),		/* bic	ip, ip, #0xc000000f */
+  ARM_INSN (0xe12fff1c),                /* bx	ip */
+  ARM_INSN (0xe125be70),                /* bkpt	0x5be0 */
+  DATA_WORD (0, R_ARM_REL32, 8),        /* dcd	R_ARM_REL32(X+8) */
+  DATA_WORD (0, R_ARM_NONE, 0),         /* .word 0 */
+  DATA_WORD (0, R_ARM_NONE, 0),         /* .word 0 */
+};
+
+
 /* Cortex-A8 erratum-workaround stubs.  */
 
 /* Stub used for conditional branches (which may be beyond +/-1MB away, so we
@@ -2492,6 +2519,8 @@ static const insn_sequence elf32_arm_stub_a8_veneer_blx[] =
   DEF_STUB(long_branch_thumb_only_pic) \
   DEF_STUB(long_branch_any_tls_pic) \
   DEF_STUB(long_branch_v4t_thumb_tls_pic) \
+  DEF_STUB(long_branch_arm_nacl) \
+  DEF_STUB(long_branch_arm_nacl_pic) \
   DEF_STUB(a8_veneer_b_cond) \
   DEF_STUB(a8_veneer_b) \
   DEF_STUB(a8_veneer_bl) \
@@ -2984,7 +3013,7 @@ struct elf32_arm_link_hash_table
   bfd *stub_bfd;
 
   /* Linker call-backs.  */
-  asection * (*add_stub_section) (const char *, asection *);
+  asection * (*add_stub_section) (const char *, asection *, unsigned int);
   void (*layout_sections_again) (void);
 
   /* Array to keep track of which stub sections have been created, and
@@ -3004,8 +3033,8 @@ struct elf32_arm_link_hash_table
 
 static struct bfd_hash_entry *
 elf32_arm_link_hash_newfunc (struct bfd_hash_entry * entry,
-                             struct bfd_hash_table * table,
-                             const char * string)
+			     struct bfd_hash_table * table,
+			     const char * string)
 {
   struct elf32_arm_link_hash_entry * ret =
     (struct elf32_arm_link_hash_entry *) entry;
@@ -3014,7 +3043,7 @@ elf32_arm_link_hash_newfunc (struct bfd_hash_entry * entry,
      subclass.  */
   if (ret == NULL)
     ret = (struct elf32_arm_link_hash_entry *)
-        bfd_hash_allocate (table, sizeof (struct elf32_arm_link_hash_entry));
+	bfd_hash_allocate (table, sizeof (struct elf32_arm_link_hash_entry));
   if (ret == NULL)
     return (struct bfd_hash_entry *) ret;
 
@@ -3188,7 +3217,7 @@ stub_hash_newfunc (struct bfd_hash_entry *entry,
   if (entry == NULL)
     {
       entry = (struct bfd_hash_entry *)
-          bfd_hash_allocate (table, sizeof (struct elf32_arm_stub_hash_entry));
+	  bfd_hash_allocate (table, sizeof (struct elf32_arm_stub_hash_entry));
       if (entry == NULL)
 	return entry;
     }
@@ -3660,11 +3689,11 @@ arm_type_of_stub (struct bfd_link_info *info,
     {
       /* Handle cases where:
 	 - this call goes too far (different Thumb/Thumb2 max
-           distance)
+	   distance)
 	 - it's a Thumb->Arm call and blx is not available, or it's a
-           Thumb->Arm branch (not bl). A stub is needed in this case,
-           but only if this call is not through a PLT entry. Indeed,
-           PLT stubs handle mode switching already.
+	   Thumb->Arm branch (not bl). A stub is needed in this case,
+	   but only if this call is not through a PLT entry. Indeed,
+	   PLT stubs handle mode switching already.
       */
       if ((!thumb2
 	    && (branch_offset > THM_MAX_FWD_BRANCH_OFFSET
@@ -3808,8 +3837,10 @@ arm_type_of_stub (struct bfd_link_info *info,
 		? (r_type == R_ARM_TLS_CALL
 		   /* TLS PIC Stub */
 		   ? arm_stub_long_branch_any_tls_pic
+		   : globals->nacl_p ? arm_stub_long_branch_arm_nacl_pic
 		   : arm_stub_long_branch_any_arm_pic)
 		/* non-PIC stubs.  */
+		: globals->nacl_p ? arm_stub_long_branch_arm_nacl
 		: arm_stub_long_branch_any_any;
 	    }
 	}
@@ -3946,7 +3977,8 @@ elf32_arm_create_or_find_stub_sec (asection **link_sec_p, asection *section,
 
 	  memcpy (s_name, link_sec->name, namelen);
 	  memcpy (s_name + namelen, STUB_SUFFIX, sizeof (STUB_SUFFIX));
-	  stub_sec = (*htab->add_stub_section) (s_name, link_sec);
+	  stub_sec = (*htab->add_stub_section) (s_name, link_sec,
+						htab->nacl_p ? 4 : 3);
 	  if (stub_sec == NULL)
 	    return NULL;
 	  htab->stub_group[link_sec->id].stub_sec = stub_sec;
@@ -4079,6 +4111,10 @@ arm_stub_required_alignment (enum elf32_arm_stub_type stub_type)
     case arm_stub_a8_veneer_blx:
       return 4;
 
+    case arm_stub_long_branch_arm_nacl:
+    case arm_stub_long_branch_arm_nacl_pic:
+      return 16;
+
     default:
       abort ();  /* Should be unreachable.  */
     }
@@ -4088,7 +4124,7 @@ static bfd_boolean
 arm_build_one_stub (struct bfd_hash_entry *gen_entry,
 		    void * in_arg)
 {
-#define MAXRELOCS 2
+#define MAXRELOCS 3
   struct elf32_arm_stub_hash_entry *stub_entry;
   struct elf32_arm_link_hash_table *globals;
   struct bfd_link_info *info;
@@ -4143,11 +4179,11 @@ arm_build_one_stub (struct bfd_hash_entry *gen_entry,
 	    bfd_vma data = (bfd_vma) template_sequence[i].data;
 	    if (template_sequence[i].reloc_addend != 0)
 	      {
-                /* We've borrowed the reloc_addend field to mean we should
-                   insert a condition code into this (Thumb-1 branch)
-                   instruction.  See THUMB16_BCOND_INSN.  */
-                BFD_ASSERT ((data & 0xff00) == 0xd000);
-                data |= ((stub_entry->orig_insn >> 22) & 0xf) << 8;
+		/* We've borrowed the reloc_addend field to mean we should
+		   insert a condition code into this (Thumb-1 branch)
+		   instruction.  See THUMB16_BCOND_INSN.  */
+		BFD_ASSERT ((data & 0xff00) == 0xd000);
+		data |= ((stub_entry->orig_insn >> 22) & 0xf) << 8;
 	      }
 	    bfd_put_16 (stub_bfd, data, loc + size);
 	    size += 2;
@@ -4160,13 +4196,13 @@ arm_build_one_stub (struct bfd_hash_entry *gen_entry,
 		      loc + size);
 	  bfd_put_16 (stub_bfd, template_sequence[i].data & 0xffff,
 		      loc + size + 2);
-          if (template_sequence[i].r_type != R_ARM_NONE)
-            {
-              stub_reloc_idx[nrelocs] = i;
-              stub_reloc_offset[nrelocs++] = size;
-            }
-          size += 4;
-          break;
+	  if (template_sequence[i].r_type != R_ARM_NONE)
+	    {
+	      stub_reloc_idx[nrelocs] = i;
+	      stub_reloc_offset[nrelocs++] = size;
+	    }
+	  size += 4;
+	  break;
 
 	case ARM_TYPE:
 	  bfd_put_32 (stub_bfd, template_sequence[i].data,
@@ -4224,7 +4260,7 @@ arm_build_one_stub (struct bfd_hash_entry *gen_entry,
 
 	rel.r_offset = stub_entry->stub_offset + stub_reloc_offset[i];
 	rel.r_info = ELF32_R_INFO (0,
-                                   template_sequence[stub_reloc_idx[i]].r_type);
+				   template_sequence[stub_reloc_idx[i]].r_type);
 	rel.r_addend = template_sequence[stub_reloc_idx[i]].reloc_addend;
 
 	if (stub_entry->stub_type == arm_stub_a8_veneer_b_cond && i == 0)
@@ -4257,7 +4293,7 @@ arm_build_one_stub (struct bfd_hash_entry *gen_entry,
 
 	rel.r_offset = stub_entry->stub_offset + stub_reloc_offset[i];
 	rel.r_info = ELF32_R_INFO (0,
-                                   template_sequence[stub_reloc_idx[i]].r_type);
+				   template_sequence[stub_reloc_idx[i]].r_type);
 	rel.r_addend = 0;
 
 	elf32_arm_final_link_relocate (elf32_arm_howto_from_type
@@ -4487,15 +4523,15 @@ group_sections (struct elf32_arm_link_hash_table *htab,
 #define NEXT_SEC PREV_SEC
       head = NULL;
       while (tail != NULL)
-        {
-          /* Pop from tail.  */
-          asection *item = tail;
-          tail = PREV_SEC (item);
+	{
+	  /* Pop from tail.  */
+	  asection *item = tail;
+	  tail = PREV_SEC (item);
 
-          /* Push on head.  */
-          NEXT_SEC (item) = head;
-          head = item;
-        }
+	  /* Push on head.  */
+	  NEXT_SEC (item) = head;
+	  head = item;
+	}
 
       while (head != NULL)
 	{
@@ -4614,65 +4650,65 @@ cortex_a8_erratum_scan (bfd *input_bfd,
       bfd_vma base_vma;
 
       if (elf_section_type (section) != SHT_PROGBITS
-          || (elf_section_flags (section) & SHF_EXECINSTR) == 0
-          || (section->flags & SEC_EXCLUDE) != 0
-          || (section->sec_info_type == SEC_INFO_TYPE_JUST_SYMS)
-          || (section->output_section == bfd_abs_section_ptr))
-        continue;
+	  || (elf_section_flags (section) & SHF_EXECINSTR) == 0
+	  || (section->flags & SEC_EXCLUDE) != 0
+	  || (section->sec_info_type == SEC_INFO_TYPE_JUST_SYMS)
+	  || (section->output_section == bfd_abs_section_ptr))
+	continue;
 
       base_vma = section->output_section->vma + section->output_offset;
 
       if (elf_section_data (section)->this_hdr.contents != NULL)
-        contents = elf_section_data (section)->this_hdr.contents;
+	contents = elf_section_data (section)->this_hdr.contents;
       else if (! bfd_malloc_and_get_section (input_bfd, section, &contents))
-        return TRUE;
+	return TRUE;
 
       sec_data = elf32_arm_section_data (section);
 
       for (span = 0; span < sec_data->mapcount; span++)
-        {
-          unsigned int span_start = sec_data->map[span].vma;
-          unsigned int span_end = (span == sec_data->mapcount - 1)
-            ? section->size : sec_data->map[span + 1].vma;
-          unsigned int i;
-          char span_type = sec_data->map[span].type;
-          bfd_boolean last_was_32bit = FALSE, last_was_branch = FALSE;
-
-          if (span_type != 't')
-            continue;
-
-          /* Span is entirely within a single 4KB region: skip scanning.  */
-          if (((base_vma + span_start) & ~0xfff)
+	{
+	  unsigned int span_start = sec_data->map[span].vma;
+	  unsigned int span_end = (span == sec_data->mapcount - 1)
+	    ? section->size : sec_data->map[span + 1].vma;
+	  unsigned int i;
+	  char span_type = sec_data->map[span].type;
+	  bfd_boolean last_was_32bit = FALSE, last_was_branch = FALSE;
+
+	  if (span_type != 't')
+	    continue;
+
+	  /* Span is entirely within a single 4KB region: skip scanning.  */
+	  if (((base_vma + span_start) & ~0xfff)
 	      == ((base_vma + span_end) & ~0xfff))
-            continue;
-
-          /* Scan for 32-bit Thumb-2 branches which span two 4K regions, where:
-
-               * The opcode is BLX.W, BL.W, B.W, Bcc.W
-               * The branch target is in the same 4KB region as the
-                 first half of the branch.
-               * The instruction before the branch is a 32-bit
-                 length non-branch instruction.  */
-          for (i = span_start; i < span_end;)
-            {
-              unsigned int insn = bfd_getl16 (&contents[i]);
-              bfd_boolean insn_32bit = FALSE, is_blx = FALSE, is_b = FALSE;
+	    continue;
+
+	  /* Scan for 32-bit Thumb-2 branches which span two 4K regions, where:
+
+	       * The opcode is BLX.W, BL.W, B.W, Bcc.W
+	       * The branch target is in the same 4KB region as the
+		 first half of the branch.
+	       * The instruction before the branch is a 32-bit
+		 length non-branch instruction.  */
+	  for (i = span_start; i < span_end;)
+	    {
+	      unsigned int insn = bfd_getl16 (&contents[i]);
+	      bfd_boolean insn_32bit = FALSE, is_blx = FALSE, is_b = FALSE;
 	      bfd_boolean is_bl = FALSE, is_bcc = FALSE, is_32bit_branch;
 
-              if ((insn & 0xe000) == 0xe000 && (insn & 0x1800) != 0x0000)
-                insn_32bit = TRUE;
+	      if ((insn & 0xe000) == 0xe000 && (insn & 0x1800) != 0x0000)
+		insn_32bit = TRUE;
 
 	      if (insn_32bit)
-	        {
-                  /* Load the rest of the insn (in manual-friendly order).  */
-                  insn = (insn << 16) | bfd_getl16 (&contents[i + 2]);
-
-        	  /* Encoding T4: B<c>.W.  */
-        	  is_b = (insn & 0xf800d000) == 0xf0009000;
-        	  /* Encoding T1: BL<c>.W.  */
-        	  is_bl = (insn & 0xf800d000) == 0xf000d000;
-        	  /* Encoding T2: BLX<c>.W.  */
-        	  is_blx = (insn & 0xf800d000) == 0xf000c000;
+		{
+		  /* Load the rest of the insn (in manual-friendly order).  */
+		  insn = (insn << 16) | bfd_getl16 (&contents[i + 2]);
+
+		  /* Encoding T4: B<c>.W.  */
+		  is_b = (insn & 0xf800d000) == 0xf0009000;
+		  /* Encoding T1: BL<c>.W.  */
+		  is_bl = (insn & 0xf800d000) == 0xf000d000;
+		  /* Encoding T2: BLX<c>.W.  */
+		  is_blx = (insn & 0xf800d000) == 0xf000c000;
 		  /* Encoding T3: B<c>.W (not permitted in IT block).  */
 		  is_bcc = (insn & 0xf800d000) == 0xf0008000
 			   && (insn & 0x07f00000) != 0x03800000;
@@ -4680,25 +4716,25 @@ cortex_a8_erratum_scan (bfd *input_bfd,
 
 	      is_32bit_branch = is_b || is_bl || is_blx || is_bcc;
 
-              if (((base_vma + i) & 0xfff) == 0xffe
+	      if (((base_vma + i) & 0xfff) == 0xffe
 		  && insn_32bit
 		  && is_32bit_branch
 		  && last_was_32bit
 		  && ! last_was_branch)
-                {
-                  bfd_signed_vma offset = 0;
-                  bfd_boolean force_target_arm = FALSE;
+		{
+		  bfd_signed_vma offset = 0;
+		  bfd_boolean force_target_arm = FALSE;
 		  bfd_boolean force_target_thumb = FALSE;
-                  bfd_vma target;
-                  enum elf32_arm_stub_type stub_type = arm_stub_none;
-                  struct a8_erratum_reloc key, *found;
-                  bfd_boolean use_plt = FALSE;
+		  bfd_vma target;
+		  enum elf32_arm_stub_type stub_type = arm_stub_none;
+		  struct a8_erratum_reloc key, *found;
+		  bfd_boolean use_plt = FALSE;
 
-                  key.from = base_vma + i;
-                  found = (struct a8_erratum_reloc *)
-                      bsearch (&key, a8_relocs, num_a8_relocs,
-                               sizeof (struct a8_erratum_reloc),
-                               &a8_reloc_compare);
+		  key.from = base_vma + i;
+		  found = (struct a8_erratum_reloc *)
+		      bsearch (&key, a8_relocs, num_a8_relocs,
+			       sizeof (struct a8_erratum_reloc),
+			       &a8_reloc_compare);
 
 		  if (found)
 		    {
@@ -4706,7 +4742,7 @@ cortex_a8_erratum_scan (bfd *input_bfd,
 		      struct elf_link_hash_entry *entry;
 
 		      /* We don't care about the error returned from this
-		         function, only if there is glue or not.  */
+			 function, only if there is glue or not.  */
 		      entry = find_thumb_glue (info, found->sym_name,
 					       &error_message);
 
@@ -4728,7 +4764,7 @@ cortex_a8_erratum_scan (bfd *input_bfd,
 			}
 		    }
 
-                  /* Check if we have an offending branch instruction.  */
+		  /* Check if we have an offending branch instruction.  */
 
 		  if (found && found->non_a8_stub)
 		    /* We've already made a stub for this instruction, e.g.
@@ -4736,46 +4772,46 @@ cortex_a8_erratum_scan (bfd *input_bfd,
 		       stub will suffice to work around the A8 erratum (see
 		       setting of always_after_branch above).  */
 		    ;
-                  else if (is_bcc)
-                    {
-                      offset = (insn & 0x7ff) << 1;
-                      offset |= (insn & 0x3f0000) >> 4;
-                      offset |= (insn & 0x2000) ? 0x40000 : 0;
-                      offset |= (insn & 0x800) ? 0x80000 : 0;
-                      offset |= (insn & 0x4000000) ? 0x100000 : 0;
-                      if (offset & 0x100000)
-                        offset |= ~ ((bfd_signed_vma) 0xfffff);
-                      stub_type = arm_stub_a8_veneer_b_cond;
-                    }
-                  else if (is_b || is_bl || is_blx)
-                    {
-                      int s = (insn & 0x4000000) != 0;
-                      int j1 = (insn & 0x2000) != 0;
-                      int j2 = (insn & 0x800) != 0;
-                      int i1 = !(j1 ^ s);
-                      int i2 = !(j2 ^ s);
-
-                      offset = (insn & 0x7ff) << 1;
-                      offset |= (insn & 0x3ff0000) >> 4;
-                      offset |= i2 << 22;
-                      offset |= i1 << 23;
-                      offset |= s << 24;
-                      if (offset & 0x1000000)
-                        offset |= ~ ((bfd_signed_vma) 0xffffff);
-
-                      if (is_blx)
-                        offset &= ~ ((bfd_signed_vma) 3);
-
-                      stub_type = is_blx ? arm_stub_a8_veneer_blx :
-                        is_bl ? arm_stub_a8_veneer_bl : arm_stub_a8_veneer_b;
-                    }
-
-                  if (stub_type != arm_stub_none)
-                    {
-                      bfd_vma pc_for_insn = base_vma + i + 4;
+		  else if (is_bcc)
+		    {
+		      offset = (insn & 0x7ff) << 1;
+		      offset |= (insn & 0x3f0000) >> 4;
+		      offset |= (insn & 0x2000) ? 0x40000 : 0;
+		      offset |= (insn & 0x800) ? 0x80000 : 0;
+		      offset |= (insn & 0x4000000) ? 0x100000 : 0;
+		      if (offset & 0x100000)
+			offset |= ~ ((bfd_signed_vma) 0xfffff);
+		      stub_type = arm_stub_a8_veneer_b_cond;
+		    }
+		  else if (is_b || is_bl || is_blx)
+		    {
+		      int s = (insn & 0x4000000) != 0;
+		      int j1 = (insn & 0x2000) != 0;
+		      int j2 = (insn & 0x800) != 0;
+		      int i1 = !(j1 ^ s);
+		      int i2 = !(j2 ^ s);
+
+		      offset = (insn & 0x7ff) << 1;
+		      offset |= (insn & 0x3ff0000) >> 4;
+		      offset |= i2 << 22;
+		      offset |= i1 << 23;
+		      offset |= s << 24;
+		      if (offset & 0x1000000)
+			offset |= ~ ((bfd_signed_vma) 0xffffff);
+
+		      if (is_blx)
+			offset &= ~ ((bfd_signed_vma) 3);
+
+		      stub_type = is_blx ? arm_stub_a8_veneer_blx :
+			is_bl ? arm_stub_a8_veneer_bl : arm_stub_a8_veneer_b;
+		    }
+
+		  if (stub_type != arm_stub_none)
+		    {
+		      bfd_vma pc_for_insn = base_vma + i + 4;
 
 		      /* The original instruction is a BL, but the target is
-		         an ARM instruction.  If we were not making a stub,
+			 an ARM instruction.  If we were not making a stub,
 			 the BL would have been converted to a BLX.  Use the
 			 BLX stub instead in that case.  */
 		      if (htab->use_blx && force_target_arm
@@ -4796,43 +4832,43 @@ cortex_a8_erratum_scan (bfd *input_bfd,
 			  is_bl = TRUE;
 			}
 
-                      if (is_blx)
-                        pc_for_insn &= ~ ((bfd_vma) 3);
+		      if (is_blx)
+			pc_for_insn &= ~ ((bfd_vma) 3);
 
-                      /* If we found a relocation, use the proper destination,
-		         not the offset in the (unrelocated) instruction.
+		      /* If we found a relocation, use the proper destination,
+			 not the offset in the (unrelocated) instruction.
 			 Note this is always done if we switched the stub type
 			 above.  */
-                      if (found)
-                        offset =
+		      if (found)
+			offset =
 			  (bfd_signed_vma) (found->destination - pc_for_insn);
 
-                      /* If the stub will use a Thumb-mode branch to a
-                         PLT target, redirect it to the preceding Thumb
-                         entry point.  */
-                      if (stub_type != arm_stub_a8_veneer_blx && use_plt)
-                        offset -= PLT_THUMB_STUB_SIZE;
+		      /* If the stub will use a Thumb-mode branch to a
+			 PLT target, redirect it to the preceding Thumb
+			 entry point.  */
+		      if (stub_type != arm_stub_a8_veneer_blx && use_plt)
+			offset -= PLT_THUMB_STUB_SIZE;
 
-                      target = pc_for_insn + offset;
+		      target = pc_for_insn + offset;
 
-                      /* The BLX stub is ARM-mode code.  Adjust the offset to
-		         take the different PC value (+8 instead of +4) into
+		      /* The BLX stub is ARM-mode code.  Adjust the offset to
+			 take the different PC value (+8 instead of +4) into
 			 account.  */
-                      if (stub_type == arm_stub_a8_veneer_blx)
-                        offset += 4;
-
-                      if (((base_vma + i) & ~0xfff) == (target & ~0xfff))
-                        {
-                          char *stub_name = NULL;
-
-                          if (num_a8_fixes == a8_fix_table_size)
-                            {
-                              a8_fix_table_size *= 2;
-                              a8_fixes = (struct a8_erratum_fix *)
-                                  bfd_realloc (a8_fixes,
-                                               sizeof (struct a8_erratum_fix)
-                                               * a8_fix_table_size);
-                            }
+		      if (stub_type == arm_stub_a8_veneer_blx)
+			offset += 4;
+
+		      if (((base_vma + i) & ~0xfff) == (target & ~0xfff))
+			{
+			  char *stub_name = NULL;
+
+			  if (num_a8_fixes == a8_fix_table_size)
+			    {
+			      a8_fix_table_size *= 2;
+			      a8_fixes = (struct a8_erratum_fix *)
+				  bfd_realloc (a8_fixes,
+					       sizeof (struct a8_erratum_fix)
+					       * a8_fix_table_size);
+			    }
 
 			  if (num_a8_fixes < prev_num_a8_fixes)
 			    {
@@ -4857,29 +4893,29 @@ cortex_a8_erratum_scan (bfd *input_bfd,
 				sprintf (stub_name, "%x:%x", section->id, i);
 			    }
 
-                          a8_fixes[num_a8_fixes].input_bfd = input_bfd;
-                          a8_fixes[num_a8_fixes].section = section;
-                          a8_fixes[num_a8_fixes].offset = i;
-                          a8_fixes[num_a8_fixes].addend = offset;
-                          a8_fixes[num_a8_fixes].orig_insn = insn;
-                          a8_fixes[num_a8_fixes].stub_name = stub_name;
-                          a8_fixes[num_a8_fixes].stub_type = stub_type;
-                          a8_fixes[num_a8_fixes].branch_type =
+			  a8_fixes[num_a8_fixes].input_bfd = input_bfd;
+			  a8_fixes[num_a8_fixes].section = section;
+			  a8_fixes[num_a8_fixes].offset = i;
+			  a8_fixes[num_a8_fixes].addend = offset;
+			  a8_fixes[num_a8_fixes].orig_insn = insn;
+			  a8_fixes[num_a8_fixes].stub_name = stub_name;
+			  a8_fixes[num_a8_fixes].stub_type = stub_type;
+			  a8_fixes[num_a8_fixes].branch_type =
 			    is_blx ? ST_BRANCH_TO_ARM : ST_BRANCH_TO_THUMB;
 
-                          num_a8_fixes++;
-                        }
-                    }
-                }
+			  num_a8_fixes++;
+			}
+		    }
+		}
 
-              i += insn_32bit ? 4 : 2;
-              last_was_32bit = insn_32bit;
+	      i += insn_32bit ? 4 : 2;
+	      last_was_32bit = insn_32bit;
 	      last_was_branch = is_32bit_branch;
-            }
-        }
+	    }
+	}
 
       if (elf_section_data (section)->this_hdr.contents == NULL)
-        free (contents);
+	free (contents);
     }
 
   *a8_fixes_p = a8_fixes;
@@ -4900,7 +4936,8 @@ elf32_arm_size_stubs (bfd *output_bfd,
 		      bfd *stub_bfd,
 		      struct bfd_link_info *info,
 		      bfd_signed_vma group_size,
-		      asection * (*add_stub_section) (const char *, asection *),
+		      asection * (*add_stub_section) (const char *, asection *,
+						      unsigned int),
 		      void (*layout_sections_again) (void))
 {
   bfd_size_type stub_group_size;
@@ -4917,9 +4954,9 @@ elf32_arm_size_stubs (bfd *output_bfd,
   if (htab->fix_cortex_a8)
     {
       a8_fixes = (struct a8_erratum_fix *)
-          bfd_zmalloc (sizeof (struct a8_erratum_fix) * a8_fix_table_size);
+	  bfd_zmalloc (sizeof (struct a8_erratum_fix) * a8_fix_table_size);
       a8_relocs = (struct a8_erratum_reloc *)
-          bfd_zmalloc (sizeof (struct a8_erratum_reloc) * a8_reloc_table_size);
+	  bfd_zmalloc (sizeof (struct a8_erratum_reloc) * a8_reloc_table_size);
     }
 
   /* Propagate mach to stub bfd, because it may not have been
@@ -4987,8 +5024,8 @@ elf32_arm_size_stubs (bfd *output_bfd,
 	  asection *section;
 	  Elf_Internal_Sym *local_syms = NULL;
 
-          if (!is_arm_elf (input_bfd))
-            continue;
+	  if (!is_arm_elf (input_bfd))
+	    continue;
 
 	  num_a8_relocs = 0;
 
@@ -5261,99 +5298,99 @@ elf32_arm_size_stubs (bfd *output_bfd,
 			  goto error_ret_free_internal;
 			}
 
-                      stub_entry->target_value = sym_value;
-                      stub_entry->target_section = sym_sec;
-                      stub_entry->stub_type = stub_type;
-                      stub_entry->h = hash;
-                      stub_entry->branch_type = branch_type;
-
-                      if (sym_name == NULL)
-                	sym_name = "unnamed";
-                      stub_entry->output_name = (char *)
-                          bfd_alloc (htab->stub_bfd,
-                                     sizeof (THUMB2ARM_GLUE_ENTRY_NAME)
-                                     + strlen (sym_name));
-                      if (stub_entry->output_name == NULL)
-                	{
-                          free (stub_name);
-                          goto error_ret_free_internal;
-                	}
-
-                      /* For historical reasons, use the existing names for
-                	 ARM-to-Thumb and Thumb-to-ARM stubs.  */
-                      if ((r_type == (unsigned int) R_ARM_THM_CALL
+		      stub_entry->target_value = sym_value;
+		      stub_entry->target_section = sym_sec;
+		      stub_entry->stub_type = stub_type;
+		      stub_entry->h = hash;
+		      stub_entry->branch_type = branch_type;
+
+		      if (sym_name == NULL)
+			sym_name = "unnamed";
+		      stub_entry->output_name = (char *)
+			  bfd_alloc (htab->stub_bfd,
+				     sizeof (THUMB2ARM_GLUE_ENTRY_NAME)
+				     + strlen (sym_name));
+		      if (stub_entry->output_name == NULL)
+			{
+			  free (stub_name);
+			  goto error_ret_free_internal;
+			}
+
+		      /* For historical reasons, use the existing names for
+			 ARM-to-Thumb and Thumb-to-ARM stubs.  */
+		      if ((r_type == (unsigned int) R_ARM_THM_CALL
 			   || r_type == (unsigned int) R_ARM_THM_JUMP24)
 			  && branch_type == ST_BRANCH_TO_ARM)
-                	sprintf (stub_entry->output_name,
-                        	 THUMB2ARM_GLUE_ENTRY_NAME, sym_name);
-                      else if ((r_type == (unsigned int) R_ARM_CALL
+			sprintf (stub_entry->output_name,
+				 THUMB2ARM_GLUE_ENTRY_NAME, sym_name);
+		      else if ((r_type == (unsigned int) R_ARM_CALL
 			       || r_type == (unsigned int) R_ARM_JUMP24)
 			       && branch_type == ST_BRANCH_TO_THUMB)
-                	sprintf (stub_entry->output_name,
-                        	 ARM2THUMB_GLUE_ENTRY_NAME, sym_name);
-                      else
-                	sprintf (stub_entry->output_name, STUB_ENTRY_NAME,
-                        	 sym_name);
-
-                      stub_changed = TRUE;
-                    }
-                  while (0);
-
-                  /* Look for relocations which might trigger Cortex-A8
-                     erratum.  */
-                  if (htab->fix_cortex_a8
-                      && (r_type == (unsigned int) R_ARM_THM_JUMP24
-                          || r_type == (unsigned int) R_ARM_THM_JUMP19
-                          || r_type == (unsigned int) R_ARM_THM_CALL
-                          || r_type == (unsigned int) R_ARM_THM_XPC22))
-                    {
-                      bfd_vma from = section->output_section->vma
-                                     + section->output_offset
-                                     + irela->r_offset;
-
-                      if ((from & 0xfff) == 0xffe)
-                        {
-                          /* Found a candidate.  Note we haven't checked the
-                             destination is within 4K here: if we do so (and
-                             don't create an entry in a8_relocs) we can't tell
-                             that a branch should have been relocated when
-                             scanning later.  */
-                          if (num_a8_relocs == a8_reloc_table_size)
-                            {
-                              a8_reloc_table_size *= 2;
-                              a8_relocs = (struct a8_erratum_reloc *)
-                                  bfd_realloc (a8_relocs,
-                                               sizeof (struct a8_erratum_reloc)
-                                               * a8_reloc_table_size);
-                            }
-
-                          a8_relocs[num_a8_relocs].from = from;
-                          a8_relocs[num_a8_relocs].destination = destination;
-                          a8_relocs[num_a8_relocs].r_type = r_type;
-                          a8_relocs[num_a8_relocs].branch_type = branch_type;
-                          a8_relocs[num_a8_relocs].sym_name = sym_name;
-                          a8_relocs[num_a8_relocs].non_a8_stub = created_stub;
-                          a8_relocs[num_a8_relocs].hash = hash;
-
-                          num_a8_relocs++;
-                        }
-                    }
+			sprintf (stub_entry->output_name,
+				 ARM2THUMB_GLUE_ENTRY_NAME, sym_name);
+		      else
+			sprintf (stub_entry->output_name, STUB_ENTRY_NAME,
+				 sym_name);
+
+		      stub_changed = TRUE;
+		    }
+		  while (0);
+
+		  /* Look for relocations which might trigger Cortex-A8
+		     erratum.  */
+		  if (htab->fix_cortex_a8
+		      && (r_type == (unsigned int) R_ARM_THM_JUMP24
+			  || r_type == (unsigned int) R_ARM_THM_JUMP19
+			  || r_type == (unsigned int) R_ARM_THM_CALL
+			  || r_type == (unsigned int) R_ARM_THM_XPC22))
+		    {
+		      bfd_vma from = section->output_section->vma
+				     + section->output_offset
+				     + irela->r_offset;
+
+		      if ((from & 0xfff) == 0xffe)
+			{
+			  /* Found a candidate.  Note we haven't checked the
+			     destination is within 4K here: if we do so (and
+			     don't create an entry in a8_relocs) we can't tell
+			     that a branch should have been relocated when
+			     scanning later.  */
+			  if (num_a8_relocs == a8_reloc_table_size)
+			    {
+			      a8_reloc_table_size *= 2;
+			      a8_relocs = (struct a8_erratum_reloc *)
+				  bfd_realloc (a8_relocs,
+					       sizeof (struct a8_erratum_reloc)
+					       * a8_reloc_table_size);
+			    }
+
+			  a8_relocs[num_a8_relocs].from = from;
+			  a8_relocs[num_a8_relocs].destination = destination;
+			  a8_relocs[num_a8_relocs].r_type = r_type;
+			  a8_relocs[num_a8_relocs].branch_type = branch_type;
+			  a8_relocs[num_a8_relocs].sym_name = sym_name;
+			  a8_relocs[num_a8_relocs].non_a8_stub = created_stub;
+			  a8_relocs[num_a8_relocs].hash = hash;
+
+			  num_a8_relocs++;
+			}
+		    }
 		}
 
-              /* We're done with the internal relocs, free them.  */
-              if (elf_section_data (section)->relocs == NULL)
-                free (internal_relocs);
-            }
+	      /* We're done with the internal relocs, free them.  */
+	      if (elf_section_data (section)->relocs == NULL)
+		free (internal_relocs);
+	    }
 
-          if (htab->fix_cortex_a8)
+	  if (htab->fix_cortex_a8)
 	    {
-              /* Sort relocs which might apply to Cortex-A8 erratum.  */
-              qsort (a8_relocs, num_a8_relocs,
+	      /* Sort relocs which might apply to Cortex-A8 erratum.  */
+	      qsort (a8_relocs, num_a8_relocs,
 		     sizeof (struct a8_erratum_reloc),
-                     &a8_reloc_compare);
+		     &a8_reloc_compare);
 
-              /* Scan for branches which might trigger Cortex-A8 erratum.  */
-              if (cortex_a8_erratum_scan (input_bfd, info, &a8_fixes,
+	      /* Scan for branches which might trigger Cortex-A8 erratum.  */
+	      if (cortex_a8_erratum_scan (input_bfd, info, &a8_fixes,
 					  &num_a8_fixes, &a8_fix_table_size,
 					  a8_relocs, num_a8_relocs,
 					  prev_num_a8_fixes, &stub_changed)
@@ -5363,7 +5400,7 @@ elf32_arm_size_stubs (bfd *output_bfd,
 	}
 
       if (prev_num_a8_fixes != num_a8_fixes)
-        stub_changed = TRUE;
+	stub_changed = TRUE;
 
       if (!stub_changed)
 	break;
@@ -5385,18 +5422,18 @@ elf32_arm_size_stubs (bfd *output_bfd,
 
       /* Add Cortex-A8 erratum veneers to stub section sizes too.  */
       if (htab->fix_cortex_a8)
-        for (i = 0; i < num_a8_fixes; i++)
-          {
+	for (i = 0; i < num_a8_fixes; i++)
+	  {
 	    stub_sec = elf32_arm_create_or_find_stub_sec (NULL,
 			 a8_fixes[i].section, htab);
 
 	    if (stub_sec == NULL)
 	      goto error_ret_free_local;
 
-            stub_sec->size
-              += find_stub_size_and_template (a8_fixes[i].stub_type, NULL,
-                                              NULL);
-          }
+	    stub_sec->size
+	      += find_stub_size_and_template (a8_fixes[i].stub_type, NULL,
+					      NULL);
+	  }
 
 
       /* Ask the linker to do its stuff.  */
@@ -5407,47 +5444,47 @@ elf32_arm_size_stubs (bfd *output_bfd,
   if (htab->fix_cortex_a8)
     {
       for (i = 0; i < num_a8_fixes; i++)
-        {
-          struct elf32_arm_stub_hash_entry *stub_entry;
-          char *stub_name = a8_fixes[i].stub_name;
-          asection *section = a8_fixes[i].section;
-          unsigned int section_id = a8_fixes[i].section->id;
-          asection *link_sec = htab->stub_group[section_id].link_sec;
-          asection *stub_sec = htab->stub_group[section_id].stub_sec;
-          const insn_sequence *template_sequence;
-          int template_size, size = 0;
-
-          stub_entry = arm_stub_hash_lookup (&htab->stub_hash_table, stub_name,
-                                             TRUE, FALSE);
-          if (stub_entry == NULL)
-            {
-              (*_bfd_error_handler) (_("%s: cannot create stub entry %s"),
-                                     section->owner,
-                                     stub_name);
-              return FALSE;
-            }
-
-          stub_entry->stub_sec = stub_sec;
-          stub_entry->stub_offset = 0;
-          stub_entry->id_sec = link_sec;
-          stub_entry->stub_type = a8_fixes[i].stub_type;
-          stub_entry->target_section = a8_fixes[i].section;
-          stub_entry->target_value = a8_fixes[i].offset;
-          stub_entry->target_addend = a8_fixes[i].addend;
-          stub_entry->orig_insn = a8_fixes[i].orig_insn;
+	{
+	  struct elf32_arm_stub_hash_entry *stub_entry;
+	  char *stub_name = a8_fixes[i].stub_name;
+	  asection *section = a8_fixes[i].section;
+	  unsigned int section_id = a8_fixes[i].section->id;
+	  asection *link_sec = htab->stub_group[section_id].link_sec;
+	  asection *stub_sec = htab->stub_group[section_id].stub_sec;
+	  const insn_sequence *template_sequence;
+	  int template_size, size = 0;
+
+	  stub_entry = arm_stub_hash_lookup (&htab->stub_hash_table, stub_name,
+					     TRUE, FALSE);
+	  if (stub_entry == NULL)
+	    {
+	      (*_bfd_error_handler) (_("%s: cannot create stub entry %s"),
+				     section->owner,
+				     stub_name);
+	      return FALSE;
+	    }
+
+	  stub_entry->stub_sec = stub_sec;
+	  stub_entry->stub_offset = 0;
+	  stub_entry->id_sec = link_sec;
+	  stub_entry->stub_type = a8_fixes[i].stub_type;
+	  stub_entry->target_section = a8_fixes[i].section;
+	  stub_entry->target_value = a8_fixes[i].offset;
+	  stub_entry->target_addend = a8_fixes[i].addend;
+	  stub_entry->orig_insn = a8_fixes[i].orig_insn;
 	  stub_entry->branch_type = a8_fixes[i].branch_type;
 
-          size = find_stub_size_and_template (a8_fixes[i].stub_type,
-                                              &template_sequence,
-                                              &template_size);
+	  size = find_stub_size_and_template (a8_fixes[i].stub_type,
+					      &template_sequence,
+					      &template_size);
 
-          stub_entry->stub_size = size;
-          stub_entry->stub_template = template_sequence;
-          stub_entry->stub_template_size = template_size;
-        }
+	  stub_entry->stub_size = size;
+	  stub_entry->stub_template = template_sequence;
+	  stub_entry->stub_template_size = template_size;
+	}
 
       /* Stash the Cortex-A8 erratum fix array for use later in
-         elf32_arm_write_section().  */
+	 elf32_arm_write_section().  */
       htab->a8_erratum_fixes = a8_fixes;
       htab->num_a8_erratum_fixes = num_a8_fixes;
     }
@@ -5527,7 +5564,7 @@ find_thumb_glue (struct bfd_link_info *link_info,
     return NULL;
 
   tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
-                                  + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);
+				  + strlen (THUMB2ARM_GLUE_ENTRY_NAME) + 1);
 
   BFD_ASSERT (tmp_name);
 
@@ -5563,7 +5600,7 @@ find_arm_glue (struct bfd_link_info *link_info,
     return NULL;
 
   tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
-                                  + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);
+				  + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);
 
   BFD_ASSERT (tmp_name);
 
@@ -5630,12 +5667,12 @@ static const insn32 a2t3p_bx_r12_insn = 0xe12fff1c;
      nop                                ldr  r6, __func_addr
      .arm                               mov  lr, pc
      b func                             bx   r6
-                                        .arm
-		 		    ;; back_to_thumb
-                 		        ldmia r13! {r6, lr}
- 				        bx    lr
-                                    __func_addr:
-                                        .word        func  */
+					.arm
+				    ;; back_to_thumb
+					ldmia r13! {r6, lr}
+					bx    lr
+				    __func_addr:
+					.word        func  */
 
 #define THUMB2ARM_GLUE_SIZE 8
 static const insn16 t2a1_bx_pc_insn = 0x4778;
@@ -5732,7 +5769,7 @@ record_arm_to_thumb_glue (struct bfd_link_info * link_info,
   BFD_ASSERT (s != NULL);
 
   tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen (name)
-                                  + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);
+				  + strlen (ARM2THUMB_GLUE_ENTRY_NAME) + 1);
 
   BFD_ASSERT (tmp_name);
 
@@ -5823,8 +5860,8 @@ record_arm_bx_glue (struct bfd_link_info * link_info, int reg)
   bh = NULL;
   val = globals->bx_glue_size;
   _bfd_generic_link_add_one_symbol (link_info, globals->bfd_of_glue_owner,
-                                    tmp_name, BSF_FUNCTION | BSF_LOCAL, s, val,
-                                    NULL, TRUE, FALSE, &bh);
+				    tmp_name, BSF_FUNCTION | BSF_LOCAL, s, val,
+				    NULL, TRUE, FALSE, &bh);
 
   myh = (struct elf_link_hash_entry *) bh;
   myh->type = ELF_ST_INFO (STB_LOCAL, STT_FUNC);
@@ -5847,7 +5884,7 @@ elf32_arm_section_map_add (asection *sec, char type, bfd_vma vma)
   if (sec_data->map == NULL)
     {
       sec_data->map = (elf32_arm_section_map *)
-          bfd_malloc (sizeof (elf32_arm_section_map));
+	  bfd_malloc (sizeof (elf32_arm_section_map));
       sec_data->mapcount = 0;
       sec_data->mapsize = 1;
     }
@@ -5858,8 +5895,8 @@ elf32_arm_section_map_add (asection *sec, char type, bfd_vma vma)
     {
       sec_data->mapsize *= 2;
       sec_data->map = (elf32_arm_section_map *)
-          bfd_realloc_or_free (sec_data->map, sec_data->mapsize
-                               * sizeof (elf32_arm_section_map));
+	  bfd_realloc_or_free (sec_data->map, sec_data->mapsize
+			       * sizeof (elf32_arm_section_map));
     }
 
   if (sec_data->map)
@@ -5875,10 +5912,10 @@ elf32_arm_section_map_add (asection *sec, char type, bfd_vma vma)
 
 static bfd_vma
 record_vfp11_erratum_veneer (struct bfd_link_info *link_info,
-                             elf32_vfp11_erratum_list *branch,
-                             bfd *branch_bfd,
-                             asection *branch_sec,
-                             unsigned int offset)
+			     elf32_vfp11_erratum_list *branch,
+			     bfd *branch_bfd,
+			     asection *branch_sec,
+			     unsigned int offset)
 {
   asection *s;
   struct elf32_arm_link_hash_table *hash_table;
@@ -5901,7 +5938,7 @@ record_vfp11_erratum_veneer (struct bfd_link_info *link_info,
   BFD_ASSERT (s != NULL);
 
   tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen
-                                  (VFP11_ERRATUM_VENEER_ENTRY_NAME) + 10);
+				  (VFP11_ERRATUM_VENEER_ENTRY_NAME) + 10);
 
   BFD_ASSERT (tmp_name);
 
@@ -5916,8 +5953,8 @@ record_vfp11_erratum_veneer (struct bfd_link_info *link_info,
   bh = NULL;
   val = hash_table->vfp11_erratum_glue_size;
   _bfd_generic_link_add_one_symbol (link_info, hash_table->bfd_of_glue_owner,
-                                    tmp_name, BSF_FUNCTION | BSF_LOCAL, s, val,
-                                    NULL, TRUE, FALSE, &bh);
+				    tmp_name, BSF_FUNCTION | BSF_LOCAL, s, val,
+				    NULL, TRUE, FALSE, &bh);
 
   myh = (struct elf_link_hash_entry *) bh;
   myh->type = ELF_ST_INFO (STB_LOCAL, STT_FUNC);
@@ -5964,20 +6001,20 @@ record_vfp11_erratum_veneer (struct bfd_link_info *link_info,
     {
       bh = NULL;
       /* FIXME: Creates an ARM symbol.  Thumb mode will need attention if it
-         ever requires this erratum fix.  */
+	 ever requires this erratum fix.  */
       _bfd_generic_link_add_one_symbol (link_info,
 					hash_table->bfd_of_glue_owner, "$a",
 					BSF_LOCAL, s, 0, NULL,
-                                        TRUE, FALSE, &bh);
+					TRUE, FALSE, &bh);
 
       myh = (struct elf_link_hash_entry *) bh;
       myh->type = ELF_ST_INFO (STB_LOCAL, STT_NOTYPE);
       myh->forced_local = 1;
 
       /* The elf32_arm_init_maps function only cares about symbols from input
-         BFDs.  We must make a note of this generated mapping symbol
-         ourselves so that code byteswapping works properly in
-         elf32_arm_write_section.  */
+	 BFDs.  We must make a note of this generated mapping symbol
+	 ourselves so that code byteswapping works properly in
+	 elf32_arm_write_section.  */
       elf32_arm_section_map_add (s, 'a', 0);
     }
 
@@ -6210,8 +6247,8 @@ bfd_elf32_arm_process_before_allocation (bfd *abfd,
 	    {
 	    case R_ARM_PC24:
 	      /* This one is a call from arm code.  We need to look up
-	         the target of the call.  If it is a thumb target, we
-	         insert glue.  */
+		 the target of the call.  If it is a thumb target, we
+		 insert glue.  */
 	      if (h->target_internal == ST_BRANCH_TO_THUMB)
 		record_arm_to_thumb_glue (link_info, h);
 	      break;
@@ -6283,15 +6320,15 @@ bfd_elf32_arm_init_maps (bfd *abfd)
       const char *name;
 
       if (sec != NULL
-          && ELF_ST_BIND (isym->st_info) == STB_LOCAL)
-        {
-          name = bfd_elf_string_from_elf_section (abfd,
-            hdr->sh_link, isym->st_name);
+	  && ELF_ST_BIND (isym->st_info) == STB_LOCAL)
+	{
+	  name = bfd_elf_string_from_elf_section (abfd,
+	    hdr->sh_link, isym->st_name);
 
-          if (bfd_is_arm_special_symbol_name (name,
+	  if (bfd_is_arm_special_symbol_name (name,
 					      BFD_ARM_SPECIAL_SYM_TYPE_MAP))
-            elf32_arm_section_map_add (sec, name[1], isym->st_value);
-        }
+	    elf32_arm_section_map_add (sec, name[1], isym->st_value);
+	}
     }
 }
 
@@ -6333,17 +6370,17 @@ bfd_elf32_arm_set_vfp11_fix (bfd *obfd, struct bfd_link_info *link_info)
   if (out_attr[Tag_CPU_arch].i >= TAG_CPU_ARCH_V7)
     {
       switch (globals->vfp11_fix)
-        {
-        case BFD_ARM_VFP11_FIX_DEFAULT:
-        case BFD_ARM_VFP11_FIX_NONE:
-          globals->vfp11_fix = BFD_ARM_VFP11_FIX_NONE;
-          break;
-
-        default:
-          /* Give a warning, but do as the user requests anyway.  */
-          (*_bfd_error_handler) (_("%B: warning: selected VFP11 erratum "
-            "workaround is not necessary for target architecture"), obfd);
-        }
+	{
+	case BFD_ARM_VFP11_FIX_DEFAULT:
+	case BFD_ARM_VFP11_FIX_NONE:
+	  globals->vfp11_fix = BFD_ARM_VFP11_FIX_NONE;
+	  break;
+
+	default:
+	  /* Give a warning, but do as the user requests anyway.  */
+	  (*_bfd_error_handler) (_("%B: warning: selected VFP11 erratum "
+	    "workaround is not necessary for target architecture"), obfd);
+	}
     }
   else if (globals->vfp11_fix == BFD_ARM_VFP11_FIX_DEFAULT)
     /* For earlier architectures, we might need the workaround, but do not
@@ -6375,7 +6412,7 @@ enum bfd_arm_vfp11_pipe
 
 static unsigned int
 bfd_arm_vfp11_regno (unsigned int insn, bfd_boolean is_double, unsigned int rx,
-                     unsigned int x)
+		     unsigned int x)
 {
   if (is_double)
     return (((insn >> rx) & 0xf) | (((insn >> x) & 1) << 4)) + 32;
@@ -6407,15 +6444,15 @@ bfd_arm_vfp11_antidependency (unsigned int wmask, int *regs, int numregs)
       unsigned int reg = regs[i];
 
       if (reg < 32 && (wmask & (1 << reg)) != 0)
-        return TRUE;
+	return TRUE;
 
       reg -= 32;
 
       if (reg >= 16)
-        continue;
+	continue;
 
       if ((wmask & (3 << (reg * 2))) != 0)
-        return TRUE;
+	return TRUE;
     }
 
   return FALSE;
@@ -6431,7 +6468,7 @@ bfd_arm_vfp11_antidependency (unsigned int wmask, int *regs, int numregs)
 
 static enum bfd_arm_vfp11_pipe
 bfd_arm_vfp11_insn_decode (unsigned int insn, unsigned int *destmask, int *regs,
-                           int *numregs)
+			   int *numregs)
 {
   enum bfd_arm_vfp11_pipe vpipe = VFP11_BAD;
   bfd_boolean is_double = ((insn & 0xf00) == 0xb00) ? 1 : 0;
@@ -6443,96 +6480,96 @@ bfd_arm_vfp11_insn_decode (unsigned int insn, unsigned int *destmask, int *regs,
       unsigned int fm = bfd_arm_vfp11_regno (insn, is_double, 0, 5);
 
       pqrs = ((insn & 0x00800000) >> 20)
-           | ((insn & 0x00300000) >> 19)
-           | ((insn & 0x00000040) >> 6);
+	   | ((insn & 0x00300000) >> 19)
+	   | ((insn & 0x00000040) >> 6);
 
       switch (pqrs)
-        {
-        case 0: /* fmac[sd].  */
-        case 1: /* fnmac[sd].  */
-        case 2: /* fmsc[sd].  */
-        case 3: /* fnmsc[sd].  */
-          vpipe = VFP11_FMAC;
-          bfd_arm_vfp11_write_mask (destmask, fd);
-          regs[0] = fd;
-          regs[1] = bfd_arm_vfp11_regno (insn, is_double, 16, 7);  /* Fn.  */
-          regs[2] = fm;
-          *numregs = 3;
-          break;
-
-        case 4: /* fmul[sd].  */
-        case 5: /* fnmul[sd].  */
-        case 6: /* fadd[sd].  */
-        case 7: /* fsub[sd].  */
-          vpipe = VFP11_FMAC;
-          goto vfp_binop;
-
-        case 8: /* fdiv[sd].  */
-          vpipe = VFP11_DS;
-          vfp_binop:
-          bfd_arm_vfp11_write_mask (destmask, fd);
-          regs[0] = bfd_arm_vfp11_regno (insn, is_double, 16, 7);   /* Fn.  */
-          regs[1] = fm;
-          *numregs = 2;
-          break;
-
-        case 15: /* extended opcode.  */
-          {
-            unsigned int extn = ((insn >> 15) & 0x1e)
-                              | ((insn >> 7) & 1);
-
-            switch (extn)
-              {
-              case 0: /* fcpy[sd].  */
-              case 1: /* fabs[sd].  */
-              case 2: /* fneg[sd].  */
-              case 8: /* fcmp[sd].  */
-              case 9: /* fcmpe[sd].  */
-              case 10: /* fcmpz[sd].  */
-              case 11: /* fcmpez[sd].  */
-              case 16: /* fuito[sd].  */
-              case 17: /* fsito[sd].  */
-              case 24: /* ftoui[sd].  */
-              case 25: /* ftouiz[sd].  */
-              case 26: /* ftosi[sd].  */
-              case 27: /* ftosiz[sd].  */
-                /* These instructions will not bounce due to underflow.  */
-                *numregs = 0;
-                vpipe = VFP11_FMAC;
-                break;
-
-              case 3: /* fsqrt[sd].  */
-                /* fsqrt cannot underflow, but it can (perhaps) overwrite
-                   registers to cause the erratum in previous instructions.  */
-                bfd_arm_vfp11_write_mask (destmask, fd);
-                vpipe = VFP11_DS;
-                break;
-
-              case 15: /* fcvt{ds,sd}.  */
-                {
-                  int rnum = 0;
-
-                  bfd_arm_vfp11_write_mask (destmask, fd);
+	{
+	case 0: /* fmac[sd].  */
+	case 1: /* fnmac[sd].  */
+	case 2: /* fmsc[sd].  */
+	case 3: /* fnmsc[sd].  */
+	  vpipe = VFP11_FMAC;
+	  bfd_arm_vfp11_write_mask (destmask, fd);
+	  regs[0] = fd;
+	  regs[1] = bfd_arm_vfp11_regno (insn, is_double, 16, 7);  /* Fn.  */
+	  regs[2] = fm;
+	  *numregs = 3;
+	  break;
+
+	case 4: /* fmul[sd].  */
+	case 5: /* fnmul[sd].  */
+	case 6: /* fadd[sd].  */
+	case 7: /* fsub[sd].  */
+	  vpipe = VFP11_FMAC;
+	  goto vfp_binop;
+
+	case 8: /* fdiv[sd].  */
+	  vpipe = VFP11_DS;
+	  vfp_binop:
+	  bfd_arm_vfp11_write_mask (destmask, fd);
+	  regs[0] = bfd_arm_vfp11_regno (insn, is_double, 16, 7);   /* Fn.  */
+	  regs[1] = fm;
+	  *numregs = 2;
+	  break;
+
+	case 15: /* extended opcode.  */
+	  {
+	    unsigned int extn = ((insn >> 15) & 0x1e)
+			      | ((insn >> 7) & 1);
+
+	    switch (extn)
+	      {
+	      case 0: /* fcpy[sd].  */
+	      case 1: /* fabs[sd].  */
+	      case 2: /* fneg[sd].  */
+	      case 8: /* fcmp[sd].  */
+	      case 9: /* fcmpe[sd].  */
+	      case 10: /* fcmpz[sd].  */
+	      case 11: /* fcmpez[sd].  */
+	      case 16: /* fuito[sd].  */
+	      case 17: /* fsito[sd].  */
+	      case 24: /* ftoui[sd].  */
+	      case 25: /* ftouiz[sd].  */
+	      case 26: /* ftosi[sd].  */
+	      case 27: /* ftosiz[sd].  */
+		/* These instructions will not bounce due to underflow.  */
+		*numregs = 0;
+		vpipe = VFP11_FMAC;
+		break;
+
+	      case 3: /* fsqrt[sd].  */
+		/* fsqrt cannot underflow, but it can (perhaps) overwrite
+		   registers to cause the erratum in previous instructions.  */
+		bfd_arm_vfp11_write_mask (destmask, fd);
+		vpipe = VFP11_DS;
+		break;
+
+	      case 15: /* fcvt{ds,sd}.  */
+		{
+		  int rnum = 0;
+
+		  bfd_arm_vfp11_write_mask (destmask, fd);
 
 		  /* Only FCVTSD can underflow.  */
-                  if ((insn & 0x100) != 0)
-                    regs[rnum++] = fm;
+		  if ((insn & 0x100) != 0)
+		    regs[rnum++] = fm;
 
-                  *numregs = rnum;
+		  *numregs = rnum;
 
-                  vpipe = VFP11_FMAC;
-                }
-                break;
+		  vpipe = VFP11_FMAC;
+		}
+		break;
 
-              default:
-                return VFP11_BAD;
-              }
-          }
-          break;
+	      default:
+		return VFP11_BAD;
+	      }
+	  }
+	  break;
 
-        default:
-          return VFP11_BAD;
-        }
+	default:
+	  return VFP11_BAD;
+	}
     }
   /* Two-register transfer.  */
   else if ((insn & 0x0fe00ed0) == 0x0c400a10)
@@ -6541,13 +6578,13 @@ bfd_arm_vfp11_insn_decode (unsigned int insn, unsigned int *destmask, int *regs,
 
       if ((insn & 0x100000) == 0)
 	{
-          if (is_double)
-            bfd_arm_vfp11_write_mask (destmask, fm);
-          else
-            {
-              bfd_arm_vfp11_write_mask (destmask, fm);
-              bfd_arm_vfp11_write_mask (destmask, fm + 1);
-            }
+	  if (is_double)
+	    bfd_arm_vfp11_write_mask (destmask, fm);
+	  else
+	    {
+	      bfd_arm_vfp11_write_mask (destmask, fm);
+	      bfd_arm_vfp11_write_mask (destmask, fm + 1);
+	    }
 	}
 
       vpipe = VFP11_LS;
@@ -6558,32 +6595,32 @@ bfd_arm_vfp11_insn_decode (unsigned int insn, unsigned int *destmask, int *regs,
       unsigned int puw = ((insn >> 21) & 0x1) | (((insn >> 23) & 3) << 1);
 
       switch (puw)
-        {
-        case 0: /* Two-reg transfer.  We should catch these above.  */
-          abort ();
+	{
+	case 0: /* Two-reg transfer.  We should catch these above.  */
+	  abort ();
 
-        case 2: /* fldm[sdx].  */
-        case 3:
-        case 5:
-          {
-            unsigned int i, offset = insn & 0xff;
+	case 2: /* fldm[sdx].  */
+	case 3:
+	case 5:
+	  {
+	    unsigned int i, offset = insn & 0xff;
 
-            if (is_double)
-              offset >>= 1;
+	    if (is_double)
+	      offset >>= 1;
 
-            for (i = fd; i < fd + offset; i++)
-              bfd_arm_vfp11_write_mask (destmask, i);
-          }
-          break;
+	    for (i = fd; i < fd + offset; i++)
+	      bfd_arm_vfp11_write_mask (destmask, i);
+	  }
+	  break;
 
-        case 4: /* fld[sd].  */
-        case 6:
-          bfd_arm_vfp11_write_mask (destmask, fd);
-          break;
+	case 4: /* fld[sd].  */
+	case 6:
+	  bfd_arm_vfp11_write_mask (destmask, fd);
+	  break;
 
-        default:
-          return VFP11_BAD;
-        }
+	default:
+	  return VFP11_BAD;
+	}
 
       vpipe = VFP11_LS;
     }
@@ -6594,18 +6631,18 @@ bfd_arm_vfp11_insn_decode (unsigned int insn, unsigned int *destmask, int *regs,
       unsigned int fn = bfd_arm_vfp11_regno (insn, is_double, 16, 7);
 
       switch (opcode)
-        {
-        case 0: /* fmsr/fmdlr.  */
-        case 1: /* fmdhr.  */
-          /* Mark fmdhr and fmdlr as writing to the whole of the DP
-             destination register.  I don't know if this is exactly right,
-             but it is the conservative choice.  */
-          bfd_arm_vfp11_write_mask (destmask, fn);
-          break;
-
-        case 7: /* fmxr.  */
-          break;
-        }
+	{
+	case 0: /* fmsr/fmdlr.  */
+	case 1: /* fmdhr.  */
+	  /* Mark fmdhr and fmdlr as writing to the whole of the DP
+	     destination register.  I don't know if this is exactly right,
+	     but it is the conservative choice.  */
+	  bfd_arm_vfp11_write_mask (destmask, fn);
+	  break;
+
+	case 7: /* fmxr.  */
+	  break;
+	}
 
       vpipe = VFP11_LS;
     }
@@ -6639,23 +6676,23 @@ bfd_elf32_arm_vfp11_erratum_scan (bfd *abfd, struct bfd_link_info *link_info)
      The states transition as follows:
 
        0 -> 1 (vector) or 0 -> 2 (scalar)
-           A VFP FMAC-pipeline instruction has been seen. Fill
-           regs[0]..regs[numregs-1] with its input operands. Remember this
-           instruction in 'first_fmac'.
+	   A VFP FMAC-pipeline instruction has been seen. Fill
+	   regs[0]..regs[numregs-1] with its input operands. Remember this
+	   instruction in 'first_fmac'.
 
        1 -> 2
-           Any instruction, except for a VFP instruction which overwrites
-           regs[*].
+	   Any instruction, except for a VFP instruction which overwrites
+	   regs[*].
 
        1 -> 3 [ -> 0 ]  or
        2 -> 3 [ -> 0 ]
-           A VFP instruction has been seen which overwrites any of regs[*].
-           We must make a veneer!  Reset state to 0 before examining next
-           instruction.
+	   A VFP instruction has been seen which overwrites any of regs[*].
+	   We must make a veneer!  Reset state to 0 before examining next
+	   instruction.
 
        2 -> 0
-           If we fail to match anything in state 2, reset to state 0 and reset
-           the instruction pointer to the instruction after 'first_fmac'.
+	   If we fail to match anything in state 2, reset to state 0 and reset
+	   the instruction pointer to the instruction after 'first_fmac'.
 
      If the VFP11 vector mode is in use, there must be at least two unrelated
      instructions between anti-dependent VFP11 instructions to properly avoid
@@ -6686,19 +6723,19 @@ bfd_elf32_arm_vfp11_erratum_scan (bfd *abfd, struct bfd_link_info *link_info)
       struct _arm_elf_section_data *sec_data;
 
       /* If we don't have executable progbits, we're not interested in this
-         section.  Also skip if section is to be excluded.  */
+	 section.  Also skip if section is to be excluded.  */
       if (elf_section_type (sec) != SHT_PROGBITS
-          || (elf_section_flags (sec) & SHF_EXECINSTR) == 0
-          || (sec->flags & SEC_EXCLUDE) != 0
+	  || (elf_section_flags (sec) & SHF_EXECINSTR) == 0
+	  || (sec->flags & SEC_EXCLUDE) != 0
 	  || sec->sec_info_type == SEC_INFO_TYPE_JUST_SYMS
 	  || sec->output_section == bfd_abs_section_ptr
-          || strcmp (sec->name, VFP11_ERRATUM_VENEER_SECTION_NAME) == 0)
-        continue;
+	  || strcmp (sec->name, VFP11_ERRATUM_VENEER_SECTION_NAME) == 0)
+	continue;
 
       sec_data = elf32_arm_section_data (sec);
 
       if (sec_data->mapcount == 0)
-        continue;
+	continue;
 
       if (elf_section_data (sec)->this_hdr.contents != NULL)
 	contents = elf_section_data (sec)->this_hdr.contents;
@@ -6709,122 +6746,122 @@ bfd_elf32_arm_vfp11_erratum_scan (bfd *abfd, struct bfd_link_info *link_info)
 	     elf32_arm_compare_mapping);
 
       for (span = 0; span < sec_data->mapcount; span++)
-        {
-          unsigned int span_start = sec_data->map[span].vma;
-          unsigned int span_end = (span == sec_data->mapcount - 1)
+	{
+	  unsigned int span_start = sec_data->map[span].vma;
+	  unsigned int span_end = (span == sec_data->mapcount - 1)
 				  ? sec->size : sec_data->map[span + 1].vma;
-          char span_type = sec_data->map[span].type;
-
-          /* FIXME: Only ARM mode is supported at present.  We may need to
-             support Thumb-2 mode also at some point.  */
-          if (span_type != 'a')
-            continue;
-
-          for (i = span_start; i < span_end;)
-            {
-              unsigned int next_i = i + 4;
-              unsigned int insn = bfd_big_endian (abfd)
-                ? (contents[i] << 24)
-                  | (contents[i + 1] << 16)
-                  | (contents[i + 2] << 8)
-                  | contents[i + 3]
-                : (contents[i + 3] << 24)
-                  | (contents[i + 2] << 16)
-                  | (contents[i + 1] << 8)
-                  | contents[i];
-              unsigned int writemask = 0;
-              enum bfd_arm_vfp11_pipe vpipe;
-
-              switch (state)
-                {
-                case 0:
-                  vpipe = bfd_arm_vfp11_insn_decode (insn, &writemask, regs,
-                                                    &numregs);
-                  /* I'm assuming the VFP11 erratum can trigger with denorm
-                     operands on either the FMAC or the DS pipeline. This might
-                     lead to slightly overenthusiastic veneer insertion.  */
-                  if (vpipe == VFP11_FMAC || vpipe == VFP11_DS)
-                    {
-                      state = use_vector ? 1 : 2;
-                      first_fmac = i;
-                      veneer_of_insn = insn;
-                    }
-                  break;
-
-                case 1:
-                  {
-                    int other_regs[3], other_numregs;
-                    vpipe = bfd_arm_vfp11_insn_decode (insn, &writemask,
+	  char span_type = sec_data->map[span].type;
+
+	  /* FIXME: Only ARM mode is supported at present.  We may need to
+	     support Thumb-2 mode also at some point.  */
+	  if (span_type != 'a')
+	    continue;
+
+	  for (i = span_start; i < span_end;)
+	    {
+	      unsigned int next_i = i + 4;
+	      unsigned int insn = bfd_big_endian (abfd)
+		? (contents[i] << 24)
+		  | (contents[i + 1] << 16)
+		  | (contents[i + 2] << 8)
+		  | contents[i + 3]
+		: (contents[i + 3] << 24)
+		  | (contents[i + 2] << 16)
+		  | (contents[i + 1] << 8)
+		  | contents[i];
+	      unsigned int writemask = 0;
+	      enum bfd_arm_vfp11_pipe vpipe;
+
+	      switch (state)
+		{
+		case 0:
+		  vpipe = bfd_arm_vfp11_insn_decode (insn, &writemask, regs,
+						    &numregs);
+		  /* I'm assuming the VFP11 erratum can trigger with denorm
+		     operands on either the FMAC or the DS pipeline. This might
+		     lead to slightly overenthusiastic veneer insertion.  */
+		  if (vpipe == VFP11_FMAC || vpipe == VFP11_DS)
+		    {
+		      state = use_vector ? 1 : 2;
+		      first_fmac = i;
+		      veneer_of_insn = insn;
+		    }
+		  break;
+
+		case 1:
+		  {
+		    int other_regs[3], other_numregs;
+		    vpipe = bfd_arm_vfp11_insn_decode (insn, &writemask,
 						      other_regs,
-                                                      &other_numregs);
-                    if (vpipe != VFP11_BAD
-                        && bfd_arm_vfp11_antidependency (writemask, regs,
+						      &other_numregs);
+		    if (vpipe != VFP11_BAD
+			&& bfd_arm_vfp11_antidependency (writemask, regs,
 							 numregs))
-                      state = 3;
-                    else
-                      state = 2;
-                  }
-                  break;
-
-                case 2:
-                  {
-                    int other_regs[3], other_numregs;
-                    vpipe = bfd_arm_vfp11_insn_decode (insn, &writemask,
+		      state = 3;
+		    else
+		      state = 2;
+		  }
+		  break;
+
+		case 2:
+		  {
+		    int other_regs[3], other_numregs;
+		    vpipe = bfd_arm_vfp11_insn_decode (insn, &writemask,
 						      other_regs,
-                                                      &other_numregs);
-                    if (vpipe != VFP11_BAD
-                        && bfd_arm_vfp11_antidependency (writemask, regs,
+						      &other_numregs);
+		    if (vpipe != VFP11_BAD
+			&& bfd_arm_vfp11_antidependency (writemask, regs,
 							 numregs))
-                      state = 3;
-                    else
-                      {
-                        state = 0;
-                        next_i = first_fmac + 4;
-                      }
-                  }
-                  break;
-
-                case 3:
-                  abort ();  /* Should be unreachable.  */
-                }
-
-              if (state == 3)
-                {
-                  elf32_vfp11_erratum_list *newerr =(elf32_vfp11_erratum_list *)
-                      bfd_zmalloc (sizeof (elf32_vfp11_erratum_list));
-
-                  elf32_arm_section_data (sec)->erratumcount += 1;
-
-                  newerr->u.b.vfp_insn = veneer_of_insn;
-
-                  switch (span_type)
-                    {
-                    case 'a':
-                      newerr->type = VFP11_ERRATUM_BRANCH_TO_ARM_VENEER;
-                      break;
-
-                    default:
-                      abort ();
-                    }
-
-                  record_vfp11_erratum_veneer (link_info, newerr, abfd, sec,
+		      state = 3;
+		    else
+		      {
+			state = 0;
+			next_i = first_fmac + 4;
+		      }
+		  }
+		  break;
+
+		case 3:
+		  abort ();  /* Should be unreachable.  */
+		}
+
+	      if (state == 3)
+		{
+		  elf32_vfp11_erratum_list *newerr =(elf32_vfp11_erratum_list *)
+		      bfd_zmalloc (sizeof (elf32_vfp11_erratum_list));
+
+		  elf32_arm_section_data (sec)->erratumcount += 1;
+
+		  newerr->u.b.vfp_insn = veneer_of_insn;
+
+		  switch (span_type)
+		    {
+		    case 'a':
+		      newerr->type = VFP11_ERRATUM_BRANCH_TO_ARM_VENEER;
+		      break;
+
+		    default:
+		      abort ();
+		    }
+
+		  record_vfp11_erratum_veneer (link_info, newerr, abfd, sec,
 					       first_fmac);
 
-                  newerr->vma = -1;
+		  newerr->vma = -1;
 
-                  newerr->next = sec_data->erratumlist;
-                  sec_data->erratumlist = newerr;
+		  newerr->next = sec_data->erratumlist;
+		  sec_data->erratumlist = newerr;
 
-                  state = 0;
-                }
+		  state = 0;
+		}
 
-              i = next_i;
-            }
-        }
+	      i = next_i;
+	    }
+	}
 
       if (contents != NULL
-          && elf_section_data (sec)->this_hdr.contents != contents)
-        free (contents);
+	  && elf_section_data (sec)->this_hdr.contents != contents)
+	free (contents);
       contents = NULL;
     }
 
@@ -6861,7 +6898,7 @@ bfd_elf32_arm_vfp11_fix_veneer_locations (bfd *abfd,
     return;
 
   tmp_name = (char *) bfd_malloc ((bfd_size_type) strlen
-                                  (VFP11_ERRATUM_VENEER_ENTRY_NAME) + 10);
+				  (VFP11_ERRATUM_VENEER_ENTRY_NAME) + 10);
 
   for (sec = abfd->sections; sec != NULL; sec = sec->next)
     {
@@ -6869,56 +6906,56 @@ bfd_elf32_arm_vfp11_fix_veneer_locations (bfd *abfd,
       elf32_vfp11_erratum_list *errnode = sec_data->erratumlist;
 
       for (; errnode != NULL; errnode = errnode->next)
-        {
-          struct elf_link_hash_entry *myh;
-          bfd_vma vma;
-
-          switch (errnode->type)
-            {
-            case VFP11_ERRATUM_BRANCH_TO_ARM_VENEER:
-            case VFP11_ERRATUM_BRANCH_TO_THUMB_VENEER:
-              /* Find veneer symbol.  */
-              sprintf (tmp_name, VFP11_ERRATUM_VENEER_ENTRY_NAME,
+	{
+	  struct elf_link_hash_entry *myh;
+	  bfd_vma vma;
+
+	  switch (errnode->type)
+	    {
+	    case VFP11_ERRATUM_BRANCH_TO_ARM_VENEER:
+	    case VFP11_ERRATUM_BRANCH_TO_THUMB_VENEER:
+	      /* Find veneer symbol.  */
+	      sprintf (tmp_name, VFP11_ERRATUM_VENEER_ENTRY_NAME,
 		       errnode->u.b.veneer->u.v.id);
 
-              myh = elf_link_hash_lookup
-                (&(globals)->root, tmp_name, FALSE, FALSE, TRUE);
+	      myh = elf_link_hash_lookup
+		(&(globals)->root, tmp_name, FALSE, FALSE, TRUE);
 
-              if (myh == NULL)
-                (*_bfd_error_handler) (_("%B: unable to find VFP11 veneer "
-                			 "`%s'"), abfd, tmp_name);
+	      if (myh == NULL)
+		(*_bfd_error_handler) (_("%B: unable to find VFP11 veneer "
+					 "`%s'"), abfd, tmp_name);
 
-              vma = myh->root.u.def.section->output_section->vma
-                    + myh->root.u.def.section->output_offset
-                    + myh->root.u.def.value;
+	      vma = myh->root.u.def.section->output_section->vma
+		    + myh->root.u.def.section->output_offset
+		    + myh->root.u.def.value;
 
-              errnode->u.b.veneer->vma = vma;
-              break;
+	      errnode->u.b.veneer->vma = vma;
+	      break;
 
 	    case VFP11_ERRATUM_ARM_VENEER:
-            case VFP11_ERRATUM_THUMB_VENEER:
-              /* Find return location.  */
-              sprintf (tmp_name, VFP11_ERRATUM_VENEER_ENTRY_NAME "_r",
-                       errnode->u.v.id);
+	    case VFP11_ERRATUM_THUMB_VENEER:
+	      /* Find return location.  */
+	      sprintf (tmp_name, VFP11_ERRATUM_VENEER_ENTRY_NAME "_r",
+		       errnode->u.v.id);
 
-              myh = elf_link_hash_lookup
-                (&(globals)->root, tmp_name, FALSE, FALSE, TRUE);
+	      myh = elf_link_hash_lookup
+		(&(globals)->root, tmp_name, FALSE, FALSE, TRUE);
 
-              if (myh == NULL)
-                (*_bfd_error_handler) (_("%B: unable to find VFP11 veneer "
+	      if (myh == NULL)
+		(*_bfd_error_handler) (_("%B: unable to find VFP11 veneer "
 					 "`%s'"), abfd, tmp_name);
 
-              vma = myh->root.u.def.section->output_section->vma
-                    + myh->root.u.def.section->output_offset
-                    + myh->root.u.def.value;
+	      vma = myh->root.u.def.section->output_section->vma
+		    + myh->root.u.def.section->output_offset
+		    + myh->root.u.def.value;
 
-              errnode->u.v.branch->vma = vma;
-              break;
+	      errnode->u.v.branch->vma = vma;
+	      break;
 
-            default:
-              abort ();
-            }
-        }
+	    default:
+	      abort ();
+	    }
+	}
     }
 
   free (tmp_name);
@@ -6932,9 +6969,9 @@ bfd_elf32_arm_set_target_relocs (struct bfd *output_bfd,
 				 struct bfd_link_info *link_info,
 				 int target1_is_rel,
 				 char * target2_type,
-                                 int fix_v4bx,
+				 int fix_v4bx,
 				 int use_blx,
-                                 bfd_arm_vfp11_fix vfp11_fix,
+				 bfd_arm_vfp11_fix vfp11_fix,
 				 int no_enum_warn, int no_wchar_warn,
 				 int pic_veneer, int fix_cortex_a8,
 				 int fix_arm1176)
@@ -7429,6 +7466,10 @@ elf32_arm_allocate_plt_entry (struct bfd_link_info *info,
       splt = htab->root.iplt;
       sgotplt = htab->root.igotplt;
 
+      /* NaCl uses a special first entry in .iplt too.  */
+      if (htab->nacl_p && splt->size == 0)
+	splt->size += htab->plt_header_size;
+
       /* Allocate room for an R_ARM_IRELATIVE relocation in .rel.iplt.  */
       elf32_arm_allocate_irelocs (info, htab->root.irelplt, 1);
     }
@@ -7651,7 +7692,7 @@ elf32_arm_populate_plt_entry (bfd *output_bfd, struct bfd_link_info *info,
 	     in the GOT.  The offset accounts for the value produced by
 	     adding to pc in the penultimate instruction of the PLT stub.  */
 	  got_displacement = (got_address
-                              - (plt_address + htab->plt_entry_size));
+			      - (plt_address + htab->plt_entry_size));
 
 	  /* NaCl does not support interworking at all.  */
 	  BFD_ASSERT (!elf32_arm_plt_needs_thumb_stub_p (info, arm_plt));
@@ -7730,8 +7771,13 @@ elf32_arm_populate_plt_entry (bfd *output_bfd, struct bfd_link_info *info,
 		  sgot->contents + got_offset);
     }
 
-  loc = srel->contents + plt_index * RELOC_SIZE (htab);
-  SWAP_RELOC_OUT (htab) (output_bfd, &rel, loc);
+  if (dynindx == -1)
+    elf32_arm_add_dynreloc (output_bfd, info, srel, &rel);
+  else
+    {
+      loc = srel->contents + plt_index * RELOC_SIZE (htab);
+      SWAP_RELOC_OUT (htab) (output_bfd, &rel, loc);
+    }
 }
 
 /* Some relocations map to different relocations depending on the
@@ -7965,28 +8011,28 @@ calculate_group_reloc_mask (bfd_vma value, int n, bfd_vma *final_residual)
 
       /* Calculate which part of the value to mask.  */
       if (residual == 0)
-        shift = 0;
+	shift = 0;
       else
-        {
-          int msb;
-
-          /* Determine the most significant bit in the residual and
-             align the resulting value to a 2-bit boundary.  */
-          for (msb = 30; msb >= 0; msb -= 2)
-            if (residual & (3 << msb))
-              break;
-
-          /* The desired shift is now (msb - 6), or zero, whichever
-             is the greater.  */
-          shift = msb - 6;
-          if (shift < 0)
-            shift = 0;
-        }
+	{
+	  int msb;
+
+	  /* Determine the most significant bit in the residual and
+	     align the resulting value to a 2-bit boundary.  */
+	  for (msb = 30; msb >= 0; msb -= 2)
+	    if (residual & (3 << msb))
+	      break;
+
+	  /* The desired shift is now (msb - 6), or zero, whichever
+	     is the greater.  */
+	  shift = msb - 6;
+	  if (shift < 0)
+	    shift = 0;
+	}
 
       /* Calculate g_n in 32-bit as well as encoded constant+rotation form.  */
       g_n = residual & (0xff << shift);
       encoded_g_n = (g_n >> shift)
-                    | ((g_n <= 0xff ? 0 : (32 - shift) / 2) << 8);
+		    | ((g_n <= 0xff ? 0 : (32 - shift) / 2) << 8);
 
       /* Calculate the residual for the next time around.  */
       residual &= ~g_n;
@@ -8198,7 +8244,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 	 branches in this object should go to it, except if the PLT is too
 	 far away, in which case a long branch stub should be inserted.  */
       if ((r_type != R_ARM_ABS32 && r_type != R_ARM_REL32
-           && r_type != R_ARM_ABS32_NOI && r_type != R_ARM_REL32_NOI
+	   && r_type != R_ARM_ABS32_NOI && r_type != R_ARM_REL32_NOI
 	   && r_type != R_ARM_CALL
 	   && r_type != R_ARM_JUMP24
 	   && r_type != R_ARM_PLT32)
@@ -8614,36 +8660,36 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 	bfd_signed_vma relocation;
 
 	insn = (bfd_get_16 (input_bfd, hit_data) << 16)
-             | bfd_get_16 (input_bfd, hit_data + 2);
+	     | bfd_get_16 (input_bfd, hit_data + 2);
 
-        if (globals->use_rel)
-          {
-            signed_addend = (insn & 0xff) | ((insn & 0x7000) >> 4)
-                          | ((insn & (1 << 26)) >> 15);
-            if (insn & 0xf00000)
-              signed_addend = -signed_addend;
-          }
+	if (globals->use_rel)
+	  {
+	    signed_addend = (insn & 0xff) | ((insn & 0x7000) >> 4)
+			  | ((insn & (1 << 26)) >> 15);
+	    if (insn & 0xf00000)
+	      signed_addend = -signed_addend;
+	  }
 
 	relocation = value + signed_addend;
 	relocation -= Pa (input_section->output_section->vma
-		          + input_section->output_offset
-		          + rel->r_offset);
+			  + input_section->output_offset
+			  + rel->r_offset);
 
-        value = abs (relocation);
+	value = abs (relocation);
 
-        if (value >= 0x1000)
-          return bfd_reloc_overflow;
+	if (value >= 0x1000)
+	  return bfd_reloc_overflow;
 
 	insn = (insn & 0xfb0f8f00) | (value & 0xff)
-             | ((value & 0x700) << 4)
-             | ((value & 0x800) << 15);
-        if (relocation < 0)
-          insn |= 0xa00000;
+	     | ((value & 0x700) << 4)
+	     | ((value & 0x800) << 15);
+	if (relocation < 0)
+	  insn |= 0xa00000;
 
 	bfd_put_16 (input_bfd, insn >> 16, hit_data);
 	bfd_put_16 (input_bfd, insn & 0xffff, hit_data + 2);
 
-        return bfd_reloc_ok;
+	return bfd_reloc_ok;
       }
 
     case R_ARM_THM_PC8:
@@ -8656,15 +8702,15 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 
 	insn = bfd_get_16 (input_bfd, hit_data);
 
-        if (globals->use_rel)
+	if (globals->use_rel)
 	  addend = ((((insn & 0x00ff) << 2) + 4) & 0x3ff) -4;
 
 	relocation = value + addend;
 	relocation -= Pa (input_section->output_section->vma
-		          + input_section->output_offset
-		          + rel->r_offset);
+			  + input_section->output_offset
+			  + rel->r_offset);
 
-        value = abs (relocation);
+	value = abs (relocation);
 
 	/* We do not check for overflow of this reloc.  Although strictly
 	   speaking this is incorrect, it appears to be necessary in order
@@ -8677,7 +8723,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 
 	bfd_put_16 (input_bfd, insn, hit_data);
 
-        return bfd_reloc_ok;
+	return bfd_reloc_ok;
       }
 
     case R_ARM_THM_PC12:
@@ -8687,33 +8733,33 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 	bfd_signed_vma relocation;
 
 	insn = (bfd_get_16 (input_bfd, hit_data) << 16)
-             | bfd_get_16 (input_bfd, hit_data + 2);
+	     | bfd_get_16 (input_bfd, hit_data + 2);
 
-        if (globals->use_rel)
-          {
-            signed_addend = insn & 0xfff;
-            if (!(insn & (1 << 23)))
-              signed_addend = -signed_addend;
-          }
+	if (globals->use_rel)
+	  {
+	    signed_addend = insn & 0xfff;
+	    if (!(insn & (1 << 23)))
+	      signed_addend = -signed_addend;
+	  }
 
 	relocation = value + signed_addend;
 	relocation -= Pa (input_section->output_section->vma
-		          + input_section->output_offset
-		          + rel->r_offset);
+			  + input_section->output_offset
+			  + rel->r_offset);
 
-        value = abs (relocation);
+	value = abs (relocation);
 
-        if (value >= 0x1000)
-          return bfd_reloc_overflow;
+	if (value >= 0x1000)
+	  return bfd_reloc_overflow;
 
 	insn = (insn & 0xff7ff000) | value;
-        if (relocation >= 0)
-          insn |= (1 << 23);
+	if (relocation >= 0)
+	  insn |= (1 << 23);
 
 	bfd_put_16 (input_bfd, insn >> 16, hit_data);
 	bfd_put_16 (input_bfd, insn & 0xffff, hit_data + 2);
 
-        return bfd_reloc_ok;
+	return bfd_reloc_ok;
       }
 
     case R_ARM_THM_XPC22:
@@ -8722,7 +8768,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
       /* Thumb BL (branch long instruction).  */
       {
 	bfd_vma relocation;
-        bfd_vma reloc_sign;
+	bfd_vma reloc_sign;
 	bfd_boolean overflow = FALSE;
 	bfd_vma upper_insn = bfd_get_16 (input_bfd, hit_data);
 	bfd_vma lower_insn = bfd_get_16 (input_bfd, hit_data + 2);
@@ -8754,20 +8800,20 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 	  }
 
 	/* Fetch the addend.  We use the Thumb-2 encoding (backwards compatible
-           with Thumb-1) involving the J1 and J2 bits.  */
+	   with Thumb-1) involving the J1 and J2 bits.  */
 	if (globals->use_rel)
 	  {
-            bfd_vma s = (upper_insn & (1 << 10)) >> 10;
-            bfd_vma upper = upper_insn & 0x3ff;
-            bfd_vma lower = lower_insn & 0x7ff;
+	    bfd_vma s = (upper_insn & (1 << 10)) >> 10;
+	    bfd_vma upper = upper_insn & 0x3ff;
+	    bfd_vma lower = lower_insn & 0x7ff;
 	    bfd_vma j1 = (lower_insn & (1 << 13)) >> 13;
 	    bfd_vma j2 = (lower_insn & (1 << 11)) >> 11;
-            bfd_vma i1 = j1 ^ s ? 0 : 1;
-            bfd_vma i2 = j2 ^ s ? 0 : 1;
+	    bfd_vma i1 = j1 ^ s ? 0 : 1;
+	    bfd_vma i2 = j2 ^ s ? 0 : 1;
 
-            addend = (i1 << 23) | (i2 << 22) | (upper << 12) | (lower << 1);
-            /* Sign extend.  */
-            addend = (addend | ((s ? 0 : 1) << 24)) - (1 << 24);
+	    addend = (i1 << 23) | (i2 << 22) | (upper << 12) | (lower << 1);
+	    /* Sign extend.  */
+	    addend = (addend | ((s ? 0 : 1) << 24)) - (1 << 24);
 
 	    signed_addend = addend;
 	  }
@@ -8924,14 +8970,14 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 	/* Put RELOCATION back into the insn.  Assumes two's complement.
 	   We use the Thumb-2 encoding, which is safe even if dealing with
 	   a Thumb-1 instruction by virtue of our overflow check above.  */
-        reloc_sign = (signed_check < 0) ? 1 : 0;
+	reloc_sign = (signed_check < 0) ? 1 : 0;
 	upper_insn = (upper_insn & ~(bfd_vma) 0x7ff)
-                     | ((relocation >> 12) & 0x3ff)
-                     | (reloc_sign << 10);
+		     | ((relocation >> 12) & 0x3ff)
+		     | (reloc_sign << 10);
 	lower_insn = (lower_insn & ~(bfd_vma) 0x2fff)
-                     | (((!((relocation >> 23) & 1)) ^ reloc_sign) << 13)
-                     | (((!((relocation >> 22) & 1)) ^ reloc_sign) << 11)
-                     | ((relocation >> 1) & 0x7ff);
+		     | (((!((relocation >> 23) & 1)) ^ reloc_sign) << 13)
+		     | (((!((relocation >> 22) & 1)) ^ reloc_sign) << 11)
+		     | ((relocation >> 1) & 0x7ff);
 
 	/* Put the relocated value back in the object file:  */
 	bfd_put_16 (input_bfd, upper_insn, hit_data);
@@ -8985,7 +9031,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 	/* ??? Should handle interworking?  GCC might someday try to
 	   use this for tail calls.  */
 
-      	relocation = value + signed_addend;
+	relocation = value + signed_addend;
 	relocation -= (input_section->output_section->vma
 		       + input_section->output_offset
 		       + rel->r_offset);
@@ -9100,11 +9146,11 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 
     case R_ARM_GOTOFF32:
       /* Relocation is relative to the start of the
-         global offset table.  */
+	 global offset table.  */
 
       BFD_ASSERT (sgot != NULL);
       if (sgot == NULL)
-        return bfd_reloc_notsupported;
+	return bfd_reloc_notsupported;
 
       /* If we are addressing a Thumb function, we need to adjust the
 	 address by one, so that attempts to call the function pointer will
@@ -9113,10 +9159,10 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 	value += 1;
 
       /* Note that sgot->output_offset is not involved in this
-         calculation.  We always want the start of .got.  If we
-         define _GLOBAL_OFFSET_TABLE in a different way, as is
-         permitted by the ABI, we might have to change this
-         calculation.  */
+	 calculation.  We always want the start of .got.  If we
+	 define _GLOBAL_OFFSET_TABLE in a different way, as is
+	 permitted by the ABI, we might have to change this
+	 calculation.  */
       value -= sgot->output_section->vma;
       return _bfd_final_link_relocate (howto, input_bfd, input_section,
 				       contents, rel->r_offset, value,
@@ -9127,7 +9173,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
       BFD_ASSERT (sgot != NULL);
 
       if (sgot == NULL)
-        return bfd_reloc_notsupported;
+	return bfd_reloc_notsupported;
 
       *unresolved_reloc_p = FALSE;
       value = sgot->output_section->vma;
@@ -9138,7 +9184,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
     case R_ARM_GOT32:
     case R_ARM_GOT_PREL:
       /* Relocation is to the entry for this symbol in the
-         global offset table.  */
+	 global offset table.  */
       if (sgot == NULL)
 	return bfd_reloc_notsupported;
 
@@ -9191,11 +9237,11 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 	      else
 		{
 		  if (dynreloc_st_type == STT_GNU_IFUNC)
- 		    outrel.r_info = ELF32_R_INFO (0, R_ARM_IRELATIVE);
+		    outrel.r_info = ELF32_R_INFO (0, R_ARM_IRELATIVE);
 		  else if (info->shared)
- 		    outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
- 		  else
- 		    outrel.r_info = 0;
+		    outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
+		  else
+		    outrel.r_info = 0;
 		  outrel.r_addend = dynreloc_value;
 		}
 
@@ -9248,7 +9294,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 				     + sgot->output_offset
 				     + off);
 		  if (dynreloc_st_type == STT_GNU_IFUNC)
- 		    outrel.r_info = ELF32_R_INFO (0, R_ARM_IRELATIVE);
+		    outrel.r_info = ELF32_R_INFO (0, R_ARM_IRELATIVE);
 		  else
 		    outrel.r_info = ELF32_R_INFO (0, R_ARM_RELATIVE);
 		  elf32_arm_add_dynreloc (output_bfd, info, srelgot, &outrel);
@@ -9394,7 +9440,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 		BFD_ASSERT ((h && (h->root.type == bfd_link_hash_undefweak))
 			    || info->shared);
 		BFD_ASSERT (globals->sgotplt_jump_table_size + offplt + 8
-                            <= globals->root.sgotplt->size);
+			    <= globals->root.sgotplt->size);
 
 		outrel.r_addend = 0;
 		outrel.r_offset = (globals->root.sgotplt->output_section->vma
@@ -9407,7 +9453,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 		loc = sreloc->contents;
 		loc += globals->next_tls_desc_index++ * RELOC_SIZE (globals);
 		BFD_ASSERT (loc + RELOC_SIZE (globals)
-		   	   <= sreloc->contents + sreloc->size);
+			   <= sreloc->contents + sreloc->size);
 
 		SWAP_RELOC_OUT (globals) (output_bfd, &outrel, loc);
 
@@ -9415,7 +9461,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 		   the relocation index and the top bit set, or zero,
 		   if we're binding now.  For locals, it gets the
 		   symbol's offset in the tls section.  */
-	    	bfd_put_32 (output_bfd,
+		bfd_put_32 (output_bfd,
 			    !h ? value - elf_hash_table (info)->tls_sec->vma
 			    : info->flags & DF_BIND_NOW ? 0
 			    : 0x80000000 | ELF32_R_SYM (outrel.r_info),
@@ -9423,7 +9469,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 			    + globals->sgotplt_jump_table_size);
 
 		/* Second word in the relocation is always zero.  */
-	    	bfd_put_32 (output_bfd, 0,
+		bfd_put_32 (output_bfd, 0,
 			    globals->root.sgotplt->contents + offplt
 			    + globals->sgotplt_jump_table_size + 4);
 	      }
@@ -9739,13 +9785,13 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 		    + input_section->output_offset + rel->r_offset);
 
 	if (r_type == R_ARM_MOVW_BREL && value >= 0x10000)
-          return bfd_reloc_overflow;
+	  return bfd_reloc_overflow;
 
 	if (branch_type == ST_BRANCH_TO_THUMB)
 	  value |= 1;
 
 	if (r_type == R_ARM_MOVT_ABS || r_type == R_ARM_MOVT_PREL
-            || r_type == R_ARM_MOVT_BREL)
+	    || r_type == R_ARM_MOVT_BREL)
 	  value >>= 16;
 
 	insn &= 0xfff0f000;
@@ -9789,13 +9835,13 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
 		    + input_section->output_offset + rel->r_offset);
 
 	if (r_type == R_ARM_THM_MOVW_BREL && value >= 0x10000)
-          return bfd_reloc_overflow;
+	  return bfd_reloc_overflow;
 
 	if (branch_type == ST_BRANCH_TO_THUMB)
 	  value |= 1;
 
 	if (r_type == R_ARM_THM_MOVT_ABS || r_type == R_ARM_THM_MOVT_PREL
-            || r_type == R_ARM_THM_MOVT_BREL)
+	    || r_type == R_ARM_THM_MOVT_BREL)
 	  value >>= 16;
 
 	insn &= 0xfbf08f00;
@@ -9821,129 +9867,129 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
     case R_ARM_ALU_SB_G2:
       {
 	bfd_vma insn = bfd_get_32 (input_bfd, hit_data);
-        bfd_vma pc = input_section->output_section->vma
+	bfd_vma pc = input_section->output_section->vma
 		     + input_section->output_offset + rel->r_offset;
-        /* sb should be the origin of the *segment* containing the symbol.
-           It is not clear how to obtain this OS-dependent value, so we
-           make an arbitrary choice of zero.  */
-        bfd_vma sb = 0;
-        bfd_vma residual;
-        bfd_vma g_n;
+	/* sb should be the origin of the *segment* containing the symbol.
+	   It is not clear how to obtain this OS-dependent value, so we
+	   make an arbitrary choice of zero.  */
+	bfd_vma sb = 0;
+	bfd_vma residual;
+	bfd_vma g_n;
 	bfd_signed_vma signed_value;
-        int group = 0;
-
-        /* Determine which group of bits to select.  */
-        switch (r_type)
-          {
-          case R_ARM_ALU_PC_G0_NC:
-          case R_ARM_ALU_PC_G0:
-          case R_ARM_ALU_SB_G0_NC:
-          case R_ARM_ALU_SB_G0:
-            group = 0;
-            break;
-
-          case R_ARM_ALU_PC_G1_NC:
-          case R_ARM_ALU_PC_G1:
-          case R_ARM_ALU_SB_G1_NC:
-          case R_ARM_ALU_SB_G1:
-            group = 1;
-            break;
-
-          case R_ARM_ALU_PC_G2:
-          case R_ARM_ALU_SB_G2:
-            group = 2;
-            break;
-
-          default:
-            abort ();
-          }
-
-        /* If REL, extract the addend from the insn.  If RELA, it will
-           have already been fetched for us.  */
+	int group = 0;
+
+	/* Determine which group of bits to select.  */
+	switch (r_type)
+	  {
+	  case R_ARM_ALU_PC_G0_NC:
+	  case R_ARM_ALU_PC_G0:
+	  case R_ARM_ALU_SB_G0_NC:
+	  case R_ARM_ALU_SB_G0:
+	    group = 0;
+	    break;
+
+	  case R_ARM_ALU_PC_G1_NC:
+	  case R_ARM_ALU_PC_G1:
+	  case R_ARM_ALU_SB_G1_NC:
+	  case R_ARM_ALU_SB_G1:
+	    group = 1;
+	    break;
+
+	  case R_ARM_ALU_PC_G2:
+	  case R_ARM_ALU_SB_G2:
+	    group = 2;
+	    break;
+
+	  default:
+	    abort ();
+	  }
+
+	/* If REL, extract the addend from the insn.  If RELA, it will
+	   have already been fetched for us.  */
 	if (globals->use_rel)
-          {
-            int negative;
-            bfd_vma constant = insn & 0xff;
-            bfd_vma rotation = (insn & 0xf00) >> 8;
-
-            if (rotation == 0)
-              signed_addend = constant;
-            else
-              {
-                /* Compensate for the fact that in the instruction, the
-                   rotation is stored in multiples of 2 bits.  */
-                rotation *= 2;
-
-                /* Rotate "constant" right by "rotation" bits.  */
-                signed_addend = (constant >> rotation) |
-                                (constant << (8 * sizeof (bfd_vma) - rotation));
-              }
-
-            /* Determine if the instruction is an ADD or a SUB.
-               (For REL, this determines the sign of the addend.)  */
-            negative = identify_add_or_sub (insn);
-            if (negative == 0)
-              {
-                (*_bfd_error_handler)
-                  (_("%B(%A+0x%lx): Only ADD or SUB instructions are allowed for ALU group relocations"),
-                  input_bfd, input_section,
-                  (long) rel->r_offset, howto->name);
-                return bfd_reloc_overflow;
-    	      }
-
-            signed_addend *= negative;
-          }
+	  {
+	    int negative;
+	    bfd_vma constant = insn & 0xff;
+	    bfd_vma rotation = (insn & 0xf00) >> 8;
+
+	    if (rotation == 0)
+	      signed_addend = constant;
+	    else
+	      {
+		/* Compensate for the fact that in the instruction, the
+		   rotation is stored in multiples of 2 bits.  */
+		rotation *= 2;
+
+		/* Rotate "constant" right by "rotation" bits.  */
+		signed_addend = (constant >> rotation) |
+				(constant << (8 * sizeof (bfd_vma) - rotation));
+	      }
+
+	    /* Determine if the instruction is an ADD or a SUB.
+	       (For REL, this determines the sign of the addend.)  */
+	    negative = identify_add_or_sub (insn);
+	    if (negative == 0)
+	      {
+		(*_bfd_error_handler)
+		  (_("%B(%A+0x%lx): Only ADD or SUB instructions are allowed for ALU group relocations"),
+		  input_bfd, input_section,
+		  (long) rel->r_offset, howto->name);
+		return bfd_reloc_overflow;
+	      }
+
+	    signed_addend *= negative;
+	  }
 
 	/* Compute the value (X) to go in the place.  */
-        if (r_type == R_ARM_ALU_PC_G0_NC
-            || r_type == R_ARM_ALU_PC_G1_NC
-            || r_type == R_ARM_ALU_PC_G0
-            || r_type == R_ARM_ALU_PC_G1
-            || r_type == R_ARM_ALU_PC_G2)
-          /* PC relative.  */
-          signed_value = value - pc + signed_addend;
-        else
-          /* Section base relative.  */
-          signed_value = value - sb + signed_addend;
-
-        /* If the target symbol is a Thumb function, then set the
-           Thumb bit in the address.  */
+	if (r_type == R_ARM_ALU_PC_G0_NC
+	    || r_type == R_ARM_ALU_PC_G1_NC
+	    || r_type == R_ARM_ALU_PC_G0
+	    || r_type == R_ARM_ALU_PC_G1
+	    || r_type == R_ARM_ALU_PC_G2)
+	  /* PC relative.  */
+	  signed_value = value - pc + signed_addend;
+	else
+	  /* Section base relative.  */
+	  signed_value = value - sb + signed_addend;
+
+	/* If the target symbol is a Thumb function, then set the
+	   Thumb bit in the address.  */
 	if (branch_type == ST_BRANCH_TO_THUMB)
 	  signed_value |= 1;
 
-        /* Calculate the value of the relevant G_n, in encoded
-           constant-with-rotation format.  */
-        g_n = calculate_group_reloc_mask (abs (signed_value), group,
-                                          &residual);
-
-        /* Check for overflow if required.  */
-        if ((r_type == R_ARM_ALU_PC_G0
-             || r_type == R_ARM_ALU_PC_G1
-             || r_type == R_ARM_ALU_PC_G2
-             || r_type == R_ARM_ALU_SB_G0
-             || r_type == R_ARM_ALU_SB_G1
-             || r_type == R_ARM_ALU_SB_G2) && residual != 0)
-          {
-            (*_bfd_error_handler)
-              (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
-              input_bfd, input_section,
-              (long) rel->r_offset, abs (signed_value), howto->name);
-            return bfd_reloc_overflow;
-          }
-
-        /* Mask out the value and the ADD/SUB part of the opcode; take care
-           not to destroy the S bit.  */
-        insn &= 0xff1ff000;
-
-        /* Set the opcode according to whether the value to go in the
-           place is negative.  */
-        if (signed_value < 0)
-          insn |= 1 << 22;
-        else
-          insn |= 1 << 23;
-
-        /* Encode the offset.  */
-        insn |= g_n;
+	/* Calculate the value of the relevant G_n, in encoded
+	   constant-with-rotation format.  */
+	g_n = calculate_group_reloc_mask (abs (signed_value), group,
+					  &residual);
+
+	/* Check for overflow if required.  */
+	if ((r_type == R_ARM_ALU_PC_G0
+	     || r_type == R_ARM_ALU_PC_G1
+	     || r_type == R_ARM_ALU_PC_G2
+	     || r_type == R_ARM_ALU_SB_G0
+	     || r_type == R_ARM_ALU_SB_G1
+	     || r_type == R_ARM_ALU_SB_G2) && residual != 0)
+	  {
+	    (*_bfd_error_handler)
+	      (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
+	      input_bfd, input_section,
+	      (long) rel->r_offset, abs (signed_value), howto->name);
+	    return bfd_reloc_overflow;
+	  }
+
+	/* Mask out the value and the ADD/SUB part of the opcode; take care
+	   not to destroy the S bit.  */
+	insn &= 0xff1ff000;
+
+	/* Set the opcode according to whether the value to go in the
+	   place is negative.  */
+	if (signed_value < 0)
+	  insn |= 1 << 22;
+	else
+	  insn |= 1 << 23;
+
+	/* Encode the offset.  */
+	insn |= g_n;
 
 	bfd_put_32 (input_bfd, insn, hit_data);
       }
@@ -9957,76 +10003,76 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
     case R_ARM_LDR_SB_G2:
       {
 	bfd_vma insn = bfd_get_32 (input_bfd, hit_data);
-        bfd_vma pc = input_section->output_section->vma
+	bfd_vma pc = input_section->output_section->vma
 		     + input_section->output_offset + rel->r_offset;
-        bfd_vma sb = 0; /* See note above.  */
-        bfd_vma residual;
+	bfd_vma sb = 0; /* See note above.  */
+	bfd_vma residual;
 	bfd_signed_vma signed_value;
-        int group = 0;
-
-        /* Determine which groups of bits to calculate.  */
-        switch (r_type)
-          {
-          case R_ARM_LDR_PC_G0:
-          case R_ARM_LDR_SB_G0:
-            group = 0;
-            break;
-
-          case R_ARM_LDR_PC_G1:
-          case R_ARM_LDR_SB_G1:
-            group = 1;
-            break;
-
-          case R_ARM_LDR_PC_G2:
-          case R_ARM_LDR_SB_G2:
-            group = 2;
-            break;
-
-          default:
-            abort ();
-          }
-
-        /* If REL, extract the addend from the insn.  If RELA, it will
-           have already been fetched for us.  */
+	int group = 0;
+
+	/* Determine which groups of bits to calculate.  */
+	switch (r_type)
+	  {
+	  case R_ARM_LDR_PC_G0:
+	  case R_ARM_LDR_SB_G0:
+	    group = 0;
+	    break;
+
+	  case R_ARM_LDR_PC_G1:
+	  case R_ARM_LDR_SB_G1:
+	    group = 1;
+	    break;
+
+	  case R_ARM_LDR_PC_G2:
+	  case R_ARM_LDR_SB_G2:
+	    group = 2;
+	    break;
+
+	  default:
+	    abort ();
+	  }
+
+	/* If REL, extract the addend from the insn.  If RELA, it will
+	   have already been fetched for us.  */
 	if (globals->use_rel)
-          {
-            int negative = (insn & (1 << 23)) ? 1 : -1;
-            signed_addend = negative * (insn & 0xfff);
-          }
+	  {
+	    int negative = (insn & (1 << 23)) ? 1 : -1;
+	    signed_addend = negative * (insn & 0xfff);
+	  }
 
 	/* Compute the value (X) to go in the place.  */
-        if (r_type == R_ARM_LDR_PC_G0
-            || r_type == R_ARM_LDR_PC_G1
-            || r_type == R_ARM_LDR_PC_G2)
-          /* PC relative.  */
-          signed_value = value - pc + signed_addend;
-        else
-          /* Section base relative.  */
-          signed_value = value - sb + signed_addend;
-
-        /* Calculate the value of the relevant G_{n-1} to obtain
-           the residual at that stage.  */
-        calculate_group_reloc_mask (abs (signed_value), group - 1, &residual);
-
-        /* Check for overflow.  */
-        if (residual >= 0x1000)
-          {
-            (*_bfd_error_handler)
-              (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
-              input_bfd, input_section,
-              (long) rel->r_offset, abs (signed_value), howto->name);
-            return bfd_reloc_overflow;
-          }
-
-        /* Mask out the value and U bit.  */
-        insn &= 0xff7ff000;
-
-        /* Set the U bit if the value to go in the place is non-negative.  */
-        if (signed_value >= 0)
-          insn |= 1 << 23;
-
-        /* Encode the offset.  */
-        insn |= residual;
+	if (r_type == R_ARM_LDR_PC_G0
+	    || r_type == R_ARM_LDR_PC_G1
+	    || r_type == R_ARM_LDR_PC_G2)
+	  /* PC relative.  */
+	  signed_value = value - pc + signed_addend;
+	else
+	  /* Section base relative.  */
+	  signed_value = value - sb + signed_addend;
+
+	/* Calculate the value of the relevant G_{n-1} to obtain
+	   the residual at that stage.  */
+	calculate_group_reloc_mask (abs (signed_value), group - 1, &residual);
+
+	/* Check for overflow.  */
+	if (residual >= 0x1000)
+	  {
+	    (*_bfd_error_handler)
+	      (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
+	      input_bfd, input_section,
+	      (long) rel->r_offset, abs (signed_value), howto->name);
+	    return bfd_reloc_overflow;
+	  }
+
+	/* Mask out the value and U bit.  */
+	insn &= 0xff7ff000;
+
+	/* Set the U bit if the value to go in the place is non-negative.  */
+	if (signed_value >= 0)
+	  insn |= 1 << 23;
+
+	/* Encode the offset.  */
+	insn |= residual;
 
 	bfd_put_32 (input_bfd, insn, hit_data);
       }
@@ -10040,76 +10086,76 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
     case R_ARM_LDRS_SB_G2:
       {
 	bfd_vma insn = bfd_get_32 (input_bfd, hit_data);
-        bfd_vma pc = input_section->output_section->vma
+	bfd_vma pc = input_section->output_section->vma
 		     + input_section->output_offset + rel->r_offset;
-        bfd_vma sb = 0; /* See note above.  */
-        bfd_vma residual;
+	bfd_vma sb = 0; /* See note above.  */
+	bfd_vma residual;
 	bfd_signed_vma signed_value;
-        int group = 0;
-
-        /* Determine which groups of bits to calculate.  */
-        switch (r_type)
-          {
-          case R_ARM_LDRS_PC_G0:
-          case R_ARM_LDRS_SB_G0:
-            group = 0;
-            break;
-
-          case R_ARM_LDRS_PC_G1:
-          case R_ARM_LDRS_SB_G1:
-            group = 1;
-            break;
-
-          case R_ARM_LDRS_PC_G2:
-          case R_ARM_LDRS_SB_G2:
-            group = 2;
-            break;
-
-          default:
-            abort ();
-          }
-
-        /* If REL, extract the addend from the insn.  If RELA, it will
-           have already been fetched for us.  */
+	int group = 0;
+
+	/* Determine which groups of bits to calculate.  */
+	switch (r_type)
+	  {
+	  case R_ARM_LDRS_PC_G0:
+	  case R_ARM_LDRS_SB_G0:
+	    group = 0;
+	    break;
+
+	  case R_ARM_LDRS_PC_G1:
+	  case R_ARM_LDRS_SB_G1:
+	    group = 1;
+	    break;
+
+	  case R_ARM_LDRS_PC_G2:
+	  case R_ARM_LDRS_SB_G2:
+	    group = 2;
+	    break;
+
+	  default:
+	    abort ();
+	  }
+
+	/* If REL, extract the addend from the insn.  If RELA, it will
+	   have already been fetched for us.  */
 	if (globals->use_rel)
-          {
-            int negative = (insn & (1 << 23)) ? 1 : -1;
-            signed_addend = negative * (((insn & 0xf00) >> 4) + (insn & 0xf));
-          }
+	  {
+	    int negative = (insn & (1 << 23)) ? 1 : -1;
+	    signed_addend = negative * (((insn & 0xf00) >> 4) + (insn & 0xf));
+	  }
 
 	/* Compute the value (X) to go in the place.  */
-        if (r_type == R_ARM_LDRS_PC_G0
-            || r_type == R_ARM_LDRS_PC_G1
-            || r_type == R_ARM_LDRS_PC_G2)
-          /* PC relative.  */
-          signed_value = value - pc + signed_addend;
-        else
-          /* Section base relative.  */
-          signed_value = value - sb + signed_addend;
-
-        /* Calculate the value of the relevant G_{n-1} to obtain
-           the residual at that stage.  */
-        calculate_group_reloc_mask (abs (signed_value), group - 1, &residual);
-
-        /* Check for overflow.  */
-        if (residual >= 0x100)
-          {
-            (*_bfd_error_handler)
-              (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
-              input_bfd, input_section,
-              (long) rel->r_offset, abs (signed_value), howto->name);
-            return bfd_reloc_overflow;
-          }
-
-        /* Mask out the value and U bit.  */
-        insn &= 0xff7ff0f0;
-
-        /* Set the U bit if the value to go in the place is non-negative.  */
-        if (signed_value >= 0)
-          insn |= 1 << 23;
-
-        /* Encode the offset.  */
-        insn |= ((residual & 0xf0) << 4) | (residual & 0xf);
+	if (r_type == R_ARM_LDRS_PC_G0
+	    || r_type == R_ARM_LDRS_PC_G1
+	    || r_type == R_ARM_LDRS_PC_G2)
+	  /* PC relative.  */
+	  signed_value = value - pc + signed_addend;
+	else
+	  /* Section base relative.  */
+	  signed_value = value - sb + signed_addend;
+
+	/* Calculate the value of the relevant G_{n-1} to obtain
+	   the residual at that stage.  */
+	calculate_group_reloc_mask (abs (signed_value), group - 1, &residual);
+
+	/* Check for overflow.  */
+	if (residual >= 0x100)
+	  {
+	    (*_bfd_error_handler)
+	      (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
+	      input_bfd, input_section,
+	      (long) rel->r_offset, abs (signed_value), howto->name);
+	    return bfd_reloc_overflow;
+	  }
+
+	/* Mask out the value and U bit.  */
+	insn &= 0xff7ff0f0;
+
+	/* Set the U bit if the value to go in the place is non-negative.  */
+	if (signed_value >= 0)
+	  insn |= 1 << 23;
+
+	/* Encode the offset.  */
+	insn |= ((residual & 0xf0) << 4) | (residual & 0xf);
 
 	bfd_put_32 (input_bfd, insn, hit_data);
       }
@@ -10123,78 +10169,78 @@ elf32_arm_final_link_relocate (reloc_howto_type *           howto,
     case R_ARM_LDC_SB_G2:
       {
 	bfd_vma insn = bfd_get_32 (input_bfd, hit_data);
-        bfd_vma pc = input_section->output_section->vma
+	bfd_vma pc = input_section->output_section->vma
 		     + input_section->output_offset + rel->r_offset;
-        bfd_vma sb = 0; /* See note above.  */
-        bfd_vma residual;
+	bfd_vma sb = 0; /* See note above.  */
+	bfd_vma residual;
 	bfd_signed_vma signed_value;
-        int group = 0;
-
-        /* Determine which groups of bits to calculate.  */
-        switch (r_type)
-          {
-          case R_ARM_LDC_PC_G0:
-          case R_ARM_LDC_SB_G0:
-            group = 0;
-            break;
-
-          case R_ARM_LDC_PC_G1:
-          case R_ARM_LDC_SB_G1:
-            group = 1;
-            break;
-
-          case R_ARM_LDC_PC_G2:
-          case R_ARM_LDC_SB_G2:
-            group = 2;
-            break;
-
-          default:
-            abort ();
-          }
-
-        /* If REL, extract the addend from the insn.  If RELA, it will
-           have already been fetched for us.  */
+	int group = 0;
+
+	/* Determine which groups of bits to calculate.  */
+	switch (r_type)
+	  {
+	  case R_ARM_LDC_PC_G0:
+	  case R_ARM_LDC_SB_G0:
+	    group = 0;
+	    break;
+
+	  case R_ARM_LDC_PC_G1:
+	  case R_ARM_LDC_SB_G1:
+	    group = 1;
+	    break;
+
+	  case R_ARM_LDC_PC_G2:
+	  case R_ARM_LDC_SB_G2:
+	    group = 2;
+	    break;
+
+	  default:
+	    abort ();
+	  }
+
+	/* If REL, extract the addend from the insn.  If RELA, it will
+	   have already been fetched for us.  */
 	if (globals->use_rel)
-          {
-            int negative = (insn & (1 << 23)) ? 1 : -1;
-            signed_addend = negative * ((insn & 0xff) << 2);
-          }
+	  {
+	    int negative = (insn & (1 << 23)) ? 1 : -1;
+	    signed_addend = negative * ((insn & 0xff) << 2);
+	  }
 
 	/* Compute the value (X) to go in the place.  */
-        if (r_type == R_ARM_LDC_PC_G0
-            || r_type == R_ARM_LDC_PC_G1
-            || r_type == R_ARM_LDC_PC_G2)
-          /* PC relative.  */
-          signed_value = value - pc + signed_addend;
-        else
-          /* Section base relative.  */
-          signed_value = value - sb + signed_addend;
-
-        /* Calculate the value of the relevant G_{n-1} to obtain
-           the residual at that stage.  */
-        calculate_group_reloc_mask (abs (signed_value), group - 1, &residual);
-
-        /* Check for overflow.  (The absolute value to go in the place must be
-           divisible by four and, after having been divided by four, must
-           fit in eight bits.)  */
-        if ((residual & 0x3) != 0 || residual >= 0x400)
-          {
-            (*_bfd_error_handler)
-              (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
-              input_bfd, input_section,
-              (long) rel->r_offset, abs (signed_value), howto->name);
-            return bfd_reloc_overflow;
-          }
-
-        /* Mask out the value and U bit.  */
-        insn &= 0xff7fff00;
-
-        /* Set the U bit if the value to go in the place is non-negative.  */
-        if (signed_value >= 0)
-          insn |= 1 << 23;
-
-        /* Encode the offset.  */
-        insn |= residual >> 2;
+	if (r_type == R_ARM_LDC_PC_G0
+	    || r_type == R_ARM_LDC_PC_G1
+	    || r_type == R_ARM_LDC_PC_G2)
+	  /* PC relative.  */
+	  signed_value = value - pc + signed_addend;
+	else
+	  /* Section base relative.  */
+	  signed_value = value - sb + signed_addend;
+
+	/* Calculate the value of the relevant G_{n-1} to obtain
+	   the residual at that stage.  */
+	calculate_group_reloc_mask (abs (signed_value), group - 1, &residual);
+
+	/* Check for overflow.  (The absolute value to go in the place must be
+	   divisible by four and, after having been divided by four, must
+	   fit in eight bits.)  */
+	if ((residual & 0x3) != 0 || residual >= 0x400)
+	  {
+	    (*_bfd_error_handler)
+	      (_("%B(%A+0x%lx): Overflow whilst splitting 0x%lx for group relocation %s"),
+	      input_bfd, input_section,
+	      (long) rel->r_offset, abs (signed_value), howto->name);
+	    return bfd_reloc_overflow;
+	  }
+
+	/* Mask out the value and U bit.  */
+	insn &= 0xff7fff00;
+
+	/* Set the U bit if the value to go in the place is non-negative.  */
+	if (signed_value >= 0)
+	  insn |= 1 << 23;
+
+	/* Encode the offset.  */
+	insn |= residual >> 2;
 
 	bfd_put_32 (input_bfd, insn, hit_data);
       }
@@ -10346,8 +10392,8 @@ elf32_arm_relocate_section (bfd *                  output_bfd,
       r_type   = arm_real_reloc_type (globals, r_type);
 
       if (   r_type == R_ARM_GNU_VTENTRY
-          || r_type == R_ARM_GNU_VTINHERIT)
-        continue;
+	  || r_type == R_ARM_GNU_VTINHERIT)
+	continue;
 
       bfd_reloc.howto = elf32_arm_howto_from_type (r_type);
       howto = bfd_reloc.howto;
@@ -10540,10 +10586,10 @@ elf32_arm_relocate_section (bfd *                  output_bfd,
 	}
 
       /* We call elf32_arm_final_link_relocate unless we're completely
-         done, i.e., the relaxation produced the final output we want,
-         and we won't let anybody mess with it. Also, we have to do
-         addend adjustments in case of a R_ARM_TLS_GOTDESC relocation
-         both in relaxed and non-relaxed cases */
+	 done, i.e., the relaxation produced the final output we want,
+	 and we won't let anybody mess with it. Also, we have to do
+	 addend adjustments in case of a R_ARM_TLS_GOTDESC relocation
+	 both in relaxed and non-relaxed cases */
      if ((elf32_arm_tls_transition (info, r_type, h) != (unsigned)r_type)
 	 || (IS_ARM_TLS_GNU_RELOC (r_type)
 	     && !((h ? elf32_arm_hash_entry (h)->tls_type :
@@ -10571,8 +10617,8 @@ elf32_arm_relocate_section (bfd *                  output_bfd,
 	 because such sections are not SEC_ALLOC and thus ld.so will
 	 not process them.  */
       if (unresolved_reloc
-          && !((input_section->flags & SEC_DEBUGGING) != 0
-               && h->def_dynamic)
+	  && !((input_section->flags & SEC_DEBUGGING) != 0
+	       && h->def_dynamic)
 	  && _bfd_elf_section_offset (output_bfd, info, input_section,
 				      rel->r_offset) != (bfd_vma) -1)
 	{
@@ -10719,7 +10765,7 @@ insert_cantunwind_after(asection *text_sec, asection *exidx_sec)
 
      1. Regions without unwind data are marked with EXIDX_CANTUNWIND entries.
      2. Duplicate entries are merged together (EXIDX_CANTUNWIND, or unwind
-        codes which have been inlined into the index).
+	codes which have been inlined into the index).
 
    If MERGE_EXIDX_ENTRIES is false, duplicate entries are not merged.
 
@@ -10745,7 +10791,7 @@ elf32_arm_fix_exidx_coverage (asection **text_section_order,
       asection *sec;
 
       for (sec = inp->sections; sec != NULL; sec = sec->next)
-        {
+	{
 	  struct bfd_elf_section_data *elf_sec = elf_section_data (sec);
 	  Elf_Internal_Shdr *hdr = &elf_sec->this_hdr;
 
@@ -10755,15 +10801,15 @@ elf32_arm_fix_exidx_coverage (asection **text_section_order,
 	  if (elf_sec->linked_to)
 	    {
 	      Elf_Internal_Shdr *linked_hdr
-	        = &elf_section_data (elf_sec->linked_to)->this_hdr;
+		= &elf_section_data (elf_sec->linked_to)->this_hdr;
 	      struct _arm_elf_section_data *linked_sec_arm_data
-	        = get_arm_elf_section_data (linked_hdr->bfd_section);
+		= get_arm_elf_section_data (linked_hdr->bfd_section);
 
 	      if (linked_sec_arm_data == NULL)
-	        continue;
+		continue;
 
 	      /* Link this .ARM.exidx section back from the text section it
-	         describes.  */
+		 describes.  */
 	      linked_sec_arm_data->u.text.arm_exidx_sec = sec;
 	    }
 	}
@@ -10788,7 +10834,7 @@ elf32_arm_fix_exidx_coverage (asection **text_section_order,
       bfd *ibfd;
 
       if (arm_data == NULL)
-        continue;
+	continue;
 
       exidx_sec = arm_data->u.text.arm_exidx_sec;
       if (exidx_sec == NULL)
@@ -10812,11 +10858,11 @@ elf32_arm_fix_exidx_coverage (asection **text_section_order,
 
       hdr = &elf_section_data (exidx_sec)->this_hdr;
       if (hdr->sh_type != SHT_ARM_EXIDX)
-        continue;
+	continue;
 
       exidx_arm_data = get_arm_elf_section_data (exidx_sec);
       if (exidx_arm_data == NULL)
-        continue;
+	continue;
 
       ibfd = exidx_sec->owner;
 
@@ -10866,7 +10912,7 @@ elf32_arm_fix_exidx_coverage (asection **text_section_order,
 
       /* Free contents if we allocated it ourselves.  */
       if (contents != hdr->contents)
-        free (contents);
+	free (contents);
 
       /* Record edits to be applied later (in elf32_arm_write_section).  */
       exidx_arm_data->u.exidx.unwind_edit_list = unwind_edit_head;
@@ -11079,7 +11125,7 @@ elf32_arm_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
 	return FALSE;
 
       /* If the src and dest have different interworking flags
-         then turn off the interworking bit.  */
+	 then turn off the interworking bit.  */
       if ((in_flags & EF_ARM_INTERWORK) != (out_flags & EF_ARM_INTERWORK))
 	{
 	  if (out_flags & EF_ARM_INTERWORK)
@@ -11511,7 +11557,7 @@ elf32_arm_merge_eabi_attributes (bfd *ibfd, bfd *obfd)
 	{
 	  if (out_attr[Tag_MPextension_use].i != 0
 	      && out_attr[Tag_MPextension_use_legacy].i
-	        != out_attr[Tag_MPextension_use].i)
+		!= out_attr[Tag_MPextension_use].i)
 	    {
 	      _bfd_error_handler
 		(_("Error: %B has both the current and legacy "
@@ -11699,7 +11745,7 @@ elf32_arm_merge_eabi_attributes (bfd *ibfd, bfd *obfd)
 	      /* 0 will merge with anything.
 		 'A' and 'S' merge to 'A'.
 		 'R' and 'S' merge to 'R'.
-	         'M' and 'A|R|S' is an error.  */
+		 'M' and 'A|R|S' is an error.  */
 	      if (out_attr[i].i == 0
 		  || (out_attr[i].i == 'S'
 		      && (in_attr[i].i == 'A' || in_attr[i].i == 'R')))
@@ -11797,7 +11843,7 @@ elf32_arm_merge_eabi_attributes (bfd *ibfd, bfd *obfd)
 	      if (regs < vfp_versions[out_attr[i].i].regs)
 		regs = vfp_versions[out_attr[i].i].regs;
 	      /* This assumes all possible supersets are also a valid
-	         options.  */
+		 options.  */
 	      for (newval = VFP_VERSION_COUNT - 1; newval > 0; newval--)
 		{
 		  if (regs == vfp_versions[newval].regs
@@ -11813,7 +11859,7 @@ elf32_arm_merge_eabi_attributes (bfd *ibfd, bfd *obfd)
 	  else if (in_attr[i].i != 0 && out_attr[i].i != in_attr[i].i)
 	    {
 	      /* It's sometimes ok to mix different configs, so this is only
-	         a warning.  */
+		 a warning.  */
 	      _bfd_error_handler
 		(_("Warning: %B: Conflicting platform configuration"), ibfd);
 	    }
@@ -12486,7 +12532,7 @@ elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,
       /* Could be done earlier, if h were already available.  */
       r_type = elf32_arm_tls_transition (info, r_type, h);
       switch (r_type)
-        {
+	{
 	  case R_ARM_GOT32:
 	  case R_ARM_GOT_PREL:
 	  case R_ARM_TLS_GD32:
@@ -12529,7 +12575,7 @@ elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,
 		}
 
 	      /* If a variable is accessed with both tls methods, two
-	         slots may be created.  */
+		 slots may be created.  */
 	      if (GOT_TLS_GD_ANY_P (old_tls_type)
 		  && GOT_TLS_GD_ANY_P (tls_type))
 		tls_type |= old_tls_type;
@@ -12542,9 +12588,9 @@ elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,
 		tls_type |= old_tls_type;
 
 	      /* If the symbol is accessed in both IE and GDESC
-	         method, we're able to relax. Turn off the GDESC flag,
-	         without messing up with any other kind of tls types
-	         that may be involved */
+		 method, we're able to relax. Turn off the GDESC flag,
+		 without messing up with any other kind of tls types
+		 that may be involved */
 	      if ((tls_type & GOT_TLS_IE) && (tls_type & GOT_TLS_GDESC))
 		tls_type &= ~GOT_TLS_GDESC;
 
@@ -12641,22 +12687,22 @@ elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,
 	      may_need_local_target_p = TRUE;
 	    break;
 
-        /* This relocation describes the C++ object vtable hierarchy.
-           Reconstruct it for later use during GC.  */
-        case R_ARM_GNU_VTINHERIT:
-          if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
-            return FALSE;
-          break;
-
-        /* This relocation describes which C++ vtable entries are actually
-           used.  Record for later use during GC.  */
-        case R_ARM_GNU_VTENTRY:
-          BFD_ASSERT (h != NULL);
-          if (h != NULL
-              && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
-            return FALSE;
-          break;
-        }
+	/* This relocation describes the C++ object vtable hierarchy.
+	   Reconstruct it for later use during GC.  */
+	case R_ARM_GNU_VTINHERIT:
+	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
+	    return FALSE;
+	  break;
+
+	/* This relocation describes which C++ vtable entries are actually
+	   used.  Record for later use during GC.  */
+	case R_ARM_GNU_VTENTRY:
+	  BFD_ASSERT (h != NULL);
+	  if (h != NULL
+	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))
+	    return FALSE;
+	  break;
+	}
 
       if (h != NULL)
 	{
@@ -12914,7 +12960,7 @@ elf32_arm_find_nearest_line (bfd *          abfd,
   /* We skip _bfd_dwarf1_find_nearest_line since no known ARM toolchain uses it.  */
 
   if (_bfd_dwarf2_find_nearest_line (abfd, dwarf_debug_sections,
-                                     section, symbols, offset,
+				     section, symbols, offset,
 				     filename_ptr, functionname_ptr,
 				     line_ptr, NULL, 0,
 				     & elf_tdata (abfd)->dwarf2_find_line_info))
@@ -13225,18 +13271,18 @@ allocate_dynrelocs_for_symbol (struct elf_link_hash_entry *h, void * inf)
 	    s->size += 4;
 	  else
 	    {
-              if (tls_type & GOT_TLS_GDESC)
-	        {
+	      if (tls_type & GOT_TLS_GDESC)
+		{
 		  /* R_ARM_TLS_DESC needs 2 GOT slots.  */
-	          eh->tlsdesc_got
+		  eh->tlsdesc_got
 		    = (htab->root.sgotplt->size
 		       - elf32_arm_compute_jump_table_size (htab));
-	          htab->root.sgotplt->size += 8;
-	          h->got.offset = (bfd_vma) -2;
+		  htab->root.sgotplt->size += 8;
+		  h->got.offset = (bfd_vma) -2;
 		  /* plt.got_offset needs to know there's a TLS_DESC
 		     reloc in the middle of .got.plt.  */
-                  htab->num_tls_desc++;
-	        }
+		  htab->num_tls_desc++;
+		}
 
 	      if (tls_type & GOT_TLS_GD)
 		{
@@ -13348,11 +13394,11 @@ allocate_dynrelocs_for_symbol (struct elf_link_hash_entry *h, void * inf)
   if (info->shared || htab->root.is_relocatable_executable)
     {
       /* The only relocs that use pc_count are R_ARM_REL32 and
-         R_ARM_REL32_NOI, which will appear on something like
-         ".long foo - .".  We want calls to protected symbols to resolve
-         directly to the function rather than going via the plt.  If people
-         want function pointer comparisons to work as expected then they
-         should avoid writing assembly like ".long foo - .".  */
+	 R_ARM_REL32_NOI, which will appear on something like
+	 ".long foo - .".  We want calls to protected symbols to resolve
+	 directly to the function rather than going via the plt.  If people
+	 want function pointer comparisons to work as expected then they
+	 should avoid writing assembly like ".long foo - .".  */
       if (SYMBOL_CALLS_LOCAL (info, h))
 	{
 	  struct elf_dyn_relocs **pp;
@@ -13382,7 +13428,7 @@ allocate_dynrelocs_for_symbol (struct elf_link_hash_entry *h, void * inf)
 	}
 
       /* Also discard relocs on undefined weak syms with non-default
-         visibility.  */
+	 visibility.  */
       if (eh->dyn_relocs != NULL
 	  && h->root.type == bfd_link_hash_undefweak)
 	{
@@ -13553,7 +13599,7 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,
 	  struct elf_dyn_relocs *p;
 
 	  for (p = (struct elf_dyn_relocs *)
-                   elf_section_data (s)->local_dynrel; p != NULL; p = p->next)
+		   elf_section_data (s)->local_dynrel; p != NULL; p = p->next)
 	    {
 	      if (!bfd_is_abs_section (p->sec)
 		  && bfd_is_abs_section (p->sec->output_section))
@@ -13649,7 +13695,7 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,
 		  *local_got = (bfd_vma) -2;
 		  /* plt.got_offset needs to know there's a TLS_DESC
 		     reloc in the middle of .got.plt.  */
-                  htab->num_tls_desc++;
+		  htab->num_tls_desc++;
 		}
 	      if (*local_tls_type & GOT_TLS_IE)
 		s->size += 4;
@@ -13715,8 +13761,8 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,
 
       if (!bfd_elf32_arm_process_before_allocation (ibfd, info)
 	  || !bfd_elf32_arm_vfp11_erratum_scan (ibfd, info))
-        /* xgettext:c-format */
-        _bfd_error_handler (_("Errors encountered processing file %s"),
+	/* xgettext:c-format */
+	_bfd_error_handler (_("Errors encountered processing file %s"),
 			    ibfd->filename);
     }
 
@@ -13740,7 +13786,7 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,
       htab->root.splt->size += htab->plt_entry_size;
 
       /* If we're not using lazy TLS relocations, don't generate the
-         PLT and GOT entries they require.  */
+	 PLT and GOT entries they require.  */
       if (!(info->flags & DF_BIND_NOW))
 	{
 	  htab->dt_tlsdesc_got = htab->root.sgot->size;
@@ -13894,7 +13940,7 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,
 
 static bfd_boolean
 elf32_arm_always_size_sections (bfd *output_bfd,
-	                        struct bfd_link_info *info)
+				struct bfd_link_info *info)
 {
   asection *tls_sec;
 
@@ -13911,22 +13957,22 @@ elf32_arm_always_size_sections (bfd *output_bfd,
 	(elf_hash_table (info), "_TLS_MODULE_BASE_", TRUE, TRUE, FALSE);
 
       if (tlsbase)
-        {
-          struct bfd_link_hash_entry *bh = NULL;
+	{
+	  struct bfd_link_hash_entry *bh = NULL;
 	  const struct elf_backend_data *bed
-            = get_elf_backend_data (output_bfd);
+	    = get_elf_backend_data (output_bfd);
 
-          if (!(_bfd_generic_link_add_one_symbol
+	  if (!(_bfd_generic_link_add_one_symbol
 		(info, output_bfd, "_TLS_MODULE_BASE_", BSF_LOCAL,
 		 tls_sec, 0, NULL, FALSE,
 		 bed->collect, &bh)))
 	    return FALSE;
 
-      	  tlsbase->type = STT_TLS;
-          tlsbase = (struct elf_link_hash_entry *)bh;
-          tlsbase->def_regular = 1;
-          tlsbase->other = STV_HIDDEN;
-          (*bed->elf_backend_hide_symbol) (info, tlsbase, TRUE);
+	  tlsbase->type = STT_TLS;
+	  tlsbase = (struct elf_link_hash_entry *)bh;
+	  tlsbase->def_regular = 1;
+	  tlsbase->other = STV_HIDDEN;
+	  (*bed->elf_backend_hide_symbol) (info, tlsbase, TRUE);
 	}
     }
   return TRUE;
@@ -14034,6 +14080,38 @@ arm_put_trampoline (struct elf32_arm_link_hash_table *htab, bfd *output_bfd,
     }
 }
 
+/* Install the special first PLT entry for elf32-arm-nacl.  Unlike
+   other variants, NaCl needs this entry in a static executable's
+   .iplt too.  When we're handling that case, GOT_DISPLACEMENT is
+   zero.  For .iplt really only the last bundle is useful, and .iplt
+   could have a shorter first entry, with each individual PLT entry's
+   relative branch calculated differently so it targets the last
+   bundle instead of the instruction before it (labelled .Lplt_tail
+   above).  But it's simpler to keep the size and layout of PLT0
+   consistent with the dynamic case, at the cost of some dead code at
+   the start of .iplt and the one dead store to the stack at the start
+   of .Lplt_tail.  */
+static void
+arm_nacl_put_plt0 (struct elf32_arm_link_hash_table *htab, bfd *output_bfd,
+		   asection *plt, bfd_vma got_displacement)
+{
+  unsigned int i;
+
+  put_arm_insn (htab, output_bfd,
+		elf32_arm_nacl_plt0_entry[0]
+		| arm_movw_immediate (got_displacement),
+		plt->contents + 0);
+  put_arm_insn (htab, output_bfd,
+		elf32_arm_nacl_plt0_entry[1]
+		| arm_movt_immediate (got_displacement),
+		plt->contents + 4);
+
+  for (i = 2; i < ARRAY_SIZE (elf32_arm_nacl_plt0_entry); ++i)
+    put_arm_insn (htab, output_bfd,
+		  elf32_arm_nacl_plt0_entry[i],
+		  plt->contents + (i * 4));
+}
+
 /* Finish up the dynamic sections.  */
 
 static bfd_boolean
@@ -14199,16 +14277,16 @@ elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info
 	      break;
 
 	    case DT_TLSDESC_PLT:
-              s = htab->root.splt;
+	      s = htab->root.splt;
 	      dyn.d_un.d_ptr = (s->output_section->vma + s->output_offset
 				+ htab->dt_tlsdesc_plt);
 	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
 	      break;
 
 	    case DT_TLSDESC_GOT:
-              s = htab->root.sgot;
+	      s = htab->root.sgot;
 	      dyn.d_un.d_ptr = (s->output_section->vma + s->output_offset
-		      		+ htab->dt_tlsdesc_got);
+				+ htab->dt_tlsdesc_got);
 	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
 	      break;
 
@@ -14272,24 +14350,8 @@ elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info
 				     htab->srelplt2->contents);
 	    }
 	  else if (htab->nacl_p)
-	    {
-	      unsigned int i;
-
-	      got_displacement = got_address + 8 - (plt_address + 16);
-
-	      put_arm_insn (htab, output_bfd,
-			    elf32_arm_nacl_plt0_entry[0]
-			    | arm_movw_immediate (got_displacement),
-			    splt->contents + 0);
-	      put_arm_insn (htab, output_bfd,
-			    elf32_arm_nacl_plt0_entry[1]
-			    | arm_movt_immediate (got_displacement),
-			    splt->contents + 4);
-	      for (i = 2; i < ARRAY_SIZE (elf32_arm_nacl_plt0_entry); ++i)
-		put_arm_insn (htab, output_bfd,
-			      elf32_arm_nacl_plt0_entry[i],
-			      splt->contents + (i * 4));
-	    }
+	    arm_nacl_put_plt0 (htab, output_bfd, splt,
+			       got_address + 8 - (plt_address + 16));
 	  else
 	    {
 	      got_displacement = got_address - (plt_address + 16);
@@ -14382,6 +14444,10 @@ elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info
 	}
     }
 
+  if (htab->nacl_p && htab->root.iplt != NULL && htab->root.iplt->size > 0)
+    /* NaCl uses a special first entry in .iplt too.  */
+    arm_nacl_put_plt0 (htab, output_bfd, htab->root.iplt, 0);
+
   /* Fill in the first three entries in the global offset table.  */
   if (sgot)
     {
@@ -14953,6 +15019,15 @@ elf32_arm_output_arch_local_syms (bfd *output_bfd,
 #endif
 	}
     }
+  if (htab->nacl_p && htab->root.iplt && htab->root.iplt->size > 0)
+    {
+      /* NaCl uses a special first entry in .iplt too.  */
+      osi.sec = htab->root.iplt;
+      osi.sec_shndx = (_bfd_elf_section_from_bfd_section
+		       (output_bfd, osi.sec->output_section));
+      if (!elf32_arm_output_map_sym (&osi, ARM_MAP_ARM, 0))
+	return FALSE;
+    }
   if ((htab->root.splt && htab->root.splt->size > 0)
       || (htab->root.iplt && htab->root.iplt->size > 0))
     {
@@ -15089,7 +15164,7 @@ struct a8_branch_to_stub_data
 
 static bfd_boolean
 make_branch_to_a8_stub (struct bfd_hash_entry *gen_entry,
-                       void *in_arg)
+		       void *in_arg)
 {
   struct elf32_arm_stub_hash_entry *stub_entry;
   struct a8_branch_to_stub_data *data;
@@ -15228,82 +15303,82 @@ elf32_arm_write_section (bfd *output_bfd,
       unsigned int endianflip = bfd_big_endian (output_bfd) ? 3 : 0;
 
       for (errnode = arm_data->erratumlist; errnode != 0;
-           errnode = errnode->next)
-        {
-          bfd_vma target = errnode->vma - offset;
-
-          switch (errnode->type)
-            {
-            case VFP11_ERRATUM_BRANCH_TO_ARM_VENEER:
-              {
-                bfd_vma branch_to_veneer;
-                /* Original condition code of instruction, plus bit mask for
-                   ARM B instruction.  */
-                unsigned int insn = (errnode->u.b.vfp_insn & 0xf0000000)
-                                  | 0x0a000000;
+	   errnode = errnode->next)
+	{
+	  bfd_vma target = errnode->vma - offset;
+
+	  switch (errnode->type)
+	    {
+	    case VFP11_ERRATUM_BRANCH_TO_ARM_VENEER:
+	      {
+		bfd_vma branch_to_veneer;
+		/* Original condition code of instruction, plus bit mask for
+		   ARM B instruction.  */
+		unsigned int insn = (errnode->u.b.vfp_insn & 0xf0000000)
+				  | 0x0a000000;
 
 		/* The instruction is before the label.  */
 		target -= 4;
 
 		/* Above offset included in -4 below.  */
 		branch_to_veneer = errnode->u.b.veneer->vma
-                                   - errnode->vma - 4;
+				   - errnode->vma - 4;
 
 		if ((signed) branch_to_veneer < -(1 << 25)
 		    || (signed) branch_to_veneer >= (1 << 25))
 		  (*_bfd_error_handler) (_("%B: error: VFP11 veneer out of "
 					   "range"), output_bfd);
 
-                insn |= (branch_to_veneer >> 2) & 0xffffff;
-                contents[endianflip ^ target] = insn & 0xff;
-                contents[endianflip ^ (target + 1)] = (insn >> 8) & 0xff;
-                contents[endianflip ^ (target + 2)] = (insn >> 16) & 0xff;
-                contents[endianflip ^ (target + 3)] = (insn >> 24) & 0xff;
-              }
-              break;
+		insn |= (branch_to_veneer >> 2) & 0xffffff;
+		contents[endianflip ^ target] = insn & 0xff;
+		contents[endianflip ^ (target + 1)] = (insn >> 8) & 0xff;
+		contents[endianflip ^ (target + 2)] = (insn >> 16) & 0xff;
+		contents[endianflip ^ (target + 3)] = (insn >> 24) & 0xff;
+	      }
+	      break;
 
 	    case VFP11_ERRATUM_ARM_VENEER:
-              {
-                bfd_vma branch_from_veneer;
-                unsigned int insn;
+	      {
+		bfd_vma branch_from_veneer;
+		unsigned int insn;
 
-                /* Take size of veneer into account.  */
-                branch_from_veneer = errnode->u.v.branch->vma
-                                     - errnode->vma - 12;
+		/* Take size of veneer into account.  */
+		branch_from_veneer = errnode->u.v.branch->vma
+				     - errnode->vma - 12;
 
 		if ((signed) branch_from_veneer < -(1 << 25)
 		    || (signed) branch_from_veneer >= (1 << 25))
 		  (*_bfd_error_handler) (_("%B: error: VFP11 veneer out of "
 					   "range"), output_bfd);
 
-                /* Original instruction.  */
-                insn = errnode->u.v.branch->u.b.vfp_insn;
-                contents[endianflip ^ target] = insn & 0xff;
-                contents[endianflip ^ (target + 1)] = (insn >> 8) & 0xff;
-                contents[endianflip ^ (target + 2)] = (insn >> 16) & 0xff;
-                contents[endianflip ^ (target + 3)] = (insn >> 24) & 0xff;
-
-                /* Branch back to insn after original insn.  */
-                insn = 0xea000000 | ((branch_from_veneer >> 2) & 0xffffff);
-                contents[endianflip ^ (target + 4)] = insn & 0xff;
-                contents[endianflip ^ (target + 5)] = (insn >> 8) & 0xff;
-                contents[endianflip ^ (target + 6)] = (insn >> 16) & 0xff;
-                contents[endianflip ^ (target + 7)] = (insn >> 24) & 0xff;
-              }
-              break;
+		/* Original instruction.  */
+		insn = errnode->u.v.branch->u.b.vfp_insn;
+		contents[endianflip ^ target] = insn & 0xff;
+		contents[endianflip ^ (target + 1)] = (insn >> 8) & 0xff;
+		contents[endianflip ^ (target + 2)] = (insn >> 16) & 0xff;
+		contents[endianflip ^ (target + 3)] = (insn >> 24) & 0xff;
+
+		/* Branch back to insn after original insn.  */
+		insn = 0xea000000 | ((branch_from_veneer >> 2) & 0xffffff);
+		contents[endianflip ^ (target + 4)] = insn & 0xff;
+		contents[endianflip ^ (target + 5)] = (insn >> 8) & 0xff;
+		contents[endianflip ^ (target + 6)] = (insn >> 16) & 0xff;
+		contents[endianflip ^ (target + 7)] = (insn >> 24) & 0xff;
+	      }
+	      break;
 
-            default:
-              abort ();
-            }
-        }
+	    default:
+	      abort ();
+	    }
+	}
     }
 
   if (arm_data->elf.this_hdr.sh_type == SHT_ARM_EXIDX)
     {
       arm_unwind_table_edit *edit_node
-        = arm_data->u.exidx.unwind_edit_list;
+	= arm_data->u.exidx.unwind_edit_list;
       /* Now, sec->size is the size of the section we will write.  The original
-         size (before we merged duplicate entries and inserted EXIDX_CANTUNWIND
+	 size (before we merged duplicate entries and inserted EXIDX_CANTUNWIND
 	 markers) was sec->rawsize.  (This isn't the case if we perform no
 	 edits, then rawsize will be zero and we should use size).  */
       bfd_byte *edited_contents = (bfd_byte *) bfd_malloc (sec->size);
@@ -15312,13 +15387,13 @@ elf32_arm_write_section (bfd *output_bfd,
       bfd_vma add_to_offsets = 0;
 
       for (in_index = 0, out_index = 0; in_index * 8 < input_size || edit_node;)
-        {
+	{
 	  if (edit_node)
 	    {
 	      unsigned int edit_index = edit_node->index;
 
 	      if (in_index < edit_index && in_index * 8 < input_size)
-	        {
+		{
 		  copy_exidx_entry (output_bfd, edited_contents + out_index * 8,
 				    contents + in_index * 8, add_to_offsets);
 		  out_index++;
@@ -15327,7 +15402,7 @@ elf32_arm_write_section (bfd *output_bfd,
 	      else if (in_index == edit_index
 		       || (in_index * 8 >= input_size
 			   && edit_index == UINT_MAX))
-	        {
+		{
 		  switch (edit_node->type)
 		    {
 		    case DELETE_EXIDX_ENTRY:
@@ -15337,12 +15412,12 @@ elf32_arm_write_section (bfd *output_bfd,
 
 		    case INSERT_EXIDX_CANTUNWIND_AT_END:
 		      {
-		        asection *text_sec = edit_node->linked_section;
+			asection *text_sec = edit_node->linked_section;
 			bfd_vma text_offset = text_sec->output_section->vma
 					      + text_sec->output_offset
 					      + text_sec->size;
 			bfd_vma exidx_offset = offset + out_index * 8;
-		        unsigned long prel31_offset;
+			unsigned long prel31_offset;
 
 			/* Note: this is meant to be equivalent to an
 			   R_ARM_PREL31 relocation.  These synthetic
@@ -15407,45 +15482,45 @@ elf32_arm_write_section (bfd *output_bfd,
 
       ptr = map[0].vma;
       for (i = 0; i < mapcount; i++)
-        {
-          if (i == mapcount - 1)
+	{
+	  if (i == mapcount - 1)
 	    end = sec->size;
-          else
-            end = map[i + 1].vma;
+	  else
+	    end = map[i + 1].vma;
 
-          switch (map[i].type)
+	  switch (map[i].type)
 	    {
 	    case 'a':
 	      /* Byte swap code words.  */
 	      while (ptr + 3 < end)
-	        {
-	          tmp = contents[ptr];
-	          contents[ptr] = contents[ptr + 3];
-	          contents[ptr + 3] = tmp;
-	          tmp = contents[ptr + 1];
-	          contents[ptr + 1] = contents[ptr + 2];
-	          contents[ptr + 2] = tmp;
-	          ptr += 4;
-	        }
+		{
+		  tmp = contents[ptr];
+		  contents[ptr] = contents[ptr + 3];
+		  contents[ptr + 3] = tmp;
+		  tmp = contents[ptr + 1];
+		  contents[ptr + 1] = contents[ptr + 2];
+		  contents[ptr + 2] = tmp;
+		  ptr += 4;
+		}
 	      break;
 
 	    case 't':
 	      /* Byte swap code halfwords.  */
 	      while (ptr + 1 < end)
-	        {
-	          tmp = contents[ptr];
-	          contents[ptr] = contents[ptr + 1];
-	          contents[ptr + 1] = tmp;
-	          ptr += 2;
-	        }
+		{
+		  tmp = contents[ptr];
+		  contents[ptr] = contents[ptr + 1];
+		  contents[ptr + 1] = tmp;
+		  ptr += 2;
+		}
 	      break;
 
 	    case 'd':
 	      /* Leave data alone.  */
 	      break;
 	    }
-          ptr = end;
-        }
+	  ptr = end;
+	}
     }
 
   free (map);
@@ -15514,17 +15589,17 @@ elf32_arm_swap_symbol_out (bfd *abfd,
       if (ELF_ST_TYPE (src->st_info) != STT_GNU_IFUNC)
 	newsym.st_info = ELF_ST_INFO (ELF_ST_BIND (src->st_info), STT_FUNC);
       if (newsym.st_shndx != SHN_UNDEF)
-        {
-          /* Do this only for defined symbols. At link type, the static
-             linker will simulate the work of dynamic linker of resolving
-             symbols and will carry over the thumbness of found symbols to
-             the output symbol table. It's not clear how it happens, but
-             the thumbness of undefined symbols can well be different at
-             runtime, and writing '1' for them will be confusing for users
-             and possibly for dynamic linker itself.
-          */
-          newsym.st_value |= 1;
-        }
+	{
+	  /* Do this only for defined symbols. At link type, the static
+	     linker will simulate the work of dynamic linker of resolving
+	     symbols and will carry over the thumbness of found symbols to
+	     the output symbol table. It's not clear how it happens, but
+	     the thumbness of undefined symbols can well be different at
+	     runtime, and writing '1' for them will be confusing for users
+	     and possibly for dynamic linker itself.
+	  */
+	  newsym.st_value |= 1;
+	}
 
       src = &newsym;
     }
@@ -15552,7 +15627,7 @@ elf32_arm_modify_segment_map (bfd *abfd,
       if (!m)
 	{
 	  m = (struct elf_segment_map *)
-              bfd_zalloc (abfd, sizeof (struct elf_segment_map));
+	      bfd_zalloc (abfd, sizeof (struct elf_segment_map));
 	  if (m == NULL)
 	    return FALSE;
 	  m->p_type = PT_ARM_EXIDX;
@@ -15889,8 +15964,8 @@ elf32_arm_merge_private_bfd_data (bfd * ibfd, bfd * obfd)
 	 flags then do not bother setting the flags for the output
 	 architecture, instead allow future merges to do this.  If no
 	 future merges ever set these flags then they will retain their
-         uninitialised values, which surprise surprise, correspond
-         to the default values.  */
+	 uninitialised values, which surprise surprise, correspond
+	 to the default values.  */
       if (bfd_get_arch_info (ibfd)->the_default
 	  && elf_elfheader (ibfd)->e_flags == 0)
 	return TRUE;
@@ -15938,7 +16013,7 @@ elf32_arm_merge_private_bfd_data (bfd * ibfd, bfd * obfd)
 	      if ((bfd_get_section_flags (ibfd, sec)
 		   & (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))
 		  == (SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS))
-	    	only_data_sections = FALSE;
+		only_data_sections = FALSE;
 
 	      null_input_bfd = FALSE;
 	      break;
diff --git a/bfd/elflink.c b/bfd/elflink.c
index bcd3add..3c08d5f 100644
--- a/bfd/elflink.c
+++ b/bfd/elflink.c
@@ -3368,6 +3368,7 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
   bfd_size_type old_dynstr_size = 0;
   size_t tabsize = 0;
   size_t hashsize = 0;
+  asection *s;
 
   htab = elf_hash_table (info);
   bed = get_elf_backend_data (abfd);
@@ -3409,75 +3410,64 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
      symbol.  This differs from .gnu.warning sections, which generate
      warnings when they are included in an output file.  */
   /* PR 12761: Also generate this warning when building shared libraries.  */
-  if (info->executable || info->shared)
+  for (s = abfd->sections; s != NULL; s = s->next)
     {
-      asection *s;
+      const char *name;
 
-      for (s = abfd->sections; s != NULL; s = s->next)
+      name = bfd_get_section_name (abfd, s);
+      if (CONST_STRNEQ (name, ".gnu.warning."))
 	{
-	  const char *name;
+	  char *msg;
+	  bfd_size_type sz;
+
+	  name += sizeof ".gnu.warning." - 1;
 
-	  name = bfd_get_section_name (abfd, s);
-	  if (CONST_STRNEQ (name, ".gnu.warning."))
+	  /* If this is a shared object, then look up the symbol
+	     in the hash table.  If it is there, and it is already
+	     been defined, then we will not be using the entry
+	     from this shared object, so we don't need to warn.
+	     FIXME: If we see the definition in a regular object
+	     later on, we will warn, but we shouldn't.  The only
+	     fix is to keep track of what warnings we are supposed
+	     to emit, and then handle them all at the end of the
+	     link.  */
+	  if (dynamic)
 	    {
-	      char *msg;
-	      bfd_size_type sz;
-
-	      name += sizeof ".gnu.warning." - 1;
-
-	      /* If this is a shared object, then look up the symbol
-		 in the hash table.  If it is there, and it is already
-		 been defined, then we will not be using the entry
-		 from this shared object, so we don't need to warn.
-		 FIXME: If we see the definition in a regular object
-		 later on, we will warn, but we shouldn't.  The only
-		 fix is to keep track of what warnings we are supposed
-		 to emit, and then handle them all at the end of the
-		 link.  */
-	      if (dynamic)
-		{
-		  struct elf_link_hash_entry *h;
+	      struct elf_link_hash_entry *h;
 
-		  h = elf_link_hash_lookup (htab, name, FALSE, FALSE, TRUE);
+	      h = elf_link_hash_lookup (htab, name, FALSE, FALSE, TRUE);
 
-		  /* FIXME: What about bfd_link_hash_common?  */
-		  if (h != NULL
-		      && (h->root.type == bfd_link_hash_defined
-			  || h->root.type == bfd_link_hash_defweak))
-		    {
-		      /* We don't want to issue this warning.  Clobber
-			 the section size so that the warning does not
-			 get copied into the output file.  */
-		      s->size = 0;
-		      continue;
-		    }
-		}
+	      /* FIXME: What about bfd_link_hash_common?  */
+	      if (h != NULL
+		  && (h->root.type == bfd_link_hash_defined
+		      || h->root.type == bfd_link_hash_defweak))
+		continue;
+	    }
 
-	      sz = s->size;
-	      msg = (char *) bfd_alloc (abfd, sz + 1);
-	      if (msg == NULL)
-		goto error_return;
+	  sz = s->size;
+	  msg = (char *) bfd_alloc (abfd, sz + 1);
+	  if (msg == NULL)
+	    goto error_return;
 
-	      if (! bfd_get_section_contents (abfd, s, msg, 0, sz))
-		goto error_return;
+	  if (! bfd_get_section_contents (abfd, s, msg, 0, sz))
+	    goto error_return;
 
-	      msg[sz] = '\0';
+	  msg[sz] = '\0';
 
-	      if (! (_bfd_generic_link_add_one_symbol
-		     (info, abfd, name, BSF_WARNING, s, 0, msg,
-		      FALSE, bed->collect, NULL)))
-		goto error_return;
+	  if (! (_bfd_generic_link_add_one_symbol
+		 (info, abfd, name, BSF_WARNING, s, 0, msg,
+		  FALSE, bed->collect, NULL)))
+	    goto error_return;
 
-	      if (! info->relocatable)
-		{
-		  /* Clobber the section size so that the warning does
-		     not get copied into the output file.  */
-		  s->size = 0;
+	  if (!info->relocatable && info->executable)
+	    {
+	      /* Clobber the section size so that the warning does
+		 not get copied into the output file.  */
+	      s->size = 0;
 
-		  /* Also set SEC_EXCLUDE, so that symbols defined in
-		     the warning section don't get copied to the output.  */
-		  s->flags |= SEC_EXCLUDE;
-		}
+	      /* Also set SEC_EXCLUDE, so that symbols defined in
+		 the warning section don't get copied to the output.  */
+	      s->flags |= SEC_EXCLUDE;
 	    }
 	}
     }
@@ -3503,7 +3493,6 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
     goto error_return;
   else
     {
-      asection *s;
       const char *soname = NULL;
       char *audit = NULL;
       struct bfd_link_needed_list *rpath = NULL, *runpath = NULL;
diff --git a/bfd/version.h b/bfd/version.h
index eac66f0..d8a5dee 100644
--- a/bfd/version.h
+++ b/bfd/version.h
@@ -1,4 +1,4 @@
-#define BFD_VERSION_DATE 20130325
+#define BFD_VERSION_DATE 20130817
 #define BFD_VERSION @bfd_version@
 #define BFD_VERSION_STRING  @bfd_version_package@ @bfd_version_string@
 #define REPORT_BUGS_TO @report_bugs_to@
diff --git a/gas/ChangeLog b/gas/ChangeLog
index 821acc9..5f37a76 100644
--- a/gas/ChangeLog
+++ b/gas/ChangeLog
@@ -1,3 +1,39 @@
+2013-06-24  Roland McGrath  <mcgrathr@google.com>
+
+	* config/tc-arm.c (parse_reg_list): Use skip_past_char for '}',
+	so it skips whitespace before it.
+	(s_arm_unwind_save_mmxwr, s_arm_unwind_save_mmxwcg): Likewise.
+
+2013-01-07  Nick Clifton  <nickc@redhat.com>
+
+	PR gas/14887
+	* config/tc-arm.c (skip_past_char): Skip whitespace before the
+	anticipated character.
+	* config/tc-arm.c (parse_address_main): Delete skip of whitespace
+	here as it is no longer needed.
+
+2013-01-02  Nick Clifton  <nickc@redhat.com>
+
+	PR gas/14987
+	* config/tc-arm.c (parse_address_main): Skip whitespace before a
+	closing bracket.
+
+2013-06-24  Roland McGrath  <mcgrathr@google.com>
+
+	* config/tc-arm.c (arm_symbol_chars): Include '{' and '}'.
+	(arm_reg_parse_multi): Skip whitespace first.
+	(parse_reg_list): Likewise.
+	(parse_vfp_reg_list): Likewise.
+	(s_arm_unwind_save_mmxwcg): Likewise.
+
+2013-05-13 Yufeng Zhang <yufeng.zhang@arm.com>
+
+	Backport from mainline:
+
+	2013-02-27 Yufeng Zhang <yufeng.zhang@arm.com>
+	* config/tc-aarch64.c (parse_sys_reg): Allow the full range of CRn
+	for system registers.
+
 2013-03-05  Yufeng Zhang  <yufeng.zhang@arm.com>
 
 	* config/tc-aarch64.c (aarch64_imm_float_p): Rename 'e' to 'pattern';
diff --git a/gas/config/tc-aarch64.c b/gas/config/tc-aarch64.c
index 162c865..db28c71 100644
--- a/gas/config/tc-aarch64.c
+++ b/gas/config/tc-aarch64.c
@@ -3243,10 +3243,14 @@ parse_sys_reg (char **str, struct hash_control *sys_regs, int imple_defined_p)
 	  unsigned int op0, op1, cn, cm, op2;
 	  if (sscanf (buf, "s%u_%u_c%u_c%u_%u", &op0, &op1, &cn, &cm, &op2) != 5)
 	    return PARSE_FAIL;
-	  /* Register access is encoded as follows:
+	  /* The architecture specifies the encoding space for implementation
+	     defined registers as:
 	     op0  op1  CRn   CRm   op2
-	     11   xxx  1x11  xxxx  xxx.  */
-	  if (op0 != 3 || op1 > 7 || (cn | 0x4) != 0xf || cm > 15 || op2 > 7)
+	     11   xxx  1x11  xxxx  xxx
+	     For convenience GAS accepts a wider encoding space, as follows:
+	     op0  op1  CRn   CRm   op2
+	     11   xxx  xxxx  xxxx  xxx  */
+	  if (op0 != 3 || op1 > 7 || cn > 15 || cm > 15 || op2 > 7)
 	    return PARSE_FAIL;
 	  value = (op0 << 14) | (op1 << 11) | (cn << 7) | (cm << 3) | op2;
 	}
diff --git a/gas/config/tc-arm.c b/gas/config/tc-arm.c
index 48316a5..516cc9a 100644
--- a/gas/config/tc-arm.c
+++ b/gas/config/tc-arm.c
@@ -323,8 +323,9 @@ static bfd_boolean unified_syntax = FALSE;
 
 /* An immediate operand can start with #, and ld*, st*, pld operands
    can contain [ and ].  We need to tell APP not to elide whitespace
-   before a [, which can appear as the first operand for pld.  */
-const char arm_symbol_chars[] = "#[]";
+   before a [, which can appear as the first operand for pld.
+   Likewise, a { can appear as the first operand for push, pop, vld*, etc.  */
+const char arm_symbol_chars[] = "#[]{}";
 
 enum neon_el_type
 {
@@ -885,6 +886,9 @@ const char FLT_CHARS[] = "rRsSfFdDxXeEpP";
 static inline int
 skip_past_char (char ** str, char c)
 {
+  /* PR gas/14987: Allow for whitespace before the expected character.  */
+  skip_whitespace (*str);
+  
   if (**str == c)
     {
       (*str)++;
@@ -1154,6 +1158,8 @@ arm_reg_parse_multi (char **ccp)
   char *p;
   struct reg_entry *reg;
 
+  skip_whitespace (start);
+
 #ifdef REGISTER_PREFIX
   if (*start != REGISTER_PREFIX)
     return NULL;
@@ -1579,6 +1585,8 @@ parse_reg_list (char ** strp)
   /* We come back here if we get ranges concatenated by '+' or '|'.  */
   do
     {
+      skip_whitespace (str);
+
       another_range = 0;
 
       if (*str == '{')
@@ -1632,7 +1640,7 @@ parse_reg_list (char ** strp)
 		 || (in_range = 1, *str++ == '-'));
 	  str--;
 
-	  if (*str++ != '}')
+	  if (skip_past_char (&str, '}') == FAIL)
 	    {
 	      first_error (_("missing `}'"));
 	      return FAIL;
@@ -1730,14 +1738,12 @@ parse_vfp_reg_list (char **ccp, unsigned int *pbase, enum reg_list_els etype)
   unsigned long mask = 0;
   int i;
 
-  if (*str != '{')
+  if (skip_past_char (&str, '{') == FAIL)
     {
       inst.error = _("expecting {");
       return FAIL;
     }
 
-  str++;
-
   switch (etype)
     {
     case REGLIST_VFP_S:
@@ -3928,8 +3934,7 @@ s_arm_unwind_save_mmxwr (void)
     }
   while (skip_past_comma (&input_line_pointer) != FAIL);
 
-  if (*input_line_pointer == '}')
-    input_line_pointer++;
+  skip_past_char (&input_line_pointer, '}');
 
   demand_empty_rest_of_line ();
 
@@ -4026,6 +4031,8 @@ s_arm_unwind_save_mmxwcg (void)
   if (*input_line_pointer == '{')
     input_line_pointer++;
 
+  skip_whitespace (input_line_pointer);
+
   do
     {
       reg = arm_reg_parse (&input_line_pointer, REG_TYPE_MMXWCG);
@@ -4061,8 +4068,7 @@ s_arm_unwind_save_mmxwcg (void)
     }
   while (skip_past_comma (&input_line_pointer) != FAIL);
 
-  if (*input_line_pointer == '}')
-    input_line_pointer++;
+  skip_past_char (&input_line_pointer, '}');
 
   demand_empty_rest_of_line ();
 
@@ -5168,6 +5174,9 @@ parse_address_main (char **str, int i, int group_relocations,
       return PARSE_OPERAND_SUCCESS;
     }
 
+  /* PR gas/14887: Allow for whitespace after the opening bracket.  */
+  skip_whitespace (p);
+
   if ((reg = arm_reg_parse (&p, REG_TYPE_RN)) == FAIL)
     {
       inst.error = _(reg_expected_msgs[REG_TYPE_RN]);
diff --git a/gas/testsuite/ChangeLog b/gas/testsuite/ChangeLog
index d1ebc3b..806fabd 100644
--- a/gas/testsuite/ChangeLog
+++ b/gas/testsuite/ChangeLog
@@ -1,3 +1,46 @@
+2013-06-24  Roland McGrath  <mcgrathr@google.com>
+
+	* gas/arm/macro-vld1.s: Add a case with whitespace before '}'.
+	* gas/arm/macro-vld1.d: Update.
+
+2013-01-07  Nick Clifton  <nickc@redhat.com>
+
+	PR gas/14887
+	* gas/arm/neon-ldst-es.s: Add more whitespace.
+
+2013-01-02  Nick Clifton  <nickc@redhat.com>
+
+	PR gas/14987
+	* gas/arm/neon-ldst-es.s: Add whitespace test.
+	* gas/arm/neon-ldst-es.d: Update expected disassembly.
+
+2013-06-24  Roland McGrath  <mcgrathr@google.com>
+
+	* gas/arm/macro-pld.s: Add a 'push {r0}' case.
+	* gas/arm/macro-pld.d: Update expected output.
+	* gas/arm/macro-vld1.s: New file.
+	* gas/arm/macro-vld1.d: New file.
+
+2013-05-13  Yufeng Zhang  <yufeng.zhang@arm.com>
+
+	Backport from mainline:
+
+	2013-05-13  Yufeng Zhang  <yufeng.zhang@arm.com>
+	* gas/aarch64/diagnostic.s: Update.
+	* gas/aarch64/diagnostic.l: Ditto.
+	* gas/aarch64/movi.s: Add new tests.
+	* gas/aarch64/movi.d: Update.
+
+2013-05-13 Yufeng Zhang <yufeng.zhang@arm.com>
+
+	Backport from mainline:
+
+	2013-02-27 Yufeng Zhang <yufeng.zhang@arm.com>
+	* gas/aarch64/illegal.l: Delete the error message for
+	msr S3_1_C13_C15_1,x7.
+	* gas/aarch64/sysreg.s: Add new tests.
+	* gas/aarch64/sysreg.d: Update.
+
 2013-03-08  Christian Groessler  <chris@groessler.org>
 
 	Backport from mainline:
diff --git a/gas/testsuite/gas/aarch64/diagnostic.l b/gas/testsuite/gas/aarch64/diagnostic.l
index f37f11c..d7a1347 100644
--- a/gas/testsuite/gas/aarch64/diagnostic.l
+++ b/gas/testsuite/gas/aarch64/diagnostic.l
@@ -38,8 +38,8 @@
 [^:]*:40: Error: invalid shift amount at operand 3 -- `shll v1.4s,v2.4h,#32'
 [^:]*:41: Error: immediate value out of range 0 to 31 at operand 3 -- `shl v1.2s,v2.2s,32'
 [^:]*:42: Error: immediate value out of range 1 to 8 at operand 3 -- `sqshrn2 v2.16b,v3.8h,#17'
-[^:]*:43: Error: immediate value out of range 0 to 255 at operand 2 -- `movi v1.4h,256'
-[^:]*:44: Error: immediate value out of range 0 to 255 at operand 2 -- `movi v1.4h,-1'
+[^:]*:43: Error: immediate value out of range -128 to 255 at operand 2 -- `movi v1.4h,256'
+[^:]*:44: Error: immediate value out of range -128 to 255 at operand 2 -- `movi v1.4h,-129'
 [^:]*:45: Error: invalid shift operator at operand 2 -- `movi v1.4h,255,msl#8'
 [^:]*:46: Error: invalid value for immediate at operand 2 -- `movi d0,256'
 [^:]*:47: Error: immediate value should be a multiple of 8 at operand 2 -- `movi v1.4h,255,lsl#7'
diff --git a/gas/testsuite/gas/aarch64/diagnostic.s b/gas/testsuite/gas/aarch64/diagnostic.s
index 99ebf8f..e5443ab 100644
--- a/gas/testsuite/gas/aarch64/diagnostic.s
+++ b/gas/testsuite/gas/aarch64/diagnostic.s
@@ -41,7 +41,7 @@
 	shl	v1.2s, v2.2s, 32
 	sqshrn2	v2.16b, v3.8h, #17
 	movi	v1.4h, 256
-	movi	v1.4h, -1
+	movi	v1.4h, -129
 	movi	v1.4h, 255, msl #8
 	movi	d0, 256
 	movi	v1.4h, 255, lsl #7
diff --git a/gas/testsuite/gas/aarch64/illegal.l b/gas/testsuite/gas/aarch64/illegal.l
index e17a1de..f7e4074 100644
--- a/gas/testsuite/gas/aarch64/illegal.l
+++ b/gas/testsuite/gas/aarch64/illegal.l
@@ -520,7 +520,6 @@
 [^:]*:496: Error: .*`str x1,page_table_count'
 [^:]*:498: Error: .*`prfm PLDL3KEEP,\[x9,x15,sxtx#2\]'
 [^:]*:500: Error: .*`mrs x5,S1_0_C13_C8_0'
-[^:]*:501: Error: .*`msr S3_1_C13_C15_1,x7'
 [^:]*:502: Error: .*`msr S3_1_C11_C15_-1,x7'
 [^:]*:503: Error: .*`msr S3_1_11_15_1,x7'
 [^:]*:506: Error: .*`movi w1,#15'
diff --git a/gas/testsuite/gas/aarch64/movi.d b/gas/testsuite/gas/aarch64/movi.d
index 2c73cc4..c225b21 100644
--- a/gas/testsuite/gas/aarch64/movi.d
+++ b/gas/testsuite/gas/aarch64/movi.d
@@ -8201,3 +8201,6 @@ Disassembly of section \.text:
     8004:	6f07e7e0 	movi	v0.2d, #0xffffffffffffffff
     8008:	6f07e7e0 	movi	v0.2d, #0xffffffffffffffff
     800c:	2f07e7ff 	movi	d31, #0xffffffffffffffff
+    8010:	0f04e403 	movi	v3.8b, #0x80
+    8014:	0f04e423 	movi	v3.8b, #0x81
+    8018:	0f07e7e3 	movi	v3.8b, #0xff
diff --git a/gas/testsuite/gas/aarch64/movi.s b/gas/testsuite/gas/aarch64/movi.s
index 99ca34a..76f2d47 100644
--- a/gas/testsuite/gas/aarch64/movi.s
+++ b/gas/testsuite/gas/aarch64/movi.s
@@ -102,3 +102,8 @@
 	movi	v0.2d, bignum
 	movi	d31, 18446744073709551615
 .set    bignum, 0xffffffffffffffff
+
+	// Allow -128 to 255 in #<imm8>
+	movi	v3.8b, -128
+	movi	v3.8b, -127
+	movi	v3.8b, -1
diff --git a/gas/testsuite/gas/aarch64/sysreg.d b/gas/testsuite/gas/aarch64/sysreg.d
index b83b270..c7cf00e 100644
--- a/gas/testsuite/gas/aarch64/sysreg.d
+++ b/gas/testsuite/gas/aarch64/sysreg.d
@@ -23,3 +23,6 @@ Disassembly of section \.text:
   3c:	d5380260 	mrs	x0, id_isar3_el1
   40:	d5380280 	mrs	x0, id_isar4_el1
   44:	d53802a0 	mrs	x0, id_isar5_el1
+  48:	d538cc00 	mrs	x0, s3_0_c12_c12_0
+  4c:	d5384600 	mrs	x0, s3_0_c4_c6_0
+  50:	d5184600 	msr	s3_0_c4_c6_0, x0
diff --git a/gas/testsuite/gas/aarch64/sysreg.s b/gas/testsuite/gas/aarch64/sysreg.s
index e6f770e..3287594 100644
--- a/gas/testsuite/gas/aarch64/sysreg.s
+++ b/gas/testsuite/gas/aarch64/sysreg.s
@@ -22,3 +22,7 @@
 	mrs x0, id_isar3_el1
 	mrs x0, id_isar4_el1
 	mrs x0, id_isar5_el1
+
+	mrs x0, s3_0_c12_c12_0
+	mrs x0, s3_0_c4_c6_0
+	msr s3_0_c4_c6_0, x0
diff --git a/gas/testsuite/gas/arm/macro-pld.d b/gas/testsuite/gas/arm/macro-pld.d
index 8f9d86c..e3a7843 100644
--- a/gas/testsuite/gas/arm/macro-pld.d
+++ b/gas/testsuite/gas/arm/macro-pld.d
@@ -6,3 +6,4 @@ Disassembly of section \.text:
 
 0+ <.*>:
 \s*0:\s+f5d0f000\s+pld\s+\[r0\]
+\s*4:\s+e52d0004\s+push\s+{r0}\s*.*
diff --git a/gas/testsuite/gas/arm/macro-pld.s b/gas/testsuite/gas/arm/macro-pld.s
index cf4df8b..f2a436b 100644
--- a/gas/testsuite/gas/arm/macro-pld.s
+++ b/gas/testsuite/gas/arm/macro-pld.s
@@ -2,3 +2,4 @@
 	\rest
 .endm
 	foo r0, pld [r0]
+	foo r0, push {r0}
diff --git a/gas/testsuite/gas/arm/neon-ldst-es.d b/gas/testsuite/gas/arm/neon-ldst-es.d
index 82bbab3..6c22c69 100644
--- a/gas/testsuite/gas/arm/neon-ldst-es.d
+++ b/gas/testsuite/gas/arm/neon-ldst-es.d
@@ -55,3 +55,4 @@ Disassembly of section \.text:
 0[0-9a-f]+ <[^>]+> f427288f 	vld2\.32	{d2-d3}, \[r7\]
 0[0-9a-f]+ <[^>]+> f427208f 	vld4\.32	{d2-d5}, \[r7\]
 0[0-9a-f]+ <[^>]+> f467c08f 	vld4\.32	{d28-d31}, \[r7\]
+0[0-9a-f]+ <[^>]+> f4a21c83 	vld1\.32	{d1\[\]}, \[r2\], r3
diff --git a/gas/testsuite/gas/arm/neon-ldst-es.s b/gas/testsuite/gas/arm/neon-ldst-es.s
index c97794c..79f4b0c 100644
--- a/gas/testsuite/gas/arm/neon-ldst-es.s
+++ b/gas/testsuite/gas/arm/neon-ldst-es.s
@@ -57,3 +57,6 @@
 	vld2.32 {q1},[r7]
 	vld4.32 {q1-q2},[r7]
 	vld4.32 {q14-q15},[r7]
+
+	@ PR 14987 and 14887: Allow for whitespace in the instruction.
+	vld1.32 { d1 [ ] } , [ r2 ] , r3
diff --git a/gold/ChangeLog b/gold/ChangeLog
index 1e21f57..69b7645 100644
--- a/gold/ChangeLog
+++ b/gold/ChangeLog
@@ -1,3 +1,40 @@
+2013-08-16  Roland McGrath  <mcgrathr@google.com>
+
+	* i386.cc (Target_i386_nacl::do_code_fill): New virtual function.
+	* x86_64.cc (Target_x86_64_nacl::do_code_fill): New virtual function.
+
+2013-07-19  Roland McGrath  <mcgrathr@google.com>
+
+	* options.h (General_options): Add -Trodata-segment option.
+	* parameters.cc (Parameters::check_rodata_segment): New function.
+	(Parameters::set_target_once): Call it.
+	* parameters.h (Parameters): Declare it (private member function).
+	* layout.cc (load_seg_unusable_for_headers): New function, broken
+	out of Layout::relaxation_loop_body.  If TARGET->isolate_execinstr()
+	then validate rodata segment rather than text segment.
+	(relaxation_loop_body): Call that.
+	(is_text_segment): New function.  Don't admit a non-executable
+	segment if TARGET->isolate_execinstr().
+	(set_segment_offsets): Call it.  Honor -Trodata-segment option.
+
+2013-02-15  Ian Lance Taylor  <iant@google.com>
+
+	* options.h (DEFINE_uint64_alias): Define.
+	(class General_options): Add -Ttext-segment as an alias for
+	-Ttext.
+
+2013-05-10  Roland McGrath  <mcgrathr@google.com>
+
+	* options.h (General_options): Add --rosegment-gap option.
+	* options.cc (finalize): --rosegment-gap implies --rosegment.
+	* layout.cc (set_segment_offsets): Let user option override
+	target->rosegment_gap().
+
+2013-05-10  Roland McGrath  <mcgrathr@google.com>
+
+	* options.h (General_options): Remove leading space from help
+	messages for -nostdlib and --rosegment.
+
 2012-12-06  Roland McGrath  <mcgrathr@google.com>
 
 	* configure.ac (HAVE_ZLIB): Use AM_ZLIB instead of AC_SEARCH_LIBS.
diff --git a/gold/i386.cc b/gold/i386.cc
index 3f0a039..47f2de4 100644
--- a/gold/i386.cc
+++ b/gold/i386.cc
@@ -3930,6 +3930,9 @@ class Target_i386_nacl : public Target_i386
       return new Output_data_plt_i386_nacl_exec(layout, got_plt, got_irelative);
   }
 
+  virtual std::string
+  do_code_fill(section_size_type length) const;
+
  private:
   static const Target::Target_info i386_nacl_info;
 };
@@ -4129,6 +4132,15 @@ Output_data_plt_i386_nacl::plt_eh_frame_fde[plt_eh_frame_fde_size] =
   elfcpp::DW_CFA_nop
 };
 
+// Return a string used to fill a code section with nops.
+// For NaCl, long NOPs are only valid if they do not cross
+// bundle alignment boundaries, so keep it simple with one-byte NOPs.
+std::string
+Target_i386_nacl::do_code_fill(section_size_type length) const
+{
+  return std::string(length, static_cast<char>(0x90));
+}
+
 // The selector for i386-nacl object files.
 
 class Target_selector_i386_nacl
diff --git a/gold/layout.cc b/gold/layout.cc
index ad667ab..05f7afb 100644
--- a/gold/layout.cc
+++ b/gold/layout.cc
@@ -1,6 +1,6 @@
 // layout.cc -- lay out output file sections for gold
 
-// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012
+// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
 // Free Software Foundation, Inc.
 // Written by Ian Lance Taylor <iant@google.com>.
 
@@ -2168,6 +2168,22 @@ Layout::prepare_for_relaxation()
   this->record_output_section_data_from_script_ = true;
 }
 
+// If the user set the address of the text segment, that may not be
+// compatible with putting the segment headers and file headers into
+// that segment.  For isolate_execinstr() targets, it's the rodata
+// segment rather than text where we might put the headers.
+static inline bool
+load_seg_unusable_for_headers(const Target* target)
+{
+  const General_options& options = parameters->options();
+  if (target->isolate_execinstr())
+    return (options.user_set_Trodata_segment()
+	    && options.Trodata_segment() % target->common_pagesize() != 0);
+  else
+    return (options.user_set_Ttext()
+	    && options.Ttext() % target->common_pagesize() != 0);
+}
+
 // Relaxation loop body:  If target has no relaxation, this runs only once
 // Otherwise, the target relaxation hook is called at the end of
 // each iteration.  If the hook returns true, it means re-layout of
@@ -2220,11 +2236,7 @@ Layout::relaxation_loop_body(
       != General_options::OBJECT_FORMAT_ELF)
     load_seg = NULL;
 
-  // If the user set the address of the text segment, that may not be
-  // compatible with putting the segment headers and file headers into
-  // that segment.
-  if (parameters->options().user_set_Ttext()
-      && parameters->options().Ttext() % target->common_pagesize() != 0)
+  if (load_seg_unusable_for_headers(target))
     {
       load_seg = NULL;
       phdr_seg = NULL;
@@ -3114,6 +3126,20 @@ align_file_offset(off_t off, uint64_t addr, uint64_t abi_pagesize)
   return aligned_off;
 }
 
+// On targets where the text segment contains only executable code,
+// a non-executable segment is never the text segment.
+
+static inline bool
+is_text_segment(const Target* target, const Output_segment* seg)
+{
+  elfcpp::Elf_Xword flags = seg->flags();
+  if ((flags & elfcpp::PF_W) != 0)
+    return false;
+  if ((flags & elfcpp::PF_X) == 0)
+    return !target->isolate_execinstr();
+  return true;
+}
+
 // Set the file offsets of all the segments, and all the sections they
 // contain.  They have all been created.  LOAD_SEG must be be laid out
 // first.  Return the offset of the data to follow.
@@ -3205,8 +3231,15 @@ Layout::set_segment_offsets(const Target* target, Output_segment* load_seg,
 	      addr = (*p)->paddr();
 	    }
 	  else if (parameters->options().user_set_Ttext()
-		   && ((*p)->flags() & elfcpp::PF_W) == 0)
+		   && (parameters->options().omagic()
+		       || is_text_segment(target, *p)))
+	    {
+	      are_addresses_set = true;
+	    }
+	  else if (parameters->options().user_set_Trodata_segment()
+		   && ((*p)->flags() & (elfcpp::PF_W | elfcpp::PF_X)) == 0)
 	    {
+	      addr = parameters->options().Trodata_segment();
 	      are_addresses_set = true;
 	    }
 	  else if (parameters->options().user_set_Tdata()
@@ -3255,7 +3288,10 @@ Layout::set_segment_offsets(const Target* target, Output_segment* load_seg,
 
 		  // If the target wants a fixed minimum distance from the
 		  // text segment to the read-only segment, move up now.
-		  uint64_t min_addr = start_addr + target->rosegment_gap();
+		  uint64_t min_addr =
+		    start_addr + (parameters->options().user_set_rosegment_gap()
+				  ? parameters->options().rosegment_gap()
+				  : target->rosegment_gap());
 		  if (addr < min_addr)
 		    addr = min_addr;
 
diff --git a/gold/options.cc b/gold/options.cc
index fe9a00e..e44a2fe 100644
--- a/gold/options.cc
+++ b/gold/options.cc
@@ -1,6 +1,7 @@
 // options.c -- handle command line options for gold
 
-// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
+// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2013
+// Free Software Foundation, Inc.
 // Written by Ian Lance Taylor <iant@google.com>.
 
 // This file is part of gold.
@@ -101,11 +102,11 @@ One_option::print() const
     {
       len += printf("-%c", this->shortname);
       if (this->helparg)
-        {
-          // -z takes long-names only.
-          gold_assert(this->dashes != DASH_Z);
-          len += printf(" %s", gettext(this->helparg));
-        }
+	{
+	  // -z takes long-names only.
+	  gold_assert(this->dashes != DASH_Z);
+	  len += printf(" %s", gettext(this->helparg));
+	}
       comma = true;
     }
   if (!this->longname.empty()
@@ -113,29 +114,29 @@ One_option::print() const
 	   && this->longname[1] == '\0'))
     {
       if (comma)
-        len += printf(", ");
+	len += printf(", ");
       switch (this->dashes)
-        {
-        case options::ONE_DASH: case options::EXACTLY_ONE_DASH:
-          len += printf("-");
-          break;
-        case options::TWO_DASHES: case options::EXACTLY_TWO_DASHES:
-          len += printf("--");
-          break;
-        case options::DASH_Z:
-          len += printf("-z ");
-          break;
-        default:
-          gold_unreachable();
-        }
+	{
+	case options::ONE_DASH: case options::EXACTLY_ONE_DASH:
+	  len += printf("-");
+	  break;
+	case options::TWO_DASHES: case options::EXACTLY_TWO_DASHES:
+	  len += printf("--");
+	  break;
+	case options::DASH_Z:
+	  len += printf("-z ");
+	  break;
+	default:
+	  gold_unreachable();
+	}
       len += printf("%s", this->longname.c_str());
       if (this->helparg)
-        {
-          // For most options, we print "--frob FOO".  But for -z
-          // we print "-z frob=FOO".
-          len += printf("%c%s", this->dashes == options::DASH_Z ? '=' : ' ',
-                        gettext(this->helparg));
-        }
+	{
+	  // For most options, we print "--frob FOO".  But for -z
+	  // we print "-z frob=FOO".
+	  len += printf("%c%s", this->dashes == options::DASH_Z ? '=' : ' ',
+			gettext(this->helparg));
+	}
     }
 
   if (len >= 30)
@@ -200,7 +201,7 @@ parse_uint(const char* option_name, const char* arg, int* retval)
   *retval = strtol(arg, &endptr, 0);
   if (*endptr != '\0' || *retval < 0)
     gold_fatal(_("%s: invalid option value (expected an integer): %s"),
-               option_name, arg);
+	       option_name, arg);
 }
 
 void
@@ -210,7 +211,7 @@ parse_int(const char* option_name, const char* arg, int* retval)
   *retval = strtol(arg, &endptr, 0);
   if (*endptr != '\0')
     gold_fatal(_("%s: invalid option value (expected an integer): %s"),
-               option_name, arg);
+	       option_name, arg);
 }
 
 void
@@ -220,7 +221,7 @@ parse_uint64(const char* option_name, const char* arg, uint64_t* retval)
   *retval = strtoull(arg, &endptr, 0);
   if (*endptr != '\0')
     gold_fatal(_("%s: invalid option value (expected an integer): %s"),
-               option_name, arg);
+	       option_name, arg);
 }
 
 void
@@ -273,13 +274,13 @@ parse_set(const char*, const char* arg, String_set* retval)
 
 void
 parse_choices(const char* option_name, const char* arg, const char** retval,
-              const char* choices[], int num_choices)
+	      const char* choices[], int num_choices)
 {
   for (int i = 0; i < num_choices; i++)
     if (strcmp(choices[i], arg) == 0)
       {
-        *retval = arg;
-        return;
+	*retval = arg;
+	return;
       }
 
   // If we get here, the user did not enter a valid choice, so we die.
@@ -288,10 +289,10 @@ parse_choices(const char* option_name, const char* arg, const char** retval,
     {
       choices_list += choices[i];
       if (i != num_choices - 1)
-        choices_list += ", ";
+	choices_list += ", ";
     }
   gold_fatal(_("%s: must take one of the following arguments: %s"),
-             option_name, choices_list.c_str());
+	     option_name, choices_list.c_str());
 }
 
 } // End namespace options.
@@ -340,21 +341,21 @@ General_options::parse_V(const char*, const char*, Command_line*)
 
 void
 General_options::parse_defsym(const char*, const char* arg,
-                              Command_line* cmdline)
+			      Command_line* cmdline)
 {
   cmdline->script_options().define_symbol(arg);
 }
 
 void
 General_options::parse_incremental(const char*, const char*,
-                                   Command_line*)
+				   Command_line*)
 {
   this->incremental_mode_ = INCREMENTAL_AUTO;
 }
 
 void
 General_options::parse_no_incremental(const char*, const char*,
-                                      Command_line*)
+				      Command_line*)
 {
   this->incremental_mode_ = INCREMENTAL_OFF;
 }
@@ -375,7 +376,7 @@ General_options::parse_incremental_update(const char*, const char*,
 
 void
 General_options::parse_incremental_changed(const char*, const char*,
-                                           Command_line*)
+					   Command_line*)
 {
   this->implicit_incremental_ = true;
   this->incremental_disposition_ = INCREMENTAL_CHANGED;
@@ -383,7 +384,7 @@ General_options::parse_incremental_changed(const char*, const char*,
 
 void
 General_options::parse_incremental_unchanged(const char*, const char*,
-                                             Command_line*)
+					     Command_line*)
 {
   this->implicit_incremental_ = true;
   this->incremental_disposition_ = INCREMENTAL_UNCHANGED;
@@ -391,7 +392,7 @@ General_options::parse_incremental_unchanged(const char*, const char*,
 
 void
 General_options::parse_incremental_unknown(const char*, const char*,
-                                           Command_line*)
+					   Command_line*)
 {
   this->implicit_incremental_ = true;
   this->incremental_disposition_ = INCREMENTAL_CHECK;
@@ -407,7 +408,7 @@ General_options::parse_incremental_startup_unchanged(const char*, const char*,
 
 void
 General_options::parse_library(const char*, const char* arg,
-                               Command_line* cmdline)
+			       Command_line* cmdline)
 {
   Input_file_argument::Input_file_type type;
   const char* name;
@@ -428,7 +429,7 @@ General_options::parse_library(const char*, const char* arg,
 #ifdef ENABLE_PLUGINS
 void
 General_options::parse_plugin(const char*, const char* arg,
-                              Command_line*)
+			      Command_line*)
 {
   this->add_plugin(arg);
 }
@@ -437,7 +438,7 @@ General_options::parse_plugin(const char*, const char* arg,
 
 void
 General_options::parse_plugin_opt(const char*, const char* arg,
-                                  Command_line*)
+				  Command_line*)
 {
   this->add_plugin_option(arg);
 }
@@ -445,7 +446,7 @@ General_options::parse_plugin_opt(const char*, const char* arg,
 
 void
 General_options::parse_R(const char* option, const char* arg,
-                         Command_line* cmdline)
+			 Command_line* cmdline)
 {
   struct stat s;
   if (::stat(arg, &s) != 0 || S_ISDIR(s.st_mode))
@@ -456,7 +457,7 @@ General_options::parse_R(const char* option, const char* arg,
 
 void
 General_options::parse_just_symbols(const char*, const char* arg,
-                                    Command_line* cmdline)
+				    Command_line* cmdline)
 {
   Input_file_argument file(arg, Input_file_argument::INPUT_FILE_TYPE_FILE,
 			   "", true, *this);
@@ -528,7 +529,7 @@ General_options::parse_static(const char*, const char*, Command_line*)
 
 void
 General_options::parse_script(const char*, const char* arg,
-                              Command_line* cmdline)
+			      Command_line* cmdline)
 {
   if (!read_commandline_script(arg, cmdline))
     gold::gold_fatal(_("unable to parse script file %s"), arg);
@@ -536,7 +537,7 @@ General_options::parse_script(const char*, const char* arg,
 
 void
 General_options::parse_version_script(const char*, const char* arg,
-                                      Command_line* cmdline)
+				      Command_line* cmdline)
 {
   if (!read_version_script(arg, cmdline))
     gold::gold_fatal(_("unable to parse version script file %s"), arg);
@@ -544,7 +545,7 @@ General_options::parse_version_script(const char*, const char* arg,
 
 void
 General_options::parse_dynamic_list(const char*, const char* arg,
-                                    Command_line* cmdline)
+				    Command_line* cmdline)
 {
   if (!read_dynamic_list(arg, cmdline, &this->dynamic_list_))
     gold::gold_fatal(_("unable to parse dynamic-list script file %s"), arg);
@@ -552,28 +553,28 @@ General_options::parse_dynamic_list(const char*, const char* arg,
 
 void
 General_options::parse_start_group(const char*, const char*,
-                                   Command_line* cmdline)
+				   Command_line* cmdline)
 {
   cmdline->inputs().start_group();
 }
 
 void
 General_options::parse_end_group(const char*, const char*,
-                                 Command_line* cmdline)
+				 Command_line* cmdline)
 {
   cmdline->inputs().end_group();
 }
 
 void
 General_options::parse_start_lib(const char*, const char*,
-                                 Command_line* cmdline)
+				 Command_line* cmdline)
 {
   cmdline->inputs().start_lib(cmdline->position_dependent_options());
 }
 
 void
 General_options::parse_end_lib(const char*, const char*,
-                               Command_line* cmdline)
+			       Command_line* cmdline)
 {
   cmdline->inputs().end_lib();
 }
@@ -585,7 +586,7 @@ General_options::parse_end_lib(const char*, const char*,
 
 void
 General_options::parse_exclude_libs(const char*, const char* arg,
-                                    Command_line*)
+				    Command_line*)
 {
   const char* p = arg;
 
@@ -659,15 +660,15 @@ General_options::string_to_object_format(const char* arg)
   else
     {
       gold::gold_error(_("format '%s' not supported; treating as elf "
-                         "(supported formats: elf, binary)"),
-                       arg);
+			 "(supported formats: elf, binary)"),
+		       arg);
       return gold::General_options::OBJECT_FORMAT_ELF;
     }
 }
 
 void
 General_options::parse_fix_v4bx(const char*, const char*,
-                                Command_line*)
+				Command_line*)
 {
   this->fix_v4bx_ = FIX_V4BX_REPLACE;
 }
@@ -700,8 +701,8 @@ void
 usage()
 {
   fprintf(stderr,
-          _("%s: use the --help option for usage information\n"),
-          gold::program_name);
+	  _("%s: use the --help option for usage information\n"),
+	  gold::program_name);
   ::exit(EXIT_FAILURE);
 }
 
@@ -709,8 +710,8 @@ void
 usage(const char* msg, const char* opt)
 {
   fprintf(stderr,
-          _("%s: %s: %s\n"),
-          gold::program_name, opt, msg);
+	  _("%s: %s: %s\n"),
+	  gold::program_name, opt, msg);
   usage();
 }
 
@@ -721,12 +722,12 @@ static char*
 get_relative_sysroot(const char* from)
 {
   char* path = make_relative_prefix(gold::program_name, from,
-                                    TARGET_SYSTEM_ROOT);
+				    TARGET_SYSTEM_ROOT);
   if (path != NULL)
     {
       struct stat s;
       if (::stat(path, &s) == 0 && S_ISDIR(s.st_mode))
-        return path;
+	return path;
       free(path);
     }
 
@@ -749,9 +750,9 @@ get_default_sysroot()
     {
       char* path = get_relative_sysroot(BINDIR);
       if (path == NULL)
-        path = get_relative_sysroot(TOOLBINDIR);
+	path = get_relative_sysroot(TOOLBINDIR);
       if (path != NULL)
-        return path;
+	return path;
     }
 
   return sysroot;
@@ -768,14 +769,14 @@ get_default_sysroot()
 // NOTE: it is safe for argv and arg to point to the same place.
 gold::options::One_option*
 parse_long_option(int argc, const char** argv, bool equals_only,
-                  const char** arg, int* i)
+		  const char** arg, int* i)
 {
   const char* const this_argv = argv[*i];
 
   const char* equals = strchr(this_argv, '=');
   const char* option_start = this_argv + strspn(this_argv, "-");
   std::string option(option_start,
-                     equals ? equals - option_start : strlen(option_start));
+		     equals ? equals - option_start : strlen(option_start));
 
   gold::options::Option_map::iterator it
       = gold::options::long_options->find(option);
@@ -788,21 +789,21 @@ parse_long_option(int argc, const char** argv, bool equals_only,
   if (this_argv[0] != '-')  // no dashes at all: had better be "-z <longopt>"
     {
       if (retval->dashes != gold::options::DASH_Z)
-        return NULL;
+	return NULL;
     }
   else if (this_argv[1] != '-')   // one dash
     {
       if (retval->dashes != gold::options::ONE_DASH
-          && retval->dashes != gold::options::EXACTLY_ONE_DASH
-          && retval->dashes != gold::options::TWO_DASHES)
-        return NULL;
+	  && retval->dashes != gold::options::EXACTLY_ONE_DASH
+	  && retval->dashes != gold::options::TWO_DASHES)
+	return NULL;
     }
   else                            // two dashes (or more!)
     {
       if (retval->dashes != gold::options::TWO_DASHES
-          && retval->dashes != gold::options::EXACTLY_TWO_DASHES
-          && retval->dashes != gold::options::ONE_DASH)
-        return NULL;
+	  && retval->dashes != gold::options::EXACTLY_TWO_DASHES
+	  && retval->dashes != gold::options::ONE_DASH)
+	return NULL;
     }
 
   // Now that we know the option is good (or else bad in a way that
@@ -813,20 +814,20 @@ parse_long_option(int argc, const char** argv, bool equals_only,
   if (!retval->takes_argument())
     {
       if (equals)
-        usage(_("unexpected argument"), this_argv);
+	usage(_("unexpected argument"), this_argv);
       else
-        *arg = NULL;
+	*arg = NULL;
     }
   else
     {
       if (equals)
-        *arg = equals + 1;
+	*arg = equals + 1;
       else if (retval->takes_optional_argument())
 	*arg = retval->default_value;
       else if (*i < argc && !equals_only)
-        *arg = argv[(*i)++];
+	*arg = argv[(*i)++];
       else
-        usage(_("missing argument"), this_argv);
+	usage(_("missing argument"), this_argv);
     }
 
   return retval;
@@ -844,7 +845,7 @@ parse_long_option(int argc, const char** argv, bool equals_only,
 // another short option in the same word.
 gold::options::One_option*
 parse_short_option(int argc, const char** argv, int pos_in_argv_i,
-                   const char** arg, int* i)
+		   const char** arg, int* i)
 {
   const char* const this_argv = argv[*i];
 
@@ -853,7 +854,7 @@ parse_short_option(int argc, const char** argv, int pos_in_argv_i,
 
   // We handle -z as a special case.
   static gold::options::One_option dash_z("", gold::options::DASH_Z,
-                                          'z', "", NULL, "Z-OPTION", false,
+					  'z', "", NULL, "Z-OPTION", false,
 					  NULL);
   gold::options::One_option* retval = NULL;
   if (this_argv[pos_in_argv_i] == 'z')
@@ -862,7 +863,7 @@ parse_short_option(int argc, const char** argv, int pos_in_argv_i,
     {
       const int char_as_int = static_cast<int>(this_argv[pos_in_argv_i]);
       if (char_as_int > 0 && char_as_int < 128)
-        retval = gold::options::short_options[char_as_int];
+	retval = gold::options::short_options[char_as_int];
     }
 
   if (retval == NULL)
@@ -874,20 +875,20 @@ parse_short_option(int argc, const char** argv, int pos_in_argv_i,
       *arg = NULL;
       // We only advance past this argument if it's the only one in argv.
       if (this_argv[pos_in_argv_i + 1] == '\0')
-        ++(*i);
+	++(*i);
     }
   else
     {
       // If we take an argument, we'll eat up this entire argv entry.
       ++(*i);
       if (this_argv[pos_in_argv_i + 1] != '\0')
-        *arg = this_argv + pos_in_argv_i + 1;
+	*arg = this_argv + pos_in_argv_i + 1;
       else if (retval->takes_optional_argument())
 	*arg = retval->default_value;
       else if (*i < argc)
-        *arg = argv[(*i)++];
+	*arg = argv[(*i)++];
       else
-        usage(_("missing argument"), this_argv);
+	usage(_("missing argument"), this_argv);
     }
 
   // If we're a -z option, we need to parse our argument as a
@@ -898,7 +899,7 @@ parse_short_option(int argc, const char** argv, int pos_in_argv_i,
       const char* dash_z_arg = *arg;
       retval = parse_long_option(1, arg, true, arg, &dummy_i);
       if (retval == NULL)
-        usage(_("unknown -z option"), dash_z_arg);
+	usage(_("unknown -z option"), dash_z_arg);
     }
 
   return retval;
@@ -952,7 +953,7 @@ General_options::add_sysroot()
     {
       this->set_sysroot(get_default_sysroot());
       if (this->sysroot() == NULL || this->sysroot()[0] == '\0')
-        return;
+	return;
     }
 
   char* canonical_sysroot = lrealpath(this->sysroot());
@@ -1117,8 +1118,8 @@ General_options::finalize()
   if (this->thread_count() > 0 || this->thread_count_initial() > 0
       || this->thread_count_middle() > 0 || this->thread_count_final() > 0)
     gold_warning(_("ignoring --thread-count: "
-                   "%s was compiled without thread support"),
-                 program_name);
+		   "%s was compiled without thread support"),
+		 program_name);
 #endif
 
   std::string libpath;
@@ -1170,17 +1171,17 @@ General_options::finalize()
       std::ifstream in;
       in.open(this->retain_symbols_file());
       if (!in)
-        gold_fatal(_("unable to open -retain-symbols-file file %s: %s"),
-                   this->retain_symbols_file(), strerror(errno));
+	gold_fatal(_("unable to open -retain-symbols-file file %s: %s"),
+		   this->retain_symbols_file(), strerror(errno));
       std::string line;
       std::getline(in, line);   // this chops off the trailing \n, if any
       while (in)
-        {
-          if (!line.empty() && line[line.length() - 1] == '\r')   // Windows
-            line.resize(line.length() - 1);
-          this->symbols_to_retain_.insert(line);
-          std::getline(in, line);
-        }
+	{
+	  if (!line.empty() && line[line.length() - 1] == '\r')   // Windows
+	    line.resize(line.length() - 1);
+	  this->symbols_to_retain_.insert(line);
+	  std::getline(in, line);
+	}
     }
 
   // -Bgroup implies --unresolved-symbols=report-all.
@@ -1239,7 +1240,7 @@ General_options::finalize()
 
   if (this->implicit_incremental_ && this->incremental_mode_ == INCREMENTAL_OFF)
     gold_fatal(_("Options --incremental-changed, --incremental-unchanged, "
-                 "--incremental-unknown require the use of --incremental"));
+		 "--incremental-unknown require the use of --incremental"));
 
   // Check for options that are not compatible with incremental linking.
   // Where an option can be disabled without seriously changing the semantics
@@ -1272,6 +1273,10 @@ General_options::finalize()
 	}
     }
 
+  // --rosegment-gap implies --rosegment.
+  if (this->user_set_rosegment_gap())
+    this->set_rosegment(true);
+
   // FIXME: we can/should be doing a lot more sanity checking here.
 }
 
@@ -1282,14 +1287,14 @@ General_options::finalize()
 
 void
 Search_directory::add_sysroot(const char* sysroot,
-                              const char* canonical_sysroot)
+			      const char* canonical_sysroot)
 {
   gold_assert(*sysroot != '\0');
   if (this->put_in_sysroot_)
     {
       if (!IS_DIR_SEPARATOR(this->name_[0])
-          && !IS_DIR_SEPARATOR(sysroot[strlen(sysroot) - 1]))
-        this->name_ = '/' + this->name_;
+	  && !IS_DIR_SEPARATOR(sysroot[strlen(sysroot) - 1]))
+	this->name_ = '/' + this->name_;
       this->name_ = sysroot + this->name_;
       this->is_in_sysroot_ = true;
     }
@@ -1302,12 +1307,12 @@ Search_directory::add_sysroot(const char* sysroot,
       int canonical_name_len = strlen(canonical_name);
       int canonical_sysroot_len = strlen(canonical_sysroot);
       if (canonical_name_len > canonical_sysroot_len
-          && IS_DIR_SEPARATOR(canonical_name[canonical_sysroot_len]))
-        {
-          canonical_name[canonical_sysroot_len] = '\0';
-          if (FILENAME_CMP(canonical_name, canonical_sysroot) == 0)
-            this->is_in_sysroot_ = true;
-        }
+	  && IS_DIR_SEPARATOR(canonical_name[canonical_sysroot_len]))
+	{
+	  canonical_name[canonical_sysroot_len] = '\0';
+	  if (FILENAME_CMP(canonical_name, canonical_sysroot) == 0)
+	    this->is_in_sysroot_ = true;
+	}
       free(canonical_name);
     }
 }
@@ -1406,7 +1411,7 @@ Command_line::Pre_options::Pre_options()
 
 int
 Command_line::process_one_option(int argc, const char** argv, int i,
-                                 bool* no_more_options)
+				 bool* no_more_options)
 {
   gold_assert(argv[i][0] == '-' && !(*no_more_options));
 
@@ -1437,7 +1442,7 @@ Command_line::process_one_option(int argc, const char** argv, int i,
     {
       option = parse_short_option(argc, argv, pos_in_argv_i, &arg, &new_i);
       if (!option)
-        break;
+	break;
       option->reader->parse_to_value(argv[i], arg, this, &this->options_);
       ++pos_in_argv_i;
     }
@@ -1459,15 +1464,15 @@ Command_line::process(int argc, const char** argv)
     {
       this->position_options_.copy_from_options(this->options());
       if (no_more_options || argv[i][0] != '-')
-        {
+	{
 	  Input_file_argument file(argv[i],
 				   Input_file_argument::INPUT_FILE_TYPE_FILE,
 				   "", false, this->position_options_);
-          this->inputs_.add_file(file);
-          ++i;
-        }
+	  this->inputs_.add_file(file);
+	  ++i;
+	}
       else
-        i = process_one_option(argc, argv, i, &no_more_options);
+	i = process_one_option(argc, argv, i, &no_more_options);
     }
 
   if (this->inputs_.in_group())
diff --git a/gold/options.h b/gold/options.h
index 50762a5..8aa9599 100644
--- a/gold/options.h
+++ b/gold/options.h
@@ -1,6 +1,7 @@
 // options.h -- handle command line options for gold  -*- C++ -*-
 
-// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
+// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2013
+// Free Software Foundation, Inc.
 // Written by Ian Lance Taylor <iant@google.com>.
 
 // This file is part of gold.
@@ -120,7 +121,7 @@ parse_set(const char* option_name, const char* arg, String_set* retval);
 
 extern void
 parse_choices(const char* option_name, const char* arg, const char** retval,
-              const char* choices[], int num_choices);
+	      const char* choices[], int num_choices);
 
 struct Struct_var;
 
@@ -168,7 +169,7 @@ struct One_option
   Struct_var* reader;
 
   One_option(const char* ln, Dashes d, char sn, const char* dv,
-             const char* hs, const char* ha, bool oa, Struct_var* r)
+	     const char* hs, const char* ha, bool oa, Struct_var* r)
     : longname(ln), dashes(d), shortname(sn), default_value(dv ? dv : ""),
       helpstring(hs), helparg(ha), optional_arg(oa), reader(r)
   {
@@ -219,7 +220,7 @@ struct Struct_var
   // OPTIONS: the global General_options object.  Used by DEFINE_special.
   virtual void
   parse_to_value(const char* option, const char* arg,
-                 Command_line* cmdline, General_options* options) = 0;
+		 Command_line* cmdline, General_options* options) = 0;
   virtual
   ~Struct_var()  // To make gcc happy.
   { }
@@ -230,16 +231,16 @@ struct Struct_special : public Struct_var
 {
   // If you change this, change the parse-fn in DEFINE_special as well.
   typedef void (General_options::*Parse_function)(const char*, const char*,
-                                                  Command_line*);
+						  Command_line*);
   Struct_special(const char* varname, Dashes dashes, char shortname,
-                 Parse_function parse_function,
-                 const char* helpstring, const char* helparg)
+		 Parse_function parse_function,
+		 const char* helpstring, const char* helparg)
     : option(varname, dashes, shortname, "", helpstring, helparg, false, this),
       parse(parse_function)
   { }
 
   void parse_to_value(const char* option, const char* arg,
-                      Command_line* cmdline, General_options* options)
+		      Command_line* cmdline, General_options* options)
   { (options->*(this->parse))(option, arg, cmdline); }
 
   One_option option;
@@ -261,17 +262,17 @@ struct Struct_special : public Struct_var
 // avoid unintended macro substitution of "assert()", we need to enclose
 // varname__ with parenthese.
 #define DEFINE_var(varname__, dashes__, shortname__, default_value__,        \
-                   default_value_as_string__, helpstring__, helparg__,       \
-                   optional_arg__, type__, param_type__, parse_fn__)	     \
+		   default_value_as_string__, helpstring__, helparg__,       \
+		   optional_arg__, type__, param_type__, parse_fn__)	     \
  public:                                                                     \
   param_type__                                                               \
   (varname__)() const                                                        \
   { return this->varname__##_.value; }                                       \
-                                                                             \
+									     \
   bool                                                                       \
   user_set_##varname__() const                                               \
   { return this->varname__##_.user_set_via_option; }                         \
-                                                                             \
+									     \
   void									     \
   set_user_set_##varname__()						     \
   { this->varname__##_.user_set_via_option = true; }			     \
@@ -281,18 +282,18 @@ struct Struct_special : public Struct_var
   {                                                                          \
     Struct_##varname__()                                                     \
       : option(#varname__, dashes__, shortname__, default_value_as_string__, \
-               helpstring__, helparg__, optional_arg__, this),		     \
-        user_set_via_option(false), value(default_value__)                   \
+	       helpstring__, helparg__, optional_arg__, this),		     \
+	user_set_via_option(false), value(default_value__)                   \
     { }                                                                      \
-                                                                             \
+									     \
     void                                                                     \
     parse_to_value(const char* option_name, const char* arg,                 \
-                   Command_line*, General_options*)                          \
+		   Command_line*, General_options*)                          \
     {                                                                        \
       parse_fn__(option_name, arg, &this->value);                            \
       this->user_set_via_option = true;                                      \
     }                                                                        \
-                                                                             \
+									     \
     options::One_option option;                                              \
     bool user_set_via_option;                                                \
     type__ value;                                                            \
@@ -308,71 +309,71 @@ struct Struct_special : public Struct_var
 // VARNAME, we also create an option called no-VARNAME (or, for a -z
 // option, noVARNAME).
 #define DEFINE_bool(varname__, dashes__, shortname__, default_value__,   \
-                    helpstring__, no_helpstring__)                       \
+		    helpstring__, no_helpstring__)                       \
   DEFINE_var(varname__, dashes__, shortname__, default_value__,          \
-             default_value__ ? "true" : "false", helpstring__, NULL,     \
-             false, bool, bool, options::parse_bool)			 \
+	     default_value__ ? "true" : "false", helpstring__, NULL,     \
+	     false, bool, bool, options::parse_bool)			 \
   struct Struct_no_##varname__ : public options::Struct_var              \
   {                                                                      \
     Struct_no_##varname__() : option((dashes__ == options::DASH_Z	 \
 				      ? "no" #varname__			 \
 				      : "no-" #varname__),		 \
 				     dashes__, '\0',			 \
-                                     default_value__ ? "false" : "true", \
-                                     no_helpstring__, NULL, false, this) \
+				     default_value__ ? "false" : "true", \
+				     no_helpstring__, NULL, false, this) \
     { }                                                                  \
-                                                                         \
+									 \
     void                                                                 \
     parse_to_value(const char*, const char*,                             \
-                   Command_line*, General_options* options)              \
+		   Command_line*, General_options* options)              \
     {                                                                    \
       options->set_##varname__(false);                                   \
       options->set_user_set_##varname__();                               \
     }                                                                    \
-                                                                         \
+									 \
     options::One_option option;                                          \
   };                                                                     \
   Struct_no_##varname__ no_##varname__##_initializer_
 
 #define DEFINE_enable(varname__, dashes__, shortname__, default_value__, \
-                      helpstring__, no_helpstring__)                     \
+		      helpstring__, no_helpstring__)                     \
   DEFINE_var(enable_##varname__, dashes__, shortname__, default_value__, \
-             default_value__ ? "true" : "false", helpstring__, NULL,     \
-             false, bool, bool, options::parse_bool)			 \
+	     default_value__ ? "true" : "false", helpstring__, NULL,     \
+	     false, bool, bool, options::parse_bool)			 \
   struct Struct_disable_##varname__ : public options::Struct_var         \
   {                                                                      \
     Struct_disable_##varname__() : option("disable-" #varname__,         \
-                                     dashes__, '\0',                     \
-                                     default_value__ ? "false" : "true", \
-                                     no_helpstring__, NULL, false, this) \
+				     dashes__, '\0',                     \
+				     default_value__ ? "false" : "true", \
+				     no_helpstring__, NULL, false, this) \
     { }                                                                  \
-                                                                         \
+									 \
     void                                                                 \
     parse_to_value(const char*, const char*,                             \
-                   Command_line*, General_options* options)              \
+		   Command_line*, General_options* options)              \
     { options->set_enable_##varname__(false); }                          \
-                                                                         \
+									 \
     options::One_option option;                                          \
   };                                                                     \
   Struct_disable_##varname__ disable_##varname__##_initializer_
 
 #define DEFINE_int(varname__, dashes__, shortname__, default_value__,   \
-                   helpstring__, helparg__)                             \
+		   helpstring__, helparg__)                             \
   DEFINE_var(varname__, dashes__, shortname__, default_value__,         \
-             #default_value__, helpstring__, helparg__, false,		\
-             int, int, options::parse_int)
+	     #default_value__, helpstring__, helparg__, false,		\
+	     int, int, options::parse_int)
 
 #define DEFINE_uint(varname__, dashes__, shortname__, default_value__,  \
-                   helpstring__, helparg__)                             \
+		   helpstring__, helparg__)                             \
   DEFINE_var(varname__, dashes__, shortname__, default_value__,         \
-             #default_value__, helpstring__, helparg__, false,		\
-             int, int, options::parse_uint)
+	     #default_value__, helpstring__, helparg__, false,		\
+	     int, int, options::parse_uint)
 
 #define DEFINE_uint64(varname__, dashes__, shortname__, default_value__, \
-                      helpstring__, helparg__)                           \
+		      helpstring__, helparg__)                           \
   DEFINE_var(varname__, dashes__, shortname__, default_value__,          \
-             #default_value__, helpstring__, helparg__, false,		 \
-             uint64_t, uint64_t, options::parse_uint64)
+	     #default_value__, helpstring__, helparg__, false,		 \
+	     uint64_t, uint64_t, options::parse_uint64)
 
 #define DEFINE_double(varname__, dashes__, shortname__, default_value__, \
 		      helpstring__, helparg__)				 \
@@ -387,19 +388,19 @@ struct Struct_special : public Struct_var
 	     double, double, options::parse_percent)
 
 #define DEFINE_string(varname__, dashes__, shortname__, default_value__, \
-                      helpstring__, helparg__)                           \
+		      helpstring__, helparg__)                           \
   DEFINE_var(varname__, dashes__, shortname__, default_value__,          \
-             default_value__, helpstring__, helparg__, false,		 \
-             const char*, const char*, options::parse_string)
+	     default_value__, helpstring__, helparg__, false,		 \
+	     const char*, const char*, options::parse_string)
 
 // This is like DEFINE_string, but we convert each occurrence to a
 // Search_directory and store it in a vector.  Thus we also have the
 // add_to_VARNAME() method, to append to the vector.
 #define DEFINE_dirlist(varname__, dashes__, shortname__,                  \
-                           helpstring__, helparg__)                       \
+			   helpstring__, helparg__)                       \
   DEFINE_var(varname__, dashes__, shortname__, ,                          \
-             "", helpstring__, helparg__, false, options::Dir_list,	  \
-             const options::Dir_list&, options::parse_dirlist)            \
+	     "", helpstring__, helparg__, false, options::Dir_list,	  \
+	     const options::Dir_list&, options::parse_dirlist)            \
   void                                                                    \
   add_to_##varname__(const char* new_value)                               \
   { options::parse_dirlist(NULL, new_value, &this->varname__##_.value); } \
@@ -409,10 +410,10 @@ struct Struct_special : public Struct_var
 
 // This is like DEFINE_string, but we store a set of strings.
 #define DEFINE_set(varname__, dashes__, shortname__,                      \
-                   helpstring__, helparg__)                               \
+		   helpstring__, helparg__)                               \
   DEFINE_var(varname__, dashes__, shortname__, ,                          \
-             "", helpstring__, helparg__, false, options::String_set,     \
-             const options::String_set&, options::parse_set)              \
+	     "", helpstring__, helparg__, false, options::String_set,     \
+	     const options::String_set&, options::parse_set)              \
  public:                                                                  \
   bool                                                                    \
   any_##varname__() const                                                 \
@@ -422,8 +423,8 @@ struct Struct_special : public Struct_var
   is_##varname__(const char* symbol) const                                \
   {                                                                       \
     return (!this->varname__##_.value.empty()                             \
-            && (this->varname__##_.value.find(std::string(symbol))        \
-                != this->varname__##_.value.end()));                      \
+	    && (this->varname__##_.value.find(std::string(symbol))        \
+		!= this->varname__##_.value.end()));                      \
   }									  \
 									  \
   options::String_set::const_iterator					  \
@@ -438,17 +439,17 @@ struct Struct_special : public Struct_var
 // After helparg__ should come an initializer list, like
 //   {"foo", "bar", "baz"}
 #define DEFINE_enum(varname__, dashes__, shortname__, default_value__,   \
-                    helpstring__, helparg__, ...)                        \
+		    helpstring__, helparg__, ...)                        \
   DEFINE_var(varname__, dashes__, shortname__, default_value__,          \
-             default_value__, helpstring__, helparg__, false,		 \
-             const char*, const char*, parse_choices_##varname__)        \
+	     default_value__, helpstring__, helparg__, false,		 \
+	     const char*, const char*, parse_choices_##varname__)        \
  private:                                                                \
   static void parse_choices_##varname__(const char* option_name,         \
-                                        const char* arg,                 \
-                                        const char** retval) {           \
+					const char* arg,                 \
+					const char** retval) {           \
     const char* choices[] = __VA_ARGS__;                                 \
     options::parse_choices(option_name, arg, retval,                     \
-                           choices, sizeof(choices) / sizeof(*choices)); \
+			   choices, sizeof(choices) / sizeof(*choices)); \
   }
 
 // This is like DEFINE_bool, but VARNAME is the name of a different
@@ -498,22 +499,48 @@ struct Struct_special : public Struct_var
   };									\
   Struct_no_##option__ no_##option__##_initializer_
 
+// This is like DEFINE_uint64, but VARNAME is the name of a different
+// option.  This option becomes an alias for that one.
+#define DEFINE_uint64_alias(option__, varname__, dashes__, shortname__,	\
+			    helpstring__, helparg__)			\
+ private:								\
+  struct Struct_##option__ : public options::Struct_var			\
+  {									\
+    Struct_##option__()							\
+      : option(#option__, dashes__, shortname__, "", helpstring__,	\
+	       helparg__, false, this)					\
+    { }									\
+									\
+    void								\
+    parse_to_value(const char* option_name, const char* arg,		\
+		   Command_line*, General_options* options)		\
+    {									\
+      uint64_t value;							\
+      options::parse_uint64(option_name, arg, &value);			\
+      options->set_##varname__(value);					\
+      options->set_user_set_##varname__();				\
+    }									\
+									\
+    options::One_option option;						\
+  };									\
+  Struct_##option__ option__##_;
+
 // This is used for non-standard flags.  It defines no functions; it
 // just calls General_options::parse_VARNAME whenever the flag is
 // seen.  We declare parse_VARNAME as a static member of
 // General_options; you are responsible for defining it there.
 // helparg__ should be NULL iff this special-option is a boolean.
 #define DEFINE_special(varname__, dashes__, shortname__,                \
-                       helpstring__, helparg__)                         \
+		       helpstring__, helparg__)                         \
  private:                                                               \
   void parse_##varname__(const char* option, const char* arg,           \
-                         Command_line* inputs);                         \
+			 Command_line* inputs);                         \
   struct Struct_##varname__ : public options::Struct_special            \
   {                                                                     \
     Struct_##varname__()                                                \
       : options::Struct_special(#varname__, dashes__, shortname__,      \
-                                &General_options::parse_##varname__,    \
-                                helpstring__, helparg__)                \
+				&General_options::parse_##varname__,    \
+				helpstring__, helparg__)                \
     { }                                                                 \
   };                                                                    \
   Struct_##varname__ varname__##_initializer_
@@ -525,8 +552,8 @@ struct Struct_special : public Struct_var
 			       default_value__,				\
 			       helpstring__, helparg__)			\
   DEFINE_var(varname__, dashes__, shortname__, default_value__,		\
-             default_value__, helpstring__, helparg__, true,		\
-             const char*, const char*, options::parse_optional_string)
+	     default_value__, helpstring__, helparg__, true,		\
+	     const char*, const char*, options::parse_optional_string)
 
 // A directory to search.  For each directory we record whether it is
 // in the sysroot.  We need to know this so that, if a linker script
@@ -594,11 +621,11 @@ class General_options
   // NOTE: For every option that you add here, also consider if you
   // should add it to Position_dependent_options.
   DEFINE_special(help, options::TWO_DASHES, '\0',
-                 N_("Report usage information"), NULL);
+		 N_("Report usage information"), NULL);
   DEFINE_special(version, options::TWO_DASHES, 'v',
-                 N_("Report version information"), NULL);
+		 N_("Report version information"), NULL);
   DEFINE_special(V, options::EXACTLY_ONE_DASH, '\0',
-                 N_("Report version and target information"), NULL);
+		 N_("Report version and target information"), NULL);
 
   // These options are sorted approximately so that for each letter in
   // the alphabet, we show the option whose shortname is that letter
@@ -615,12 +642,12 @@ class General_options
 		    N_("Do not allow multiple definitions"), false);
 
   DEFINE_bool(allow_shlib_undefined, options::TWO_DASHES, '\0', false,
-              N_("Allow unresolved references in shared libraries"),
-              N_("Do not allow unresolved references in shared libraries"));
+	      N_("Allow unresolved references in shared libraries"),
+	      N_("Do not allow unresolved references in shared libraries"));
 
   DEFINE_bool(as_needed, options::TWO_DASHES, '\0', false,
-              N_("Only set DT_NEEDED for shared libraries if used"),
-              N_("Always DT_NEEDED for shared libraries"));
+	      N_("Only set DT_NEEDED for shared libraries if used"),
+	      N_("Always DT_NEEDED for shared libraries"));
 
   DEFINE_enum(assert, options::ONE_DASH, '\0', NULL,
 	      N_("Ignored"), N_("[ignored]"),
@@ -631,10 +658,10 @@ class General_options
   // accept any string.  We'll fail later (when the string is parsed),
   // if the target isn't actually supported.
   DEFINE_string(format, options::TWO_DASHES, 'b', "elf",
-                N_("Set input format"), ("[elf,binary]"));
+		N_("Set input format"), ("[elf,binary]"));
 
   DEFINE_bool(Bdynamic, options::ONE_DASH, '\0', true,
-              N_("-l searches for shared libraries"), NULL);
+	      N_("-l searches for shared libraries"), NULL);
   DEFINE_bool_alias(Bstatic, Bdynamic, options::ONE_DASH, '\0',
 		    N_("-l does not search for shared libraries"), NULL,
 		    true);
@@ -647,7 +674,7 @@ class General_options
 	      N_("Use group name lookup rules for shared library"), NULL);
 
   DEFINE_bool(Bsymbolic, options::ONE_DASH, '\0', false,
-              N_("Bind defined symbols locally"), NULL);
+	      N_("Bind defined symbols locally"), NULL);
 
   DEFINE_bool(Bsymbolic_functions, options::ONE_DASH, '\0', false,
 	      N_("Bind defined function symbols locally"), NULL);
@@ -662,14 +689,14 @@ class General_options
 
 #ifdef HAVE_ZLIB_H
   DEFINE_enum(compress_debug_sections, options::TWO_DASHES, '\0', "none",
-              N_("Compress .debug_* sections in the output file"),
-              ("[none,zlib]"),
-              {"none", "zlib"});
+	      N_("Compress .debug_* sections in the output file"),
+	      ("[none,zlib]"),
+	      {"none", "zlib"});
 #else
   DEFINE_enum(compress_debug_sections, options::TWO_DASHES, '\0', "none",
-              N_("Compress .debug_* sections in the output file"),
-              N_("[none]"),
-              {"none"});
+	      N_("Compress .debug_* sections in the output file"),
+	      N_("[none]"),
+	      {"none"});
 #endif
 
   DEFINE_bool(copy_dt_needed_entries, options::TWO_DASHES, '\0', false,
@@ -685,19 +712,19 @@ class General_options
 	      N_("Handle constructors as directed by compiler"));
 
   DEFINE_bool(define_common, options::TWO_DASHES, 'd', false,
-              N_("Define common symbols"),
-              N_("Do not define common symbols"));
+	      N_("Define common symbols"),
+	      N_("Do not define common symbols"));
   DEFINE_bool(dc, options::ONE_DASH, '\0', false,
-              N_("Alias for -d"), NULL);
+	      N_("Alias for -d"), NULL);
   DEFINE_bool(dp, options::ONE_DASH, '\0', false,
-              N_("Alias for -d"), NULL);
+	      N_("Alias for -d"), NULL);
 
   DEFINE_string(debug, options::TWO_DASHES, '\0', "",
-                N_("Turn on debugging"),
-                N_("[all,files,script,task][,...]"));
+		N_("Turn on debugging"),
+		N_("[all,files,script,task][,...]"));
 
   DEFINE_special(defsym, options::TWO_DASHES, '\0',
-                 N_("Define a symbol"), N_("SYMBOL=EXPRESSION"));
+		 N_("Define a symbol"), N_("SYMBOL=EXPRESSION"));
 
   DEFINE_optional_string(demangle, options::TWO_DASHES, '\0', NULL,
 			 N_("Demangle C++ symbols in log messages"),
@@ -708,35 +735,35 @@ class General_options
 	      NULL);
 
   DEFINE_bool(detect_odr_violations, options::TWO_DASHES, '\0', false,
-              N_("Look for violations of the C++ One Definition Rule"),
+	      N_("Look for violations of the C++ One Definition Rule"),
 	      N_("Do not look for violations of the C++ One Definition Rule"));
 
   DEFINE_bool(discard_all, options::TWO_DASHES, 'x', false,
 	      N_("Delete all local symbols"), NULL);
   DEFINE_bool(discard_locals, options::TWO_DASHES, 'X', false,
-              N_("Delete all temporary local symbols"), NULL);
+	      N_("Delete all temporary local symbols"), NULL);
 
   DEFINE_bool(dynamic_list_data, options::TWO_DASHES, '\0', false,
-              N_("Add data symbols to dynamic symbols"), NULL);
+	      N_("Add data symbols to dynamic symbols"), NULL);
 
   DEFINE_bool(dynamic_list_cpp_new, options::TWO_DASHES, '\0', false,
-              N_("Add C++ operator new/delete to dynamic symbols"), NULL);
+	      N_("Add C++ operator new/delete to dynamic symbols"), NULL);
 
   DEFINE_bool(dynamic_list_cpp_typeinfo, options::TWO_DASHES, '\0', false,
-              N_("Add C++ typeinfo to dynamic symbols"), NULL);
+	      N_("Add C++ typeinfo to dynamic symbols"), NULL);
 
   DEFINE_special(dynamic_list, options::TWO_DASHES, '\0',
-                 N_("Read a list of dynamic symbols"), N_("FILE"));
+		 N_("Read a list of dynamic symbols"), N_("FILE"));
 
   DEFINE_string(entry, options::TWO_DASHES, 'e', NULL,
-                N_("Set program start address"), N_("ADDRESS"));
+		N_("Set program start address"), N_("ADDRESS"));
 
   DEFINE_special(exclude_libs, options::TWO_DASHES, '\0',
 		 N_("Exclude libraries from automatic export"),
 		 N_(("lib,lib ...")));
 
   DEFINE_bool(export_dynamic, options::TWO_DASHES, 'E', false,
-              N_("Export all dynamic symbols"),
+	      N_("Export all dynamic symbols"),
 	      N_("Do not export all dynamic symbols (default)"));
 
   DEFINE_set(export_dynamic_symbol, options::TWO_DASHES, '\0',
@@ -749,7 +776,7 @@ class General_options
 		 N_("Link little-endian objects."), NULL);
 
   DEFINE_bool(eh_frame_hdr, options::TWO_DASHES, '\0', false,
-              N_("Create exception frame header"), NULL);
+	      N_("Create exception frame header"), NULL);
 
   DEFINE_bool(enum_size_warning, options::TWO_DASHES, '\0', true, NULL,
 	      N_("(ARM only) Do not warn about objects with incompatible "
@@ -768,7 +795,7 @@ class General_options
 	      N_("Do not treat warnings as errors"));
 
   DEFINE_string(fini, options::ONE_DASH, '\0', "_fini",
-                N_("Call SYMBOL at unload-time"), N_("SYMBOL"));
+		N_("Call SYMBOL at unload-time"), N_("SYMBOL"));
 
   DEFINE_bool(fix_cortex_a8, options::TWO_DASHES, '\0', false,
 	      N_("(ARM only) Fix binaries for Cortex-A8 erratum."),
@@ -783,13 +810,13 @@ class General_options
 	      N_("(ARM only) Do not merge exidx entries in debuginfo."));
 
   DEFINE_special(fix_v4bx, options::TWO_DASHES, '\0',
-                 N_("(ARM only) Rewrite BX rn as MOV pc, rn for ARMv4"),
-                 NULL);
+		 N_("(ARM only) Rewrite BX rn as MOV pc, rn for ARMv4"),
+		 NULL);
 
   DEFINE_special(fix_v4bx_interworking, options::TWO_DASHES, '\0',
-                 N_("(ARM only) Rewrite BX rn branch to ARMv4 interworking "
-                    "veneer"),
-                 NULL);
+		 N_("(ARM only) Rewrite BX rn branch to ARMv4 interworking "
+		    "veneer"),
+		 NULL);
 
   DEFINE_bool(g, options::EXACTLY_ONE_DASH, '\0', false,
 	      N_("Ignored"), NULL);
@@ -803,7 +830,7 @@ class General_options
 	      N_("Disable STB_GNU_UNIQUE symbol binding"));
 
   DEFINE_string(soname, options::ONE_DASH, 'h', NULL,
-                N_("Set shared library name"), N_("FILENAME"));
+		N_("Set shared library name"), N_("FILENAME"));
 
   DEFINE_double(hash_bucket_empty_fraction, options::TWO_DASHES, '\0', 0.0,
 		N_("Min fraction of empty buckets in dynamic hash"),
@@ -814,7 +841,7 @@ class General_options
 	      {"sysv", "gnu", "both"});
 
   DEFINE_string(dynamic_linker, options::TWO_DASHES, 'I', NULL,
-                N_("Set dynamic linker path"), N_("PROGRAM"));
+		N_("Set dynamic linker path"), N_("PROGRAM"));
 
   DEFINE_special(incremental, options::TWO_DASHES, '\0',
 		 N_("Do an incremental link if possible; "
@@ -832,21 +859,21 @@ class General_options
 		 N_("Do an incremental link; exit if not possible"), NULL);
 
   DEFINE_string(incremental_base, options::TWO_DASHES, '\0', NULL,
-                N_("Set base file for incremental linking"
-                   " (default is output file)"),
-                N_("FILE"));
+		N_("Set base file for incremental linking"
+		   " (default is output file)"),
+		N_("FILE"));
 
   DEFINE_special(incremental_changed, options::TWO_DASHES, '\0',
-                 N_("Assume files changed"), NULL);
+		 N_("Assume files changed"), NULL);
 
   DEFINE_special(incremental_unchanged, options::TWO_DASHES, '\0',
-                 N_("Assume files didn't change"), NULL);
+		 N_("Assume files didn't change"), NULL);
 
   DEFINE_special(incremental_unknown, options::TWO_DASHES, '\0',
-                 N_("Use timestamps to check files (default)"), NULL);
+		 N_("Use timestamps to check files (default)"), NULL);
 
   DEFINE_special(incremental_startup_unchanged, options::TWO_DASHES, '\0',
-                 N_("Assume startup files unchanged "
+		 N_("Assume startup files unchanged "
 		    "(files preceding this option)"), NULL);
 
   DEFINE_percent(incremental_patch, options::TWO_DASHES, '\0', 10,
@@ -854,44 +881,48 @@ class General_options
 		 N_("PERCENT"));
 
   DEFINE_string(init, options::ONE_DASH, '\0', "_init",
-                N_("Call SYMBOL at load-time"), N_("SYMBOL"));
+		N_("Call SYMBOL at load-time"), N_("SYMBOL"));
 
   DEFINE_special(just_symbols, options::TWO_DASHES, '\0',
-                 N_("Read only symbol values from FILE"), N_("FILE"));
+		 N_("Read only symbol values from FILE"), N_("FILE"));
 
   DEFINE_bool(map_whole_files, options::TWO_DASHES, '\0',
 	      sizeof(void*) >= 8,
-              N_("Map whole files to memory (default on 64-bit hosts)"),
-              N_("Map relevant file parts to memory (default on 32-bit "
-                 "hosts)"));
+	      N_("Map whole files to memory (default on 64-bit hosts)"),
+	      N_("Map relevant file parts to memory (default on 32-bit "
+		 "hosts)"));
   DEFINE_bool(keep_files_mapped, options::TWO_DASHES, '\0', true,
-              N_("Keep files mapped across passes (default)"),
-              N_("Release mapped files after each pass"));
+	      N_("Keep files mapped across passes (default)"),
+	      N_("Release mapped files after each pass"));
 
   DEFINE_bool(ld_generated_unwind_info, options::TWO_DASHES, '\0', true,
 	      N_("Generate unwind information for PLT (default)"),
 	      N_("Do not generate unwind information for PLT"));
 
   DEFINE_special(library, options::TWO_DASHES, 'l',
-                 N_("Search for library LIBNAME"), N_("LIBNAME"));
+		 N_("Search for library LIBNAME"), N_("LIBNAME"));
 
   DEFINE_dirlist(library_path, options::TWO_DASHES, 'L',
-                 N_("Add directory to search path"), N_("DIR"));
+		 N_("Add directory to search path"), N_("DIR"));
 
   DEFINE_bool(nostdlib, options::ONE_DASH, '\0', false,
-              N_(" Only search directories specified on the command line."),
-              NULL);
+	      N_("Only search directories specified on the command line."),
+	      NULL);
 
   DEFINE_bool(rosegment, options::TWO_DASHES, '\0', false,
-              N_(" Put read-only non-executable sections in their own segment"),
-              NULL);
+	      N_("Put read-only non-executable sections in their own segment"),
+	      NULL);
+
+  DEFINE_uint64(rosegment_gap, options::TWO_DASHES, '\0', -1U,
+		N_("Set offset between executable and read-only segments"),
+		N_("OFFSET"));
 
   DEFINE_string(m, options::EXACTLY_ONE_DASH, 'm', "",
-                N_("Set GNU linker emulation; obsolete"), N_("EMULATION"));
+		N_("Set GNU linker emulation; obsolete"), N_("EMULATION"));
 
   DEFINE_bool(mmap_output_file, options::TWO_DASHES, '\0', true,
-              N_("Map the output file for writing (default)."),
-              N_("Do not map the output file for writing."));
+	      N_("Map the output file for writing (default)."),
+	      N_("Do not map the output file for writing."));
 
   DEFINE_bool(print_map, options::TWO_DASHES, 'M', false,
 	      N_("Write map file on standard output"), NULL);
@@ -916,10 +947,10 @@ class General_options
 		    NULL, false);
 
   DEFINE_string(output, options::TWO_DASHES, 'o', "a.out",
-                N_("Set output file name"), N_("FILE"));
+		N_("Set output file name"), N_("FILE"));
 
   DEFINE_uint(optimize, options::EXACTLY_ONE_DASH, 'O', 0,
-              N_("Optimize output file size"), N_("LEVEL"));
+	      N_("Optimize output file size"), N_("LEVEL"));
 
   DEFINE_string(oformat, options::EXACTLY_TWO_DASHES, '\0', "elf",
 		N_("Set output format"), N_("[binary]"));
@@ -938,18 +969,18 @@ class General_options
 
 #ifdef ENABLE_PLUGINS
   DEFINE_special(plugin, options::TWO_DASHES, '\0',
-                 N_("Load a plugin library"), N_("PLUGIN"));
+		 N_("Load a plugin library"), N_("PLUGIN"));
   DEFINE_special(plugin_opt, options::TWO_DASHES, '\0',
-                 N_("Pass an option to the plugin"), N_("OPTION"));
+		 N_("Pass an option to the plugin"), N_("OPTION"));
 #endif
 
   DEFINE_bool(posix_fallocate, options::TWO_DASHES, '\0', true,
-              N_("Use posix_fallocate to reserve space in the output file"
+	      N_("Use posix_fallocate to reserve space in the output file"
 		 " (default)."),
-              N_("Use fallocate or ftruncate to reserve space."));
+	      N_("Use fallocate or ftruncate to reserve space."));
 
   DEFINE_bool(preread_archive_symbols, options::TWO_DASHES, '\0', false,
-              N_("Preread archive symbols when multi-threaded"), NULL);
+	      N_("Preread archive symbols when multi-threaded"), NULL);
 
   DEFINE_bool(print_output_format, options::TWO_DASHES, '\0', false,
 	      N_("Print default output format"), NULL);
@@ -962,10 +993,10 @@ class General_options
 	      N_("Ignored for SVR4 compatibility"), NULL);
 
   DEFINE_bool(emit_relocs, options::TWO_DASHES, 'q', false,
-              N_("Generate relocations in output"), NULL);
+	      N_("Generate relocations in output"), NULL);
 
   DEFINE_bool(relocatable, options::EXACTLY_ONE_DASH, 'r', false,
-              N_("Generate relocatable output"), NULL);
+	      N_("Generate relocatable output"), NULL);
   DEFINE_bool_alias(i, relocatable, options::EXACTLY_ONE_DASH, '\0',
 		    N_("Synonym for -r"), NULL, false);
 
@@ -973,20 +1004,20 @@ class General_options
 	      N_("Relax branches on certain targets"), NULL);
 
   DEFINE_string(retain_symbols_file, options::TWO_DASHES, '\0', NULL,
-                N_("keep only symbols listed in this file"), N_("FILE"));
+		N_("keep only symbols listed in this file"), N_("FILE"));
 
   // -R really means -rpath, but can mean --just-symbols for
   // compatibility with GNU ld.  -rpath is always -rpath, so we list
   // it separately.
   DEFINE_special(R, options::EXACTLY_ONE_DASH, 'R',
-                 N_("Add DIR to runtime search path"), N_("DIR"));
+		 N_("Add DIR to runtime search path"), N_("DIR"));
 
   DEFINE_dirlist(rpath, options::ONE_DASH, '\0',
-                 N_("Add DIR to runtime search path"), N_("DIR"));
+		 N_("Add DIR to runtime search path"), N_("DIR"));
 
   DEFINE_dirlist(rpath_link, options::TWO_DASHES, '\0',
-                 N_("Add DIR to link time shared library search path"),
-                 N_("DIR"));
+		 N_("Add DIR to link time shared library search path"),
+		 N_("DIR"));
 
   DEFINE_string(section_ordering_file, options::TWO_DASHES, '\0', NULL,
 		N_("Layout sections in the order specified."),
@@ -1004,32 +1035,32 @@ class General_options
 	      N_("COUNT"));
 
   DEFINE_bool(strip_all, options::TWO_DASHES, 's', false,
-              N_("Strip all symbols"), NULL);
+	      N_("Strip all symbols"), NULL);
   DEFINE_bool(strip_debug, options::TWO_DASHES, 'S', false,
-              N_("Strip debugging information"), NULL);
+	      N_("Strip debugging information"), NULL);
   DEFINE_bool(strip_debug_non_line, options::TWO_DASHES, '\0', false,
-              N_("Emit only debug line number information"), NULL);
+	      N_("Emit only debug line number information"), NULL);
   DEFINE_bool(strip_debug_gdb, options::TWO_DASHES, '\0', false,
-              N_("Strip debug symbols that are unused by gdb "
-                 "(at least versions <= 7.4)"), NULL);
+	      N_("Strip debug symbols that are unused by gdb "
+		 "(at least versions <= 7.4)"), NULL);
   DEFINE_bool(strip_lto_sections, options::TWO_DASHES, '\0', true,
-              N_("Strip LTO intermediate code sections"), NULL);
+	      N_("Strip LTO intermediate code sections"), NULL);
 
   DEFINE_int(stub_group_size, options::TWO_DASHES , '\0', 1,
-             N_("(ARM only) The maximum distance from instructions in a group "
+	     N_("(ARM only) The maximum distance from instructions in a group "
 		"of sections to their stubs.  Negative values mean stubs "
 		"are always after the group. 1 means using default size.\n"),
 	     N_("SIZE"));
 
   DEFINE_bool(no_keep_memory, options::TWO_DASHES, '\0', false,
-              N_("Use less memory and more disk I/O "
-                 "(included only for compatibility with GNU ld)"), NULL);
+	      N_("Use less memory and more disk I/O "
+		 "(included only for compatibility with GNU ld)"), NULL);
 
   DEFINE_bool(shared, options::ONE_DASH, 'G', false,
-              N_("Generate shared library"), NULL);
+	      N_("Generate shared library"), NULL);
 
   DEFINE_bool(Bshareable, options::ONE_DASH, '\0', false,
-              N_("Generate shared library"), NULL);
+	      N_("Generate shared library"), NULL);
 
   DEFINE_uint(split_stack_adjust_size, options::TWO_DASHES, '\0', 0x4000,
 	      N_("Stack size when -fsplit-stack function calls non-split"),
@@ -1038,63 +1069,68 @@ class General_options
   // This is not actually special in any way, but I need to give it
   // a non-standard accessor-function name because 'static' is a keyword.
   DEFINE_special(static, options::ONE_DASH, '\0',
-                 N_("Do not link against shared libraries"), NULL);
+		 N_("Do not link against shared libraries"), NULL);
 
   DEFINE_enum(icf, options::TWO_DASHES, '\0', "none",
-              N_("Identical Code Folding. "
-                 "\'--icf=safe\' Folds ctors, dtors and functions whose"
-                 " pointers are definitely not taken."),
-	      ("[none,all,safe]"),	
-              {"none", "all", "safe"});
+	      N_("Identical Code Folding. "
+		 "\'--icf=safe\' Folds ctors, dtors and functions whose"
+		 " pointers are definitely not taken."),
+	      ("[none,all,safe]"),
+	      {"none", "all", "safe"});
 
   DEFINE_uint(icf_iterations, options::TWO_DASHES , '\0', 0,
-              N_("Number of iterations of ICF (default 2)"), N_("COUNT"));
+	      N_("Number of iterations of ICF (default 2)"), N_("COUNT"));
 
   DEFINE_bool(print_icf_sections, options::TWO_DASHES, '\0', false,
-              N_("List folded identical sections on stderr"),
-              N_("Do not list folded identical sections"));
+	      N_("List folded identical sections on stderr"),
+	      N_("Do not list folded identical sections"));
 
   DEFINE_set(keep_unique, options::TWO_DASHES, '\0',
 	     N_("Do not fold this symbol during ICF"), N_("SYMBOL"));
 
   DEFINE_bool(gc_sections, options::TWO_DASHES, '\0', false,
-              N_("Remove unused sections"),
-              N_("Don't remove unused sections (default)"));
+	      N_("Remove unused sections"),
+	      N_("Don't remove unused sections (default)"));
 
   DEFINE_bool(print_gc_sections, options::TWO_DASHES, '\0', false,
-              N_("List removed unused sections on stderr"),
-              N_("Do not list removed unused sections"));
+	      N_("List removed unused sections on stderr"),
+	      N_("Do not list removed unused sections"));
 
   DEFINE_bool(stats, options::TWO_DASHES, '\0', false,
-              N_("Print resource usage statistics"), NULL);
+	      N_("Print resource usage statistics"), NULL);
 
   DEFINE_string(sysroot, options::TWO_DASHES, '\0', "",
-                N_("Set target system root directory"), N_("DIR"));
+		N_("Set target system root directory"), N_("DIR"));
 
   DEFINE_bool(trace, options::TWO_DASHES, 't', false,
-              N_("Print the name of each input file"), NULL);
+	      N_("Print the name of each input file"), NULL);
 
   DEFINE_special(script, options::TWO_DASHES, 'T',
-                 N_("Read linker script"), N_("FILE"));
+		 N_("Read linker script"), N_("FILE"));
 
   DEFINE_bool(threads, options::TWO_DASHES, '\0', false,
-              N_("Run the linker multi-threaded"),
-              N_("Do not run the linker multi-threaded"));
+	      N_("Run the linker multi-threaded"),
+	      N_("Do not run the linker multi-threaded"));
   DEFINE_uint(thread_count, options::TWO_DASHES, '\0', 0,
-              N_("Number of threads to use"), N_("COUNT"));
+	      N_("Number of threads to use"), N_("COUNT"));
   DEFINE_uint(thread_count_initial, options::TWO_DASHES, '\0', 0,
-              N_("Number of threads to use in initial pass"), N_("COUNT"));
+	      N_("Number of threads to use in initial pass"), N_("COUNT"));
   DEFINE_uint(thread_count_middle, options::TWO_DASHES, '\0', 0,
-              N_("Number of threads to use in middle pass"), N_("COUNT"));
+	      N_("Number of threads to use in middle pass"), N_("COUNT"));
   DEFINE_uint(thread_count_final, options::TWO_DASHES, '\0', 0,
-              N_("Number of threads to use in final pass"), N_("COUNT"));
+	      N_("Number of threads to use in final pass"), N_("COUNT"));
 
   DEFINE_uint64(Tbss, options::ONE_DASH, '\0', -1U,
-                N_("Set the address of the bss segment"), N_("ADDRESS"));
+		N_("Set the address of the bss segment"), N_("ADDRESS"));
   DEFINE_uint64(Tdata, options::ONE_DASH, '\0', -1U,
-                N_("Set the address of the data segment"), N_("ADDRESS"));
+		N_("Set the address of the data segment"), N_("ADDRESS"));
   DEFINE_uint64(Ttext, options::ONE_DASH, '\0', -1U,
-                N_("Set the address of the text segment"), N_("ADDRESS"));
+		N_("Set the address of the text segment"), N_("ADDRESS"));
+  DEFINE_uint64_alias(Ttext_segment, Ttext, options::ONE_DASH, '\0',
+		      N_("Set the address of the text segment"),
+		      N_("ADDRESS"));
+  DEFINE_uint64(Trodata_segment, options::ONE_DASH, '\0', -1U,
+		N_("Set the address of the rodata segment"), N_("ADDRESS"));
 
   DEFINE_set(undefined, options::TWO_DASHES, 'u',
 	     N_("Create undefined reference to SYMBOL"), N_("SYMBOL"));
@@ -1107,10 +1143,10 @@ class General_options
 		  "ignore-in-shared-libs"});
 
   DEFINE_bool(verbose, options::TWO_DASHES, '\0', false,
-              N_("Synonym for --debug=files"), NULL);
+	      N_("Synonym for --debug=files"), NULL);
 
   DEFINE_special(version_script, options::TWO_DASHES, '\0',
-                 N_("Read version script"), N_("FILE"));
+		 N_("Read version script"), N_("FILE"));
 
   DEFINE_bool(warn_common, options::TWO_DASHES, '\0', false,
 	      N_("Warn about duplicate common symbols"),
@@ -1150,14 +1186,14 @@ class General_options
 		 "wchar_t sizes"));
 
   DEFINE_bool(whole_archive, options::TWO_DASHES, '\0', false,
-              N_("Include all archive contents"),
-              N_("Include only needed archive contents"));
+	      N_("Include all archive contents"),
+	      N_("Include only needed archive contents"));
 
   DEFINE_set(wrap, options::TWO_DASHES, '\0',
 	     N_("Use wrapper functions for SYMBOL"), N_("SYMBOL"));
 
   DEFINE_set(trace_symbol, options::TWO_DASHES, 'y',
-             N_("Trace references to symbol"), N_("SYMBOL"));
+	     N_("Trace references to symbol"), N_("SYMBOL"));
 
   DEFINE_bool(undefined_version, options::TWO_DASHES, '\0', true,
 	      N_("Allow unused version in script (default)"),
@@ -1168,15 +1204,15 @@ class General_options
 		N_("PATH"));
 
   DEFINE_special(start_group, options::TWO_DASHES, '(',
-                 N_("Start a library search group"), NULL);
+		 N_("Start a library search group"), NULL);
   DEFINE_special(end_group, options::TWO_DASHES, ')',
-                 N_("End a library search group"), NULL);
+		 N_("End a library search group"), NULL);
 
 
   DEFINE_special(start_lib, options::TWO_DASHES, '\0',
-                 N_("Start a library"), NULL);
+		 N_("Start a library"), NULL);
   DEFINE_special(end_lib, options::TWO_DASHES, '\0',
-                 N_("End a library "), NULL);
+		 N_("End a library "), NULL);
 
   // The -z options.
 
@@ -1184,12 +1220,12 @@ class General_options
 	      N_("Sort dynamic relocs"),
 	      N_("Do not sort dynamic relocs"));
   DEFINE_uint64(common_page_size, options::DASH_Z, '\0', 0,
-                N_("Set common page size to SIZE"), N_("SIZE"));
+		N_("Set common page size to SIZE"), N_("SIZE"));
   DEFINE_bool(defs, options::DASH_Z, '\0', false,
-              N_("Report undefined symbols (even with --shared)"),
-              NULL);
+	      N_("Report undefined symbols (even with --shared)"),
+	      NULL);
   DEFINE_bool(execstack, options::DASH_Z, '\0', false,
-              N_("Mark output as requiring executable stack"), NULL);
+	      N_("Mark output as requiring executable stack"), NULL);
   DEFINE_bool(initfirst, options::DASH_Z, '\0', false,
 	      N_("Mark DSO to be initialized first at runtime"),
 	      NULL);
@@ -1203,7 +1239,7 @@ class General_options
 	      N_("Mark object requiring immediate process"),
 	      NULL);
   DEFINE_uint64(max_page_size, options::DASH_Z, '\0', 0,
-                N_("Set maximum page size to SIZE"), N_("SIZE"));
+		N_("Set maximum page size to SIZE"), N_("SIZE"));
   DEFINE_bool(muldefs, options::DASH_Z, '\0', false,
 	      N_("Allow multiple definitions of symbols"),
 	      NULL);
@@ -1225,13 +1261,13 @@ class General_options
 	      N_("Mark DSO not available to dldump"),
 	      NULL);
   DEFINE_bool(noexecstack, options::DASH_Z, '\0', false,
-              N_("Mark output as not requiring executable stack"), NULL);
+	      N_("Mark output as not requiring executable stack"), NULL);
   DEFINE_bool(now, options::DASH_Z, '\0', false,
 	      N_("Mark object for immediate function binding"),
 	      NULL);
   DEFINE_bool(origin, options::DASH_Z, '\0', false,
 	      N_("Mark DSO to indicate that needs immediate $ORIGIN "
-                 "processing at runtime"), NULL);
+		 "processing at runtime"), NULL);
   DEFINE_bool(relro, options::DASH_Z, '\0', false,
 	      N_("Where possible mark variables read-only after relocation"),
 	      N_("Don't mark variables read-only after relocation"));
@@ -1313,7 +1349,7 @@ class General_options
   should_retain_symbol(const char* symbol_name) const
     {
       if (symbols_to_retain_.empty())    // means flag wasn't specified
-        return true;
+	return true;
       return symbols_to_retain_.find(symbol_name) != symbols_to_retain_.end();
     }
 
@@ -1456,7 +1492,7 @@ class General_options
     // Do not fold any functions (Default or --icf=none).
     ICF_NONE,
     // All functions are candidates for folding. (--icf=all).
-    ICF_ALL,	
+    ICF_ALL,
     // Only ctors and dtors are candidates for folding. (--icf=safe).
     ICF_SAFE
   };
@@ -1549,7 +1585,7 @@ class General_options
   type__                                        \
   varname__() const                             \
   { return this->varname__##_; }                \
-                                                \
+						\
   void                                          \
   set_##varname__(type__ value)                 \
   { this->varname__##_ = value; }               \
@@ -1560,7 +1596,7 @@ class Position_dependent_options
 {
  public:
   Position_dependent_options(const General_options& options
-                             = Position_dependent_options::default_options_)
+			     = Position_dependent_options::default_options_)
   { copy_from_options(options); }
 
   void copy_from_options(const General_options& options)
@@ -1617,9 +1653,9 @@ class Input_file_argument
   { }
 
   Input_file_argument(const char* name, Input_file_type type,
-                      const char* extra_search_path,
-                      bool just_symbols,
-                      const Position_dependent_options& options)
+		      const char* extra_search_path,
+		      bool just_symbols,
+		      const Position_dependent_options& options)
     : name_(name), type_(type), extra_search_path_(extra_search_path),
       just_symbols_(just_symbols), options_(options), arg_serial_(0)
   { }
@@ -1629,9 +1665,9 @@ class Input_file_argument
   // position-independent vars from the General_options and only store
   // those.
   Input_file_argument(const char* name, Input_file_type type,
-                      const char* extra_search_path,
-                      bool just_symbols,
-                      const General_options& options)
+		      const char* extra_search_path,
+		      bool just_symbols,
+		      const General_options& options)
     : name_(name), type_(type), extra_search_path_(extra_search_path),
       just_symbols_(just_symbols), options_(options), arg_serial_(0)
   { }
@@ -1656,8 +1692,8 @@ class Input_file_argument
   extra_search_path() const
   {
     return (this->extra_search_path_.empty()
-            ? NULL
-            : this->extra_search_path_.c_str());
+	    ? NULL
+	    : this->extra_search_path_.c_str());
   }
 
   // Return whether we should only read symbols from this file.
@@ -1970,7 +2006,7 @@ class Command_line
   // is set to true if argv[i] is "--".
   int
   process_one_option(int argc, const char** argv, int i,
-                     bool* no_more_options);
+		     bool* no_more_options);
 
   // Get the general options.
   const General_options&
diff --git a/gold/parameters.cc b/gold/parameters.cc
index d69b62c..2781990 100644
--- a/gold/parameters.cc
+++ b/gold/parameters.cc
@@ -1,6 +1,6 @@
 // parameters.cc -- general parameters for a link using gold
 
-// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012
+// Copyright 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
 // Free Software Foundation, Inc.
 // Written by Ian Lance Taylor <iant@google.com>.
 
@@ -127,7 +127,10 @@ Parameters::set_target_once(Target* target)
   gold_assert(this->target_ == NULL);
   this->target_ = target;
   if (this->options_valid())
-    this->check_target_endianness();
+    {
+      this->check_target_endianness();
+      this->check_rodata_segment();
+    }
 }
 
 // Clear the target, for testing.
@@ -219,6 +222,15 @@ Parameters::check_target_endianness()
     }
 }
 
+void
+Parameters::check_rodata_segment()
+{
+  if (this->options().user_set_Trodata_segment()
+      && !this->options().rosegment()
+      && !this->target().isolate_execinstr())
+    gold_error(_("-Trodata-segment is meaningless without --rosegment"));
+}
+
 // Return the name of the entry symbol.
 
 const char*
diff --git a/gold/parameters.h b/gold/parameters.h
index 10de2ae..8d1ec2e 100644
--- a/gold/parameters.h
+++ b/gold/parameters.h
@@ -1,6 +1,6 @@
 // parameters.h -- general parameters for a link using gold  -*- C++ -*-
 
-// Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
+// Copyright 2006, 2007, 2008, 2009, 2010, 2013 Free Software Foundation, Inc.
 // Written by Ian Lance Taylor <iant@google.com>.
 
 // This file is part of gold.
@@ -183,6 +183,9 @@ class Parameters
   void
   check_target_endianness();
 
+  void
+  check_rodata_segment();
+
   friend class Set_parameters_target_once;
 
   Errors* errors_;
diff --git a/gold/x86_64.cc b/gold/x86_64.cc
index 8ddf4f2..592b587 100644
--- a/gold/x86_64.cc
+++ b/gold/x86_64.cc
@@ -4560,6 +4560,9 @@ class Target_x86_64_nacl : public Target_x86_64<size>
 						 plt_count);
   }
 
+  virtual std::string
+  do_code_fill(section_size_type length) const;
+
  private:
   static const Target::Target_info x86_64_nacl_info;
 };
@@ -4784,6 +4787,16 @@ Output_data_plt_x86_64_nacl<size>::plt_eh_frame_fde[plt_eh_frame_fde_size] =
   elfcpp::DW_CFA_nop
 };
 
+// Return a string used to fill a code section with nops.
+// For NaCl, long NOPs are only valid if they do not cross
+// bundle alignment boundaries, so keep it simple with one-byte NOPs.
+template<int size>
+std::string
+Target_x86_64_nacl<size>::do_code_fill(section_size_type length) const
+{
+  return std::string(length, static_cast<char>(0x90));
+}
+
 // The selector for x86_64-nacl object files.
 
 template<int size>
diff --git a/ld/ChangeLog b/ld/ChangeLog
index 20c59c7..b0f237c 100644
--- a/ld/ChangeLog
+++ b/ld/ChangeLog
@@ -1,3 +1,8 @@
+2013-07-18  Roland McGrath  <mcgrathr@google.com>
+
+	* emultempl/armelf.em (elf32_arm_add_stub_section): Take third
+	argument ALIGNMENT_POWER, use it instead of constant 3.
+
 2013-03-05  Alan Modra  <amodra@gmail.com>
 
 	PR ld/15222
diff --git a/ld/emultempl/armelf.em b/ld/emultempl/armelf.em
index 7f7d2cc..2adddbb 100644
--- a/ld/emultempl/armelf.em
+++ b/ld/emultempl/armelf.em
@@ -1,6 +1,6 @@
 # This shell script emits a C file. -*- C -*-
 #   Copyright 1991, 1993, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
-#   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
+#   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
 #   Free Software Foundation, Inc.
 #
 # This file is part of the GNU Binutils.
@@ -74,8 +74,8 @@ arm_elf_before_allocation (void)
       /* Here we rummage through the found bfds to collect glue information.  */
       LANG_FOR_EACH_INPUT_STATEMENT (is)
 	{
-          /* Initialise mapping tables for code/data.  */
-          bfd_elf32_arm_init_maps (is->the_bfd);
+	  /* Initialise mapping tables for code/data.  */
+	  bfd_elf32_arm_init_maps (is->the_bfd);
 
 	  if (!bfd_elf32_arm_process_before_allocation (is->the_bfd,
 							&link_info)
@@ -185,7 +185,8 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)
 
 static asection *
 elf32_arm_add_stub_section (const char *stub_sec_name,
-			    asection *input_section)
+			    asection *input_section,
+			    unsigned int alignment_power)
 {
   asection *stub_sec;
   flagword flags;
@@ -201,7 +202,7 @@ elf32_arm_add_stub_section (const char *stub_sec_name,
   if (stub_sec == NULL)
     goto err_ret;
 
-  bfd_set_section_alignment (stub_file->the_bfd, stub_sec, 3);
+  bfd_set_section_alignment (stub_file->the_bfd, stub_sec, alignment_power);
 
   output_section = input_section->output_section;
   secname = bfd_get_section_name (output_section->owner, output_section);
@@ -280,7 +281,7 @@ gld${EMULATION_NAME}_after_allocation (void)
 	 the unwind table index.  */
       unsigned int list_size = 10;
       asection **sec_list = (asection **)
-          xmalloc (list_size * sizeof (asection *));
+	  xmalloc (list_size * sizeof (asection *));
       unsigned int sec_count = 0;
 
       LANG_FOR_EACH_INPUT_STATEMENT (is)
@@ -307,7 +308,7 @@ gld${EMULATION_NAME}_after_allocation (void)
 		    {
 		      list_size *= 2;
 		      sec_list = (asection **)
-                          xrealloc (sec_list, list_size * sizeof (asection *));
+			  xrealloc (sec_list, list_size * sizeof (asection *));
 		    }
 
 		  sec_list[sec_count++] = sec;
@@ -373,9 +374,9 @@ gld${EMULATION_NAME}_finish (void)
   {
     LANG_FOR_EACH_INPUT_STATEMENT (is)
       {
-        /* Figure out where VFP11 erratum veneers (and the labels returning
-           from same) have been placed.  */
-        bfd_elf32_arm_vfp11_fix_veneer_locations (is->the_bfd, &link_info);
+	/* Figure out where VFP11 erratum veneers (and the labels returning
+	   from same) have been placed.  */
+	bfd_elf32_arm_vfp11_fix_veneer_locations (is->the_bfd, &link_info);
       }
   }
 
@@ -470,13 +471,13 @@ arm_elf_create_output_section_statements (void)
 				   fix_arm1176);
 
   stub_file = lang_add_input_file ("linker stubs",
- 				   lang_input_file_is_fake_enum,
- 				   NULL);
+				   lang_input_file_is_fake_enum,
+				   NULL);
   stub_file->the_bfd = bfd_create ("linker stubs", link_info.output_bfd);
   if (stub_file->the_bfd == NULL
       || ! bfd_set_arch_mach (stub_file->the_bfd,
- 			      bfd_get_arch (link_info.output_bfd),
- 			      bfd_get_mach (link_info.output_bfd)))
+			      bfd_get_arch (link_info.output_bfd),
+			      bfd_get_mach (link_info.output_bfd)))
     {
       einfo ("%X%P: can not create BFD %E\n");
       return;
@@ -577,13 +578,13 @@ PARSE_AND_LIST_OPTIONS='
   fprintf (file, _("  --pic-veneer                Always generate PIC interworking veneers\n"));
   fprintf (file, _("\
   --stub-group-size=N         Maximum size of a group of input sections that\n\
-                               can be handled by one stub section.  A negative\n\
-                               value locates all stubs after their branches\n\
-                               (with a group size of -N), while a positive\n\
-                               value allows two groups of input sections, one\n\
-                               before, and one after each stub section.\n\
-                               Values of +/-1 indicate the linker should\n\
-                               choose suitable defaults.\n"));
+			       can be handled by one stub section.  A negative\n\
+			       value locates all stubs after their branches\n\
+			       (with a group size of -N), while a positive\n\
+			       value allows two groups of input sections, one\n\
+			       before, and one after each stub section.\n\
+			       Values of +/-1 indicate the linker should\n\
+			       choose suitable defaults.\n"));
   fprintf (file, _("  --[no-]fix-cortex-a8        Disable/enable Cortex-A8 Thumb-2 branch erratum fix\n"));
   fprintf (file, _("  --no-merge-exidx-entries    Disable merging exidx entries\n"));
   fprintf (file, _("  --[no-]fix-arm1176          Disable/enable ARM1176 BLX immediate erratum fix\n"));
@@ -628,13 +629,13 @@ PARSE_AND_LIST_ARGS_CASES='
 
     case OPTION_VFP11_DENORM_FIX:
       if (strcmp (optarg, "none") == 0)
-        vfp11_denorm_fix = BFD_ARM_VFP11_FIX_NONE;
+	vfp11_denorm_fix = BFD_ARM_VFP11_FIX_NONE;
       else if (strcmp (optarg, "scalar") == 0)
-        vfp11_denorm_fix = BFD_ARM_VFP11_FIX_SCALAR;
+	vfp11_denorm_fix = BFD_ARM_VFP11_FIX_SCALAR;
       else if (strcmp (optarg, "vector") == 0)
-        vfp11_denorm_fix = BFD_ARM_VFP11_FIX_VECTOR;
+	vfp11_denorm_fix = BFD_ARM_VFP11_FIX_VECTOR;
       else
-        einfo (_("Unrecognized VFP11 fix type '\''%s'\''.\n"), optarg);
+	einfo (_("Unrecognized VFP11 fix type '\''%s'\''.\n"), optarg);
       break;
 
     case OPTION_NO_ENUM_SIZE_WARNING:
@@ -653,8 +654,8 @@ PARSE_AND_LIST_ARGS_CASES='
       {
 	const char *end;
 
-        group_size = bfd_scan_vma (optarg, &end, 0);
-        if (*end)
+	group_size = bfd_scan_vma (optarg, &end, 0);
+	if (*end)
 	  einfo (_("%P%F: invalid number `%s'\''\n"), optarg);
       }
       break;
diff --git a/ld/testsuite/ChangeLog b/ld/testsuite/ChangeLog
index 6d516e0..cb4238a 100644
--- a/ld/testsuite/ChangeLog
+++ b/ld/testsuite/ChangeLog
@@ -1,3 +1,33 @@
+2013-07-18  Roland McGrath  <mcgrathr@google.com>
+
+	* ld-arm/farcall-arm-nacl.d: New file.
+	* ld-arm/farcall-arm-nacl-pic.d: New file.
+	* ld-arm/farcall-data-nacl.d: New file.
+	* ld-arm/arm-elf.exp (armeabitests_common): Add extra element to
+	"action" lists for those cases to use a different dump file for NaCl
+	targets.
+	Massage $armeabitests_common to drop the extra element or the one
+	before it, depending on [istarget "arm*-*-nacl*"].
+
+	* ld-arm/arm-elf.exp (armelftests_common): Move all "Cortex-A8
+	erratum fix", Thumb-only and interworking cases to ...
+	(armelftests_nonacl): ... here.
+	(armeabitests_common): Move all "erratum 760522 fix", Thumb-only
+	and interworking cases to ...
+	(armeabitests_nonacl): ... here.
+
+2013-05-28  Will Newton  <will.newton@linaro.org>
+
+	* ld-arm/arm-elf.exp: Add IFUNC test 17.
+	* ld-arm/ifunc-17.dd: New file.
+	* ld-arm/ifunc-17.gd: Likewise.
+	* ld-arm/ifunc-17.rd: Likewise.
+	* ld-arm/ifunc-17.s: Likweise.
+	* ld-arm/ifunc-1.rd: Reorder relocs to match linker output.
+	* ld-arm/ifunc-2.rd: Likewise.
+	* ld-arm/ifunc-5.rd: Likewise.
+	* ld-arm/ifunc-6.rd: Likewise.
+
 2013-03-05  Alan Modra  <amodra@gmail.com>
 
 	* ld-scripts/rgn-at6.s, * ld-scripts/rgn-at6.t, * ld-scripts/rgn-at6.d,
diff --git a/ld/testsuite/ld-arm/arm-elf.exp b/ld/testsuite/ld-arm/arm-elf.exp
index 8e15ffe..641dccc 100644
--- a/ld/testsuite/ld-arm/arm-elf.exp
+++ b/ld/testsuite/ld-arm/arm-elf.exp
@@ -1,5 +1,5 @@
 # Expect script for various ARM ELF tests.
-#   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2012
+#   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2012, 2013
 #   Free Software Foundation, Inc.
 #
 # This file is part of the GNU Binutils.
@@ -71,9 +71,6 @@ set armelftests_common {
     {"Group relocations" "-Ttext 0x8000 --section-start zero=0x0 --section-start alpha=0xeef0 --section-start beta=0xffeef0" "" {group-relocs.s}
      {{objdump -dr group-relocs.d}}
      "group-relocs"}
-    {"Thumb-1 BL" "-Ttext 0x1000 --section-start .foo=0x401000" "" {thumb1-bl.s}
-     {{objdump -dr thumb1-bl.d}}
-     "thumb1-bl"}
     {"Indirect cross-library function reference (set-up)"
      "-shared" "" {arm-lib-plt-2a.s}
      {}
@@ -142,12 +139,6 @@ set armelftests_common {
     {"TLS descseq relaxation BE32" "-T arm-dyn.ld -EB" "-mbig-endian" {tls-descrelax-be32.s}
      {{objdump -fdw tls-descrelax-be32.d}}
      "tls-descrelax-be32"}
-    {"Thumb entry point" "-T arm.ld" "" {thumb-entry.s}
-     {{readelf -h thumb-entry.d}}
-     "thumb-entry"}
-    {"thumb-rel32" "-static -T arm.ld" "" {thumb-rel32.s}
-     {{objdump -s thumb-rel32.d}}
-     "thumb-rel32"}
     {"MOVW/MOVT" "-static -T arm.ld" "" {arm-movwt.s}
      {{objdump -dw arm-movwt.d}}
      "arm-movwt"}
@@ -166,79 +157,9 @@ set armelftests_common {
      "-EL --vfp11-denorm-fix=scalar -Ttext=0x8000" "-EL -mfpu=vfpxd" {vfp11-fix-none.s}
      {{objdump -dr vfp11-fix-none.d}}
      "vfp11-fix-none"}
-    {"Cortex-A8 erratum fix, b.w"
-     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-fix-b.s}
-     {{objdump -dr cortex-a8-fix-b.d}}
-     "cortex-a8-fix-b"}
-    {"Cortex-A8 erratum fix, bl.w"
-     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-fix-bl.s}
-     {{objdump -dr cortex-a8-fix-bl.d}}
-     "cortex-a8-fix-bl"}
-    {"Cortex-A8 erratum fix, bcc.w"
-     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-fix-bcc.s}
-     {{objdump -dr cortex-a8-fix-bcc.d}}
-     "cortex-a8-fix-bcc"}
-    {"Cortex-A8 erratum fix, blx.w"
-     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-fix-blx.s}
-     {{objdump -dr cortex-a8-fix-blx.d}}
-     "cortex-a8-fix-blx"}
-    {"Cortex-A8 erratum fix, relocate b.w to ARM"
-     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-arm-target.s cortex-a8-fix-b-rel.s}
-     {{objdump -dr cortex-a8-fix-b-rel-arm.d}}
-     "cortex-a8-fix-b-rel-arm"}
-    {"Cortex-A8 erratum fix, relocate b.w to Thumb"
-     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-thumb-target.s cortex-a8-fix-b-rel.s}
-     {{objdump -dr cortex-a8-fix-b-rel-thumb.d}}
-     "cortex-a8-fix-b-rel-thumb"}
-    {"Cortex-A8 erratum fix, relocate bl.w to ARM"
-     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-arm-target.s cortex-a8-fix-bl-rel.s}
-     {{objdump -dr cortex-a8-fix-bl-rel-arm.d}}
-     "cortex-a8-fix-bl-rel-arm"}
-    {"Cortex-A8 erratum fix, relocate bl.w to Thumb"
-     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-thumb-target.s cortex-a8-fix-bl-rel.s}
-     {{objdump -dr cortex-a8-fix-bl-rel-thumb.d}}
-     "cortex-a8-fix-bl-rel-thumb"}
-    {"Cortex-A8 erratum fix, relocate b<cond>.w to Thumb"
-     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-thumb-target.s cortex-a8-fix-bcc-rel.s}
-     {{objdump -dr cortex-a8-fix-bcc-rel-thumb.d}}
-     "cortex-a8-fix-bcc-rel-thumb"}
-    {"Cortex-A8 erratum fix, relocate blx.w to ARM"
-     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-arm-target.s cortex-a8-fix-blx-rel.s}
-     {{objdump -dr cortex-a8-fix-blx-rel-arm.d}}
-     "cortex-a8-fix-blx-rel-arm"}
-    {"Cortex-A8 erratum fix, relocate blx.w to Thumb"
-     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-thumb-target.s cortex-a8-fix-blx-rel.s}
-     {{objdump -dr cortex-a8-fix-blx-rel-thumb.d}}
-     "cortex-a8-fix-blx-rel-thumb"}
-    {"Cortex-A8 erratum fix, relocate bl.w and far call"
-     "-EL -Ttext=0x00 --fix-cortex-a8 --defsym _start=0"
-     "-EL -mcpu=cortex-a8" {cortex-a8-far-1.s cortex-a8-far-2.s cortex-a8-far-3.s}
-     {{objdump -dr cortex-a8-far.d}}
-     "cortex-a8-far"}
-    {"Cortex-A8 erratum fix, headers"
-     "-EL --fix-cortex-a8 -T cortex-a8-fix-hdr.t"
-     "-EL -mcpu=cortex-a8" {cortex-a8-fix-hdr.s}
-     {{objdump -dr cortex-a8-fix-hdr.d}}
-     "cortex-a8-fix-hdr"}
-    {"Cortex-A8 erratum fix, blx.w and b<cond>.w together"
-     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-fix-blx-bcond.s}
-     {{objdump -dr cortex-a8-fix-blx-bcond.d}}
-     "cortex-a8-fix-blx-bcond"}
     {"Unwinding and -gc-sections" "-gc-sections" "" {gc-unwind.s}
      {{objdump -sj.data gc-unwind.d}}
      "gc-unwind"}
-    {"Thumb and -gc-sections" "-shared -T arm-dyn.ld" "" {gc-thumb-lib.s}
-     {}
-     "gc-thumb-lib.so"}
-    {"Thumb and -gc-sections" "-pie -T arm.ld -gc-sections tmpdir/gc-thumb-lib.so" "" {gc-thumb.s}
-     {{readelf --relocs gc-thumb.d}}
-     "gc-thumb"}
-    {"arm-pic-veneer" "-static -T arm.ld --pic-veneer" "" {arm-pic-veneer.s}
-     {{objdump -d arm-pic-veneer.d}}
-     "arm-pic-veneer"}
-    {"jump19" "-static -T arm.ld" "" {jump19.s}
-     {{objdump -dr jump19.d}}
-     "jump19"}
     {"script-type" "-static -T script-type.ld" "" {script-type.s}
      {{readelf -s script-type.sym}}
      "script-type"}
@@ -274,6 +195,28 @@ set armelftests_common {
 }
 
 set armelftests_nonacl {
+    {"Thumb-1 BL" "-Ttext 0x1000 --section-start .foo=0x401000" "" {thumb1-bl.s}
+     {{objdump -dr thumb1-bl.d}}
+     "thumb1-bl"}
+    {"Thumb entry point" "-T arm.ld" "" {thumb-entry.s}
+     {{readelf -h thumb-entry.d}}
+     "thumb-entry"}
+    {"thumb-rel32" "-static -T arm.ld" "" {thumb-rel32.s}
+     {{objdump -s thumb-rel32.d}}
+     "thumb-rel32"}
+    {"Thumb and -gc-sections" "-shared -T arm-dyn.ld" "" {gc-thumb-lib.s}
+     {}
+     "gc-thumb-lib.so"}
+    {"Thumb and -gc-sections" "-pie -T arm.ld -gc-sections tmpdir/gc-thumb-lib.so" "" {gc-thumb.s}
+     {{readelf --relocs gc-thumb.d}}
+     "gc-thumb"}
+    {"arm-pic-veneer" "-static -T arm.ld --pic-veneer" "" {arm-pic-veneer.s}
+     {{objdump -d arm-pic-veneer.d}}
+     "arm-pic-veneer"}
+    {"jump19" "-static -T arm.ld" "" {jump19.s}
+     {{objdump -dr jump19.d}}
+     "jump19"}
+
     {"Simple non-PIC shared library" "-shared" "" {arm-lib.s}
      {{objdump -fdw arm-lib.d} {objdump -Rw arm-lib.r}}
      "arm-lib.so"}
@@ -351,6 +294,64 @@ set armelftests_nonacl {
      "-EL" {cortex-a8-thumb-target.s cortex-a8-fix-bl-rel.s}
      {{objdump -dr cortex-a8-fix-bl-rel-plt.d}}
      "cortex-a8-fix-bl-rel-thumb"}
+    {"Cortex-A8 erratum fix, b.w"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-fix-b.s}
+     {{objdump -dr cortex-a8-fix-b.d}}
+     "cortex-a8-fix-b"}
+    {"Cortex-A8 erratum fix, bl.w"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-fix-bl.s}
+     {{objdump -dr cortex-a8-fix-bl.d}}
+     "cortex-a8-fix-bl"}
+    {"Cortex-A8 erratum fix, bcc.w"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-fix-bcc.s}
+     {{objdump -dr cortex-a8-fix-bcc.d}}
+     "cortex-a8-fix-bcc"}
+    {"Cortex-A8 erratum fix, blx.w"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-fix-blx.s}
+     {{objdump -dr cortex-a8-fix-blx.d}}
+     "cortex-a8-fix-blx"}
+    {"Cortex-A8 erratum fix, relocate b.w to ARM"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-arm-target.s cortex-a8-fix-b-rel.s}
+     {{objdump -dr cortex-a8-fix-b-rel-arm.d}}
+     "cortex-a8-fix-b-rel-arm"}
+    {"Cortex-A8 erratum fix, relocate b.w to Thumb"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-thumb-target.s cortex-a8-fix-b-rel.s}
+     {{objdump -dr cortex-a8-fix-b-rel-thumb.d}}
+     "cortex-a8-fix-b-rel-thumb"}
+    {"Cortex-A8 erratum fix, relocate bl.w to ARM"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-arm-target.s cortex-a8-fix-bl-rel.s}
+     {{objdump -dr cortex-a8-fix-bl-rel-arm.d}}
+     "cortex-a8-fix-bl-rel-arm"}
+    {"Cortex-A8 erratum fix, relocate bl.w to Thumb"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-thumb-target.s cortex-a8-fix-bl-rel.s}
+     {{objdump -dr cortex-a8-fix-bl-rel-thumb.d}}
+     "cortex-a8-fix-bl-rel-thumb"}
+    {"Cortex-A8 erratum fix, relocate b<cond>.w to Thumb"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-thumb-target.s cortex-a8-fix-bcc-rel.s}
+     {{objdump -dr cortex-a8-fix-bcc-rel-thumb.d}}
+     "cortex-a8-fix-bcc-rel-thumb"}
+    {"Cortex-A8 erratum fix, relocate blx.w to ARM"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-arm-target.s cortex-a8-fix-blx-rel.s}
+     {{objdump -dr cortex-a8-fix-blx-rel-arm.d}}
+     "cortex-a8-fix-blx-rel-arm"}
+    {"Cortex-A8 erratum fix, relocate blx.w to Thumb"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-thumb-target.s cortex-a8-fix-blx-rel.s}
+     {{objdump -dr cortex-a8-fix-blx-rel-thumb.d}}
+     "cortex-a8-fix-blx-rel-thumb"}
+    {"Cortex-A8 erratum fix, relocate bl.w and far call"
+     "-EL -Ttext=0x00 --fix-cortex-a8 --defsym _start=0"
+     "-EL -mcpu=cortex-a8" {cortex-a8-far-1.s cortex-a8-far-2.s cortex-a8-far-3.s}
+     {{objdump -dr cortex-a8-far.d}}
+     "cortex-a8-far"}
+    {"Cortex-A8 erratum fix, headers"
+     "-EL --fix-cortex-a8 -T cortex-a8-fix-hdr.t"
+     "-EL -mcpu=cortex-a8" {cortex-a8-fix-hdr.s}
+     {{objdump -dr cortex-a8-fix-hdr.d}}
+     "cortex-a8-fix-hdr"}
+    {"Cortex-A8 erratum fix, blx.w and b<cond>.w together"
+     "-EL -Ttext=0x8f00 --fix-cortex-a8" "-EL" {cortex-a8-fix-blx-bcond.s}
+     {{objdump -dr cortex-a8-fix-blx-bcond.d}}
+     "cortex-a8-fix-blx-bcond"}
     {"IFUNC test 1" "-T ifunc-static.ld" "" {ifunc-1.s}
      {{objdump -d ifunc-1.dd}
       {objdump {-s -j.data -j.got} ifunc-1.gd}
@@ -433,6 +434,11 @@ set armelftests_nonacl {
       {objdump {-s -j.data -j.got} ifunc-16.gd}
       {readelf -r ifunc-16.rd}}
      "ifunc-16"}
+    {"IFUNC test 17" "-T ifunc-static.ld" "" {ifunc-17.s}
+     {{objdump -d ifunc-17.dd}
+      {objdump {-s -j.data -j.got} ifunc-17.gd}
+      {readelf -r ifunc-17.rd}}
+     "ifunc-17"}
 }
 
 run_ld_link_tests $armelftests_common
@@ -472,7 +478,13 @@ if { ![istarget "arm*-*-*eabi"] && ![istarget "arm*-*-nacl*"] } {
     return
 }
 
-# Farcalls stubs are fully supported for ARM-EABI only
+# Farcalls stubs are fully supported for ARM-EABI only.
+# This list is massaged below into run_ld_link_tests standard format.
+# The source list is almost that same format.  The one difference is
+# that each "action" (elements of element 5) might have four elements
+# instead of three; in that case, the fourth element is the name of
+# the dump file to use for arm*-*nacl* targets instead of the canonical
+# dump file (the third element).
 set armeabitests_common {
      {"EABI attribute merging" "-r" "" {attr-merge.s attr-merge.s}
       {{readelf -A attr-merge.attr}}
@@ -510,108 +522,29 @@ set armeabitests_common {
      {"EABI attribute arch merging 2 reversed" "-r" "" {arch-v6.s arch-v6k.s}
       {{readelf -A attr-merge-arch-2.attr}}
       "attr-merge-arch-2r"}
-     {"Thumb-2 BL" "-Ttext 0x1000 --section-start .foo=0x1001000" "" {thumb2-bl.s}
-      {{objdump -dr thumb2-bl.d}}
-      "thumb2-bl"}
-     {"Thumb-2 Interworked branch" "-T arm.ld" "" {thumb2-b-interwork.s}
-      {{objdump -dr thumb2-b-interwork.d}}
-      "thumb2-b-interwork"}
-    {"BL/BLX interworking" "-T arm.ld" "" {thumb2-bl-blx-interwork.s}
-     {{objdump -dr thumb2-bl-blx-interwork.d}}
-     "thumb2-bl-blx-interwork"}
-    {"ARMv4 interworking" "-static -T arm.ld --fix-v4bx-interworking" "--fix-v4bx -meabi=4" {armv4-bx.s}
-     {{objdump -d armv4-bx.d}}
-     "armv4-bx"}
     {"MOVW/MOVT and merged sections" "-T arm.ld" "" {movw-merge.s}
      {{objdump -dw movw-merge.d}}
      "movw-merge"}
     {"MOVW/MOVT against shared libraries" "tmpdir/arm-lib.so" "" {arm-app-movw.s}
      {{objdump -Rw arm-app.r}}
      "arm-app-movw"}
-    {"Thumb-2-as-Thumb-1 BL" "--no-fix-arm1176 -Ttext 0x1000 --section-start .foo=0x100100c" "" {thumb2-bl-as-thumb1-bad.s}
-     {{objdump -d thumb2-bl-as-thumb1-bad.d}}
-     "thumb2-bl-as-thumb1-bad"}
-    {"Thumb-2 BL" "-Ttext 0x1000 --section-start .foo=0x100100c" "" {thumb2-bl-bad.s}
-     {{objdump -d thumb2-bl-bad.d}}
-     "thumb2-bl-bad"}
 
     {"ARM-ARM farcall" "-Ttext 0x1000 --section-start .foo=0x2001020" "" {farcall-arm-arm.s}
-     {{objdump -d farcall-arm-arm.d}}
+     {{objdump -d farcall-arm-arm.d farcall-arm-nacl.d}}
      "farcall-arm-arm"}
     {"ARM-ARM farcall (PIC veneer)" "-Ttext 0x1000 --section-start .foo=0x2001020 --pic-veneer" "" {farcall-arm-arm.s}
-     {{objdump -d farcall-arm-arm-pic-veneer.d}}
+     {{objdump -d farcall-arm-arm-pic-veneer.d farcall-arm-nacl-pic.d}}
      "farcall-arm-arm-pic-veneer"}
     {"ARM-ARM farcall (BE8)" "-Ttext 0x1000 --section-start .foo=0x2001020 -EB --be8" "-EB" {farcall-arm-arm.s}
-     {{objdump -d farcall-arm-arm.d}}
+     {{objdump -d farcall-arm-arm.d farcall-arm-nacl.d}}
      "farcall-arm-arm-be8"}
     {"ARM-ARM farcall (BE)" "-Ttext 0x1000 --section-start .foo=0x2001020 -EB" "-EB" {farcall-arm-arm.s}
-     {{objdump -d farcall-arm-arm.d}}
+     {{objdump -d farcall-arm-arm.d farcall-arm-nacl.d}}
      "farcall-arm-arm-be"}
 
-    {"Multiple farcalls" "-Ttext 0x1000 --section-start .foo=0x2002020" "" {farcall-mix.s}
-     {{objdump -d farcall-mix.d}}
-     "farcall-mix"}
-    {"Multiple farcalls from several sections" "-Ttext 0x1000 --section-start .mytext=0x2000 --section-start .foo=0x2003020" "" {farcall-mix2.s}
-     {{objdump -d farcall-mix2.d}}
-     "farcall-mix2"}
-
-    {"Default group size" "-Ttext 0x1000 --section-start .foo=0x2003020" "" {farcall-group.s farcall-group2.s}
-     {{objdump -d farcall-group.d}}
-     "farcall-group-default"}
-    {"Group size=2" "-Ttext 0x1000 --section-start .foo=0x2003020 --stub-group-size=2" "" {farcall-group.s farcall-group2.s}
-     {{objdump -d farcall-group-size2.d}}
-     "farcall-group-size2"}
-    {"Group size limit" "-Ttext 0x1000 --section-start .far=0x2003020" "" {farcall-group3.s farcall-group4.s}
-     {{objdump -d farcall-group-limit.d}}
-     "farcall-group-limit"}
-
     {"Long branch with mixed text and data" "-T arm.ld" "" {farcall-data.s}
-     {{objdump -dr farcall-data.d}}
+     {{objdump -dr farcall-data.d farcall-data-nacl.d}}
      "farcall-data"}
-
-    {"R_ARM_THM_JUMP24 Relocation veneers: Short 1"
-     "--no-fix-arm1176 --section-start destsect=0x00009000 --section-start .text=0x8000"
-     "-march=armv7-a -mthumb"
-     {jump-reloc-veneers.s}
-     {{objdump -d jump-reloc-veneers-short1.d}}
-     "jump-reloc-veneers-short1"}
-    {"R_ARM_THM_JUMP24 Relocation veneers: Short 2"
-     "--no-fix-arm1176 --section-start destsect=0x00900000 --section-start .text=0x8000"
-     "-march=armv7-a -mthumb"
-     {jump-reloc-veneers.s}
-     {{objdump -d jump-reloc-veneers-short2.d}}
-     "jump-reloc-veneers-short2"}
-    {"R_ARM_THM_JUMP24 Relocation veneers: Long"
-     "--no-fix-arm1176 --section-start destsect=0x09000000 --section-start .text=0x8000"
-     "-march=armv7-a -mthumb"
-     {jump-reloc-veneers.s}
-     {{objdump -d jump-reloc-veneers-long.d}}
-     "jump-reloc-veneers-long"}
-
-    {"erratum 760522 fix (default for v6z)" "--section-start=.foo=0x2001014"
-     "-march=armv6z" {fix-arm1176.s}
-     {{objdump -d fix-arm1176-on.d}}
-     "fix-arm1176-1"}
-    {"erratum 760522 fix (explicitly on at v6z)" "--section-start=.foo=0x2001014 --fix-arm1176"
-     "-march=armv6z" {fix-arm1176.s}
-     {{objdump -d fix-arm1176-on.d}}
-     "fix-arm1176-2"}
-    {"erratum 760522 fix (explicitly off at v6z)" "--section-start=.foo=0x2001014 --no-fix-arm1176"
-     "-march=armv6z" {fix-arm1176.s}
-     {{objdump -d fix-arm1176-off.d}}
-     "fix-arm1176-3"}
-    {"erratum 760522 fix (default for v5)" "--section-start=.foo=0x2001014 "
-     "-march=armv5te" {fix-arm1176.s}
-     {{objdump -d fix-arm1176-on.d}}
-     "fix-arm1176-4"}
-    {"erratum 760522 fix (default for v7-a)" "--section-start=.foo=0x2001014 "
-     "-march=armv7-a" {fix-arm1176.s}
-     {{objdump -d fix-arm1176-off.d}}
-     "fix-arm1176-5"}
-    {"erratum 760522 fix (default for ARM1156)" "--section-start=.foo=0x2001014 "
-     "-mcpu=arm1156t2f-s" {fix-arm1176.s}
-     {{objdump -d fix-arm1176-off.d}}
-     "fix-arm1176-6"}
 }
 
 set armeabitests_nonacl {
@@ -672,6 +605,23 @@ set armeabitests_nonacl {
      {{objdump -d farcall-thumb-arm-pic-veneer.d}}
      "farcall-thumb-arm-pic-veneer"}
 
+    {"Multiple farcalls" "-Ttext 0x1000 --section-start .foo=0x2002020" "" {farcall-mix.s}
+     {{objdump -d farcall-mix.d}}
+     "farcall-mix"}
+    {"Multiple farcalls from several sections" "-Ttext 0x1000 --section-start .mytext=0x2000 --section-start .foo=0x2003020" "" {farcall-mix2.s}
+     {{objdump -d farcall-mix2.d}}
+     "farcall-mix2"}
+
+    {"Default group size" "-Ttext 0x1000 --section-start .foo=0x2003020" "" {farcall-group.s farcall-group2.s}
+     {{objdump -d farcall-group.d}}
+     "farcall-group-default"}
+    {"Group size=2" "-Ttext 0x1000 --section-start .foo=0x2003020 --stub-group-size=2" "" {farcall-group.s farcall-group2.s}
+     {{objdump -d farcall-group-size2.d}}
+     "farcall-group-size2"}
+    {"Group size limit" "-Ttext 0x1000 --section-start .far=0x2003020" "" {farcall-group3.s farcall-group4.s}
+     {{objdump -d farcall-group-limit.d}}
+     "farcall-group-limit"}
+
     {"Mixed ARM/Thumb dynamic application with farcalls" "tmpdir/mixed-lib.so -T arm-dyn.ld --section-start .far_arm=0x2100000 --section-start .far_thumb=0x2200000" ""
      {farcall-mixed-app.s}
      {{objdump -fdw farcall-mixed-app.d} {objdump -Rw farcall-mixed-app.r}
@@ -693,6 +643,70 @@ set armeabitests_nonacl {
      {{objdump -fdw farcall-mixed-lib.d}}
      "farcall-mixed-lib.so"}
 
+    {"Thumb-2-as-Thumb-1 BL" "--no-fix-arm1176 -Ttext 0x1000 --section-start .foo=0x100100c" "" {thumb2-bl-as-thumb1-bad.s}
+     {{objdump -d thumb2-bl-as-thumb1-bad.d}}
+     "thumb2-bl-as-thumb1-bad"}
+    {"Thumb-2 BL" "-Ttext 0x1000 --section-start .foo=0x100100c" "" {thumb2-bl-bad.s}
+     {{objdump -d thumb2-bl-bad.d}}
+     "thumb2-bl-bad"}
+
+    {"Thumb-2 BL" "-Ttext 0x1000 --section-start .foo=0x1001000" "" {thumb2-bl.s}
+     {{objdump -dr thumb2-bl.d}}
+     "thumb2-bl"}
+    {"Thumb-2 Interworked branch" "-T arm.ld" "" {thumb2-b-interwork.s}
+     {{objdump -dr thumb2-b-interwork.d}}
+     "thumb2-b-interwork"}
+    {"BL/BLX interworking" "-T arm.ld" "" {thumb2-bl-blx-interwork.s}
+     {{objdump -dr thumb2-bl-blx-interwork.d}}
+    "thumb2-bl-blx-interwork"}
+    {"ARMv4 interworking" "-static -T arm.ld --fix-v4bx-interworking" "--fix-v4bx -meabi=4" {armv4-bx.s}
+     {{objdump -d armv4-bx.d}}
+     "armv4-bx"}
+
+    {"R_ARM_THM_JUMP24 Relocation veneers: Short 1"
+     "--no-fix-arm1176 --section-start destsect=0x00009000 --section-start .text=0x8000"
+     "-march=armv7-a -mthumb"
+     {jump-reloc-veneers.s}
+     {{objdump -d jump-reloc-veneers-short1.d}}
+     "jump-reloc-veneers-short1"}
+    {"R_ARM_THM_JUMP24 Relocation veneers: Short 2"
+     "--no-fix-arm1176 --section-start destsect=0x00900000 --section-start .text=0x8000"
+     "-march=armv7-a -mthumb"
+     {jump-reloc-veneers.s}
+     {{objdump -d jump-reloc-veneers-short2.d}}
+     "jump-reloc-veneers-short2"}
+    {"R_ARM_THM_JUMP24 Relocation veneers: Long"
+     "--no-fix-arm1176 --section-start destsect=0x09000000 --section-start .text=0x8000"
+     "-march=armv7-a -mthumb"
+     {jump-reloc-veneers.s}
+     {{objdump -d jump-reloc-veneers-long.d}}
+     "jump-reloc-veneers-long"}
+
+    {"erratum 760522 fix (default for v6z)" "--section-start=.foo=0x2001014"
+     "-march=armv6z" {fix-arm1176.s}
+     {{objdump -d fix-arm1176-on.d}}
+     "fix-arm1176-1"}
+    {"erratum 760522 fix (explicitly on at v6z)" "--section-start=.foo=0x2001014 --fix-arm1176"
+     "-march=armv6z" {fix-arm1176.s}
+     {{objdump -d fix-arm1176-on.d}}
+     "fix-arm1176-2"}
+    {"erratum 760522 fix (explicitly off at v6z)" "--section-start=.foo=0x2001014 --no-fix-arm1176"
+     "-march=armv6z" {fix-arm1176.s}
+     {{objdump -d fix-arm1176-off.d}}
+     "fix-arm1176-3"}
+    {"erratum 760522 fix (default for v5)" "--section-start=.foo=0x2001014 "
+     "-march=armv5te" {fix-arm1176.s}
+     {{objdump -d fix-arm1176-on.d}}
+     "fix-arm1176-4"}
+    {"erratum 760522 fix (default for v7-a)" "--section-start=.foo=0x2001014 "
+     "-march=armv7-a" {fix-arm1176.s}
+     {{objdump -d fix-arm1176-off.d}}
+     "fix-arm1176-5"}
+    {"erratum 760522 fix (default for ARM1156)" "--section-start=.foo=0x2001014 "
+     "-mcpu=arm1156t2f-s" {fix-arm1176.s}
+     {{objdump -d fix-arm1176-off.d}}
+     "fix-arm1176-6"}
+
     {"TLS gnu shared library" "--no-fix-arm1176 -shared -T arm-dyn.ld" "" {tls-gdesc.s}
      {{objdump -fdw tls-gdesc.d} {objdump -Rw tls-gdesc.r}}
      "tls-lib2.so"}
@@ -710,6 +724,27 @@ set armeabitests_nonacl {
      "tls-thumb1"}
 }
 
+# Massage the $armeabitests_common list into run_ld_link_tests standard form.
+# See the comment before 'set armeabitests_common', above.
+set elide_action_elt 3
+set is_nacl [istarget "arm*-*-nacl*"]
+if {$is_nacl} {
+    set elide_action_elt 2
+}
+set neabi_common [llength $armeabitests_common]
+for {set i 0} {$i < $neabi_common} {incr i} {
+    set case [lindex $armeabitests_common $i]
+    set actions [lindex $case 4]
+    set nactions [llength $actions]
+    for {set j 0} {$j < $nactions} {incr j} {
+	set action [lindex $actions $j]
+	if {[llength $action] == 4} {
+	    set action [lreplace $action $elide_action_elt $elide_action_elt]
+	    lset armeabitests_common $i 4 $j $action
+	}
+    }
+}
+
 run_ld_link_tests $armeabitests_common
 if { ![istarget "arm*-*-nacl*"] } {
     run_ld_link_tests $armeabitests_nonacl
diff --git a/ld/testsuite/ld-arm/ifunc-1.rd b/ld/testsuite/ld-arm/ifunc-1.rd
index 75e6d70..2644123 100644
--- a/ld/testsuite/ld-arm/ifunc-1.rd
+++ b/ld/testsuite/ld-arm/ifunc-1.rd
@@ -4,5 +4,5 @@ There is no dynamic section in this file\.
 Relocation section '\.rel\.dyn' at offset 0x8000 contains 3 entries:
  Offset     Info    Type            Sym\.Value  Sym\. Name
 0001100c  ......a0 R_ARM_IRELATIVE  
-00011010  ......a0 R_ARM_IRELATIVE  
 00011014  ......a0 R_ARM_IRELATIVE  
+00011010  ......a0 R_ARM_IRELATIVE  
diff --git a/ld/testsuite/ld-arm/ifunc-2.rd b/ld/testsuite/ld-arm/ifunc-2.rd
index 92b000a..7bbabf4 100644
--- a/ld/testsuite/ld-arm/ifunc-2.rd
+++ b/ld/testsuite/ld-arm/ifunc-2.rd
@@ -5,9 +5,9 @@ Relocation section '\.rel\.dyn' at offset 0x8000 contains 8 entries:
  Offset     Info    Type            Sym\.Value  Sym\. Name
 0001100c  ......a0 R_ARM_IRELATIVE  
 00011010  ......a0 R_ARM_IRELATIVE  
+00011020  ......a0 R_ARM_IRELATIVE  
+00011028  ......a0 R_ARM_IRELATIVE  
 00011014  ......a0 R_ARM_IRELATIVE  
 00011018  ......a0 R_ARM_IRELATIVE  
 0001101c  ......a0 R_ARM_IRELATIVE  
-00011020  ......a0 R_ARM_IRELATIVE  
 00011024  ......a0 R_ARM_IRELATIVE  
-00011028  ......a0 R_ARM_IRELATIVE  
diff --git a/ld/testsuite/ld-arm/ifunc-5.rd b/ld/testsuite/ld-arm/ifunc-5.rd
index 75e6d70..2644123 100644
--- a/ld/testsuite/ld-arm/ifunc-5.rd
+++ b/ld/testsuite/ld-arm/ifunc-5.rd
@@ -4,5 +4,5 @@ There is no dynamic section in this file\.
 Relocation section '\.rel\.dyn' at offset 0x8000 contains 3 entries:
  Offset     Info    Type            Sym\.Value  Sym\. Name
 0001100c  ......a0 R_ARM_IRELATIVE  
-00011010  ......a0 R_ARM_IRELATIVE  
 00011014  ......a0 R_ARM_IRELATIVE  
+00011010  ......a0 R_ARM_IRELATIVE  
diff --git a/ld/testsuite/ld-arm/ifunc-6.rd b/ld/testsuite/ld-arm/ifunc-6.rd
index 0fbfec5..04c18a9 100644
--- a/ld/testsuite/ld-arm/ifunc-6.rd
+++ b/ld/testsuite/ld-arm/ifunc-6.rd
@@ -3,7 +3,7 @@ There is no dynamic section in this file\.
 
 Relocation section '\.rel\.dyn' at offset 0x8000 contains 4 entries:
  Offset     Info    Type            Sym\.Value  Sym\. Name
-0001100c  ......a0 R_ARM_IRELATIVE  
+00011018  ......a0 R_ARM_IRELATIVE  
 00011010  ......a0 R_ARM_IRELATIVE  
+0001100c  ......a0 R_ARM_IRELATIVE  
 00011014  ......a0 R_ARM_IRELATIVE  
-00011018  ......a0 R_ARM_IRELATIVE  
diff --git a/opcodes/ChangeLog b/opcodes/ChangeLog
index 96dfaeb..4adbc86 100644
--- a/opcodes/ChangeLog
+++ b/opcodes/ChangeLog
@@ -1,3 +1,12 @@
+2013-05-13  Yufeng Zhang  <yufeng.zhang@arm.com>
+
+	Backport from mainline:
+
+	2013-05-13  Yufeng Zhang  <yufeng.zhang@arm.com>
+	* aarch64-asm.c (aarch64_ins_advsimd_imm_modified): Remove assertion.
+	* aarch64-opc.c (operand_general_constraint_met_p): Relax the range
+	check from [0, 255] to [-128, 255].
+
 2013-03-25  Tristan Gingold  <gingold@adacore.com>
 	Backport of: 2013-03-08  Yann Sionneau  <yann.sionneau@gmail.com>
 
diff --git a/opcodes/aarch64-asm.c b/opcodes/aarch64-asm.c
index 16cdaa9..ba463d9 100644
--- a/opcodes/aarch64-asm.c
+++ b/opcodes/aarch64-asm.c
@@ -369,7 +369,6 @@ aarch64_ins_advsimd_imm_modified (const aarch64_operand *self ATTRIBUTE_UNUSED,
       imm = aarch64_shrink_expanded_imm8 (imm);
       assert ((int)imm >= 0);
     }
-  assert (imm <= 255);
   insert_fields (code, imm, 0, 2, FLD_defgh, FLD_abc);
 
   if (kind == AARCH64_MOD_NONE)
diff --git a/opcodes/aarch64-opc.c b/opcodes/aarch64-opc.c
index 73a760a..32f34c6 100644
--- a/opcodes/aarch64-opc.c
+++ b/opcodes/aarch64-opc.c
@@ -1724,10 +1724,10 @@ operand_general_constraint_met_p (const aarch64_opnd_info *opnds, int idx,
 	  assert (idx == 1);
 	  if (aarch64_get_qualifier_esize (opnds[0].qualifier) != 8)
 	    {
-	      /* uimm8 */
-	      if (!value_in_range_p (opnd->imm.value, 0, 255))
+	      /* uimm8 or simm8 */
+	      if (!value_in_range_p (opnd->imm.value, -128, 255))
 		{
-		  set_imm_out_of_range_error (mismatch_detail, idx, 0, 255);
+		  set_imm_out_of_range_error (mismatch_detail, idx, -128, 255);
 		  return 0;
 		}
 	    }
-- 
1.8.1.2

