Index: bfd/ChangeLog
===================================================================
RCS file: /cvs/src/src/bfd/ChangeLog,v
retrieving revision 1.4318.2.16
retrieving revision 1.4318.2.19
diff -r1.4318.2.16 -r1.4318.2.19
0a1,19
> 2008-11-20  Alan Modra  <amodra@bigpond.net.au>
> 
> 	* elf32-ppc.c (allocate_dynrelocs): Always use tlsld_got for
> 	TLS_LD even when symbol is used with other TLS reloc types.
> 	(ppc_elf_relocate_section): Bypass symbol checks when using tlsld_got.
> 	Leave addend zero on LD DTPMOD dynamic reloc.
> 
> 2008-11-17  Eric B. Weddington  <eric.weddington@atmel.com>
> 
> 	PR 7022
> 	* elf32-avr.c (bfd_elf_avr_final_write_processing):
> 	Add missing break statements.
> 
> 2008-10-28  Tristan Gingold  <gingold@adacore.com>
> 
> 	* configure.in: Bump version to 2.19.0
> 	* Makefile.am (RELEASE): Unset.
> 	* configure, Makefile.in: Regenerated.
> 
Index: bfd/Makefile.am
===================================================================
RCS file: /cvs/src/src/bfd/Makefile.am,v
retrieving revision 1.214.2.2
retrieving revision 1.214.2.3
diff -r1.214.2.2 -r1.214.2.3
7c7
< RELEASE=y
---
> # RELEASE=y
Index: bfd/Makefile.in
===================================================================
RCS file: /cvs/src/src/bfd/Makefile.in,v
retrieving revision 1.237.2.2
retrieving revision 1.237.2.3
diff -r1.237.2.2 -r1.237.2.3
274c274
< RELEASE = y
---
> # RELEASE=y
Index: bfd/configure
===================================================================
RCS file: /cvs/src/src/bfd/configure,v
retrieving revision 1.281.2.5
retrieving revision 1.281.2.6
diff -r1.281.2.5 -r1.281.2.6
3035c3035
<  VERSION=2.19
---
>  VERSION=2.19.0
Index: bfd/configure.in
===================================================================
RCS file: /cvs/src/src/bfd/configure.in,v
retrieving revision 1.243.2.5
retrieving revision 1.243.2.6
diff -r1.243.2.5 -r1.243.2.6
11c11
< AM_INIT_AUTOMAKE(bfd, 2.19)
---
> AM_INIT_AUTOMAKE(bfd, 2.19.0)
Index: bfd/elf32-avr.c
===================================================================
RCS file: /cvs/src/src/bfd/elf32-avr.c,v
retrieving revision 1.37
retrieving revision 1.37.2.1
diff -r1.37 -r1.37.2.1
1300a1301
>       break;
1307a1309
>       break;
1310a1313
>       break;
Index: bfd/elf32-ppc.c
===================================================================
RCS file: /cvs/src/src/bfd/elf32-ppc.c,v
retrieving revision 1.243.2.3
retrieving revision 1.243.2.4
diff -r1.243.2.3 -r1.243.2.4
4999a5000,5002
>       bfd_boolean dyn;
>       unsigned int need;
> 
5009,5016c5012,5013
<       if (eh->tls_mask == (TLS_TLS | TLS_LD)
< 	  && !eh->elf.def_dynamic)
< 	{
< 	  /* If just an LD reloc, we'll just use htab->tlsld_got.offset.  */
< 	  htab->tlsld_got.refcount += 1;
< 	  eh->elf.got.offset = (bfd_vma) -1;
< 	}
<       else
---
>       need = 0;
>       if ((eh->tls_mask & TLS_TLS) != 0)
5018,5020c5015
< 	  bfd_boolean dyn;
< 	  unsigned int need = 0;
< 	  if ((eh->tls_mask & TLS_TLS) != 0)
---
> 	  if ((eh->tls_mask & TLS_LD) != 0)
5022,5024c5017,5022
< 	      if ((eh->tls_mask & TLS_LD) != 0)
< 		need += 8;
< 	      if ((eh->tls_mask & TLS_GD) != 0)
---
> 	      if (!eh->elf.def_dynamic)
> 		/* We'll just use htab->tlsld_got.offset.  This should
> 		   always be the case.  It's a little odd if we have
> 		   a local dynamic reloc against a non-local symbol.  */
> 		htab->tlsld_got.refcount += 1;
> 	      else
5026,5029d5023
< 	      if ((eh->tls_mask & (TLS_TPREL | TLS_TPRELGD)) != 0)
< 		need += 4;
< 	      if ((eh->tls_mask & TLS_DTPREL) != 0)
< 		need += 4;
5031c5025,5029
< 	  else
---
> 	  if ((eh->tls_mask & TLS_GD) != 0)
> 	    need += 8;
> 	  if ((eh->tls_mask & (TLS_TPREL | TLS_TPRELGD)) != 0)
> 	    need += 4;
> 	  if ((eh->tls_mask & TLS_DTPREL) != 0)
5032a5031,5037
> 	}
>       else
> 	need += 4;
>       if (need == 0)
> 	eh->elf.got.offset = (bfd_vma) -1;
>       else
> 	{
5042c5047,5048
< 	      if ((eh->tls_mask & TLS_LD) != 0)
---
> 	      if ((eh->tls_mask & TLS_LD) != 0
> 		  && eh->elf.def_dynamic)
5278c5284,5285
< 	    if (*lgot_masks == (TLS_TLS | TLS_LD))
---
> 	    unsigned int need = 0;
> 	    if ((*lgot_masks & TLS_TLS) != 0)
5280,5283c5287,5294
< 		/* If just an LD reloc, we'll just use
< 		   htab->tlsld_got.offset.  */
< 		htab->tlsld_got.refcount += 1;
< 		*local_got = (bfd_vma) -1;
---
> 		if ((*lgot_masks & TLS_GD) != 0)
> 		  need += 8;
> 		if ((*lgot_masks & TLS_LD) != 0)
> 		  htab->tlsld_got.refcount += 1;
> 		if ((*lgot_masks & (TLS_TPREL | TLS_TPRELGD)) != 0)
> 		  need += 4;
> 		if ((*lgot_masks & TLS_DTPREL) != 0)
> 		  need += 4;
5285a5297,5300
> 	      need += 4;
> 	    if (need == 0)
> 	      *local_got = (bfd_vma) -1;
> 	    else
5287,5298d5301
< 		unsigned int need = 0;
< 		if ((*lgot_masks & TLS_TLS) != 0)
< 		  {
< 		    if ((*lgot_masks & TLS_GD) != 0)
< 		      need += 8;
< 		    if ((*lgot_masks & (TLS_TPREL | TLS_TPRELGD)) != 0)
< 		      need += 4;
< 		    if ((*lgot_masks & TLS_DTPREL) != 0)
< 		      need += 4;
< 		  }
< 		else
< 		  need += 4;
6563c6566,6567
< 			&& (h == NULL
---
> 			&& (offp == &htab->tlsld_got.offset
> 			    || h == NULL
6594c6598
< 			if (indx == 0)
---
> 			if (indx == 0 && tls_ty != (TLS_TLS | TLS_LD))
Index: bfd/version.h
===================================================================
RCS file: /cvs/src/src/bfd/version.h,v
retrieving revision 1.2442.2.37
retrieving revision 1.2442.2.82
diff -r1.2442.2.37 -r1.2442.2.82
1c1
< #define BFD_VERSION_DATE 20081016
---
> #define BFD_VERSION_DATE 20081130
Index: ld/ChangeLog
===================================================================
RCS file: /cvs/src/src/ld/ChangeLog,v
retrieving revision 1.1868.2.6
retrieving revision 1.1868.2.7
diff -r1.1868.2.6 -r1.1868.2.7
0a1,5
> 2008-11-14  Alan Modra  <amodra@bigpond.net.au>
> 
> 	* Makefile.am (spu_ovl.o_c): Add missing line continuations.
> 	* Makefile.in: Regenerate.
> 
Index: ld/Makefile.am
===================================================================
RCS file: /cvs/src/src/ld/Makefile.am,v
retrieving revision 1.253.2.1
retrieving revision 1.253.2.2
diff -r1.253.2.1 -r1.253.2.2
761c761
< 	  cpp -DOVLY_IRQ_SAVE $(srcdir)/emultempl/spu_ovl.S spu_ovl.s
---
> 	  cpp -DOVLY_IRQ_SAVE $(srcdir)/emultempl/spu_ovl.S spu_ovl.s; \
763c763
< 	  ../binutils/bin2c <spu_ovl.o >$@
---
> 	  ../binutils/bin2c <spu_ovl.o >$@; \
Index: ld/Makefile.in
===================================================================
RCS file: /cvs/src/src/ld/Makefile.in,v
retrieving revision 1.274.2.1
retrieving revision 1.274.2.2
diff -r1.274.2.1 -r1.274.2.2
1591c1591
< 	  cpp -DOVLY_IRQ_SAVE $(srcdir)/emultempl/spu_ovl.S spu_ovl.s
---
> 	  cpp -DOVLY_IRQ_SAVE $(srcdir)/emultempl/spu_ovl.S spu_ovl.s; \
1593c1593
< 	  ../binutils/bin2c <spu_ovl.o >$@
---
> 	  ../binutils/bin2c <spu_ovl.o >$@; \
Index: opcodes/ChangeLog
===================================================================
RCS file: /cvs/src/src/opcodes/ChangeLog,v
retrieving revision 1.1299.2.2
retrieving revision 1.1299.2.5
diff -r1.1299.2.2 -r1.1299.2.5
0a1,17
> 2008-11-27  Alan Modra  <amodra@bigpond.net.au>
> 
> 	* ppc-opc.c (extract_sprg): Correct operand range check.
> 
> 2008-11-26  Andreas Schwab  <schwab@suse.de>
> 
> 	* m68k-dis.c (NEXTBYTE, NEXTWORD, NEXTLONG, NEXTULONG, NEXTSINGLE)
> 	(NEXTDOUBLE, NEXTEXTEND, NEXTPACKED): Fix error handling.
> 	(save_printer, save_print_address): Remove.
> 	(fetch_data): Don't use them.
> 	(match_insn_m68k): Always restore printing functions.
> 	(print_insn_m68k): Don't save/restore printing functions.
> 
> 2008-11-25  Nick Clifton  <nickc@redhat.com>
> 
> 	* m68k-dis.c: Rewrite to remove use of setjmp/longjmp.
> 
Index: opcodes/m68k-dis.c
===================================================================
RCS file: /cvs/src/src/opcodes/m68k-dis.c,v
retrieving revision 1.29
retrieving revision 1.29.8.2
diff -r1.29 -r1.29.8.2
63c63,71
< #define NEXTBYTE(p)  (p += 2, FETCH_DATA (info, p), COERCE_SIGNED_CHAR(p[-1]))
---
> #define NEXTBYTE(p, val)			\
>   do						\
>     {						\
>       p += 2;					\
>       if (!FETCH_DATA (info, p))		\
> 	return -3;				\
>       val = COERCE_SIGNED_CHAR (p[-1]);		\
>     }						\
>   while (0)
67,69c75,84
< #define NEXTWORD(p)  \
<   (p += 2, FETCH_DATA (info, p), \
<    COERCE16 ((p[-2] << 8) + p[-1]))
---
> 
> #define NEXTWORD(p, val, ret_val)		\
>   do						\
>     {						\
>       p += 2;					\
>       if (!FETCH_DATA (info, p))		\
> 	return ret_val;				\
>       val = COERCE16 ((p[-2] << 8) + p[-1]);	\
>     }						\
>   while (0)						
73,75c88,97
< #define NEXTLONG(p)  \
<   (p += 4, FETCH_DATA (info, p), \
<    (COERCE32 ((((((p[-4] << 8) + p[-3]) << 8) + p[-2]) << 8) + p[-1])))
---
> 
> #define NEXTLONG(p, val, ret_val)					\
>   do									\
>     {									\
>       p += 4;								\
>       if (!FETCH_DATA (info, p))					\
> 	return ret_val;							\
>       val = COERCE32 ((((((p[-4] << 8) + p[-3]) << 8) + p[-2]) << 8) + p[-1]); \
>     }									\
>   while (0)
78,80c100,108
< #define NEXTULONG(p)  \
<   (p += 4, FETCH_DATA (info, p), \
<    (unsigned int) ((((((p[-4] << 8) + p[-3]) << 8) + p[-2]) << 8) + p[-1]))
---
> #define NEXTULONG(p, val)						\
>   do									\
>     {									\
>       p += 4;								\
>       if (!FETCH_DATA (info, p))					\
> 	return -3;							\
>       val = (unsigned int) ((((((p[-4] << 8) + p[-3]) << 8) + p[-2]) << 8) + p[-1]); \
>     }									\
>   while (0)
83,85c111,120
< #define NEXTSINGLE(val, p) \
<   (p += 4, FETCH_DATA (info, p), \
<    floatformat_to_double (&floatformat_ieee_single_big, (char *) p - 4, &val))
---
> #define NEXTSINGLE(val, p)					\
>   do								\
>     {								\
>       p += 4;							\
>       if (!FETCH_DATA (info, p))				\
> 	return -3;						\
>       floatformat_to_double (& floatformat_ieee_single_big,	\
> 			     (char *) p - 4, & val);		\
>     }								\
>   while (0)
88,90c123,132
< #define NEXTDOUBLE(val, p) \
<   (p += 8, FETCH_DATA (info, p), \
<    floatformat_to_double (&floatformat_ieee_double_big, (char *) p - 8, &val))
---
> #define NEXTDOUBLE(val, p)					\
>   do								\
>     {								\
>       p += 8;							\
>       if (!FETCH_DATA (info, p))				\
> 	return -3;						\
>       floatformat_to_double (& floatformat_ieee_double_big,	\
> 			     (char *) p - 8, & val);		\
>     }								\
>   while (0)
93,95c135,144
< #define NEXTEXTEND(val, p) \
<   (p += 12, FETCH_DATA (info, p), \
<    floatformat_to_double (&floatformat_m68881_ext, (char *) p - 12, &val))
---
> #define NEXTEXTEND(val, p)				\
>   do							\
>     {							\
>       p += 12;						\
>       if (!FETCH_DATA (info, p))			\
> 	return -3;					\
>       floatformat_to_double (& floatformat_m68881_ext,	\
> 			     (char *) p - 12, & val);	\
>     }							\
>   while (0)
101,102c150,159
< #define NEXTPACKED(p) \
<   (p += 12, FETCH_DATA (info, p), 0.0)
---
> #define NEXTPACKED(p, val)			\
>   do						\
>     {						\
>       p += 12;					\
>       if (!FETCH_DATA (info, p))		\
> 	return -3;				\
>       val = 0.0;				\
>     }						\
>   while (0)
> 
115d171
<   jmp_buf bailout;
119,120c175
<    to ADDR (exclusive) are valid.  Returns 1 for success, longjmps
<    on error.  */
---
>    to ADDR (exclusive) are valid.  Returns 1 for success, 0 on error.  */
139c194
<       longjmp (priv->bailout, 1);
---
>       return 0;
164c219,220
<    BUFFER contains the instruction.  */
---
>    BUFFER contains the instruction.
>    Returns -1 on failure.  */
219c275,276
<       FETCH_DATA (info, buffer + 3);
---
>       if (! FETCH_DATA (info, buffer + 3))
> 	return -1;
224c281,282
<       FETCH_DATA (info, buffer + 3);
---
>       if (! FETCH_DATA (info, buffer + 3))
> 	return -1;
229c287,288
<       FETCH_DATA (info, buffer + 3);
---
>       if (! FETCH_DATA (info, buffer + 3))
> 	return -1;
235c294,295
<       FETCH_DATA (info, buffer + 3);
---
>       if (! FETCH_DATA (info, buffer + 3))
> 	return -1;
242c302,303
<       FETCH_DATA (info, buffer + 3);
---
>       if (! FETCH_DATA (info, buffer + 3))
> 	return -1;
247c308,309
<       FETCH_DATA (info, buffer + 5);
---
>       if (! FETCH_DATA (info, buffer + 5))
> 	return -1;
253c315,316
<       FETCH_DATA (info, buffer + 5);
---
>       if (! FETCH_DATA (info, buffer + 5))
> 	return -1;
259c322,323
<       FETCH_DATA (info, buffer + 5);
---
>       if (! FETCH_DATA (info, buffer + 5))
> 	return -1;
264c328,329
<       FETCH_DATA (info, buffer + 3);
---
>       if (! FETCH_DATA (info, buffer + 3))
> 	return -1;
270c335,336
<       FETCH_DATA (info, buffer + 3);
---
>       if (! FETCH_DATA (info, buffer + 3))
> 	return -1;
276c342,343
<       FETCH_DATA (info, buffer + 3);
---
>       if (! FETCH_DATA (info, buffer + 3))
> 	return -1;
286c353,354
<       FETCH_DATA (info, buffer + 3);
---
>       if (! FETCH_DATA (info, buffer + 3))
> 	return -1;
453c521,522
<    ADDR is the nominal core address of that extension word.  */
---
>    ADDR is the nominal core address of that extension word.
>    Returns NULL upon error.  */
468c537
<   word = NEXTWORD (p);
---
>   NEXTWORD (p, word, NULL);
506c575
<       base_disp = NEXTWORD (p);
---
>       NEXTWORD (p, base_disp, NULL);
509c578
<       base_disp = NEXTLONG (p);
---
>       NEXTLONG (p, base_disp, NULL);
529c598
<       outer_disp = NEXTWORD (p);
---
>       NEXTWORD (p, outer_disp, NULL);
532c601
<       outer_disp = NEXTLONG (p);
---
>       NEXTLONG (p, outer_disp, NULL);
549a619,627
> #define FETCH_ARG(size, val)				\
>   do							\
>     {							\
>       val = fetch_arg (buffer, place, size, info);	\
>       if (val < 0)					\
> 	return -3;					\
>     }							\
>   while (0)
> 
552c630
<    an opcode tabe error was found.
---
>    an opcode tabe error was found or -3 to simply abort.
578,579c656,657
<         val = fetch_arg (buffer, place, 2, info);
<         (*info->fprintf_func) (info->stream, cacheFieldName[val]);
---
>         FETCH_ARG (2, val);
> 	(*info->fprintf_func) (info->stream, cacheFieldName[val]);
585,588c663,664
<         (*info->fprintf_func)
< 	  (info->stream,
< 	   "%s@",
< 	   reg_names[fetch_arg (buffer, place, 3, info) + 8]);
---
> 	FETCH_ARG (3, val);
> 	(*info->fprintf_func) (info->stream, "%s@", reg_names[val + 8]);
594c670
<         uval = NEXTULONG (p);
---
>         NEXTULONG (p, uval);
646c722
< 	val = fetch_arg (buffer, place, 12, info);
---
> 	FETCH_ARG (12, val);
659c735
<       val = fetch_arg (buffer, place, 3, info);
---
>       FETCH_ARG (3, val);
667c743
<       val = fetch_arg (buffer, place, 3, info);
---
>       FETCH_ARG (3, val);
675c751
<       val = fetch_arg (buffer, place, 3, info);
---
>       FETCH_ARG (3, val);
680c756
<       val = fetch_arg (buffer, place, 9, info);
---
>       FETCH_ARG (9, val);
688c764,765
< 	  val = fetch_arg (buffer, place, 1, info);
---
> 
> 	  FETCH_ARG (1, val);
693c770
< 	  val = fetch_arg (buffer, place, 8, info);
---
> 	  FETCH_ARG (8, val);
701c778
<       val = fetch_arg (buffer, place, 4, info);
---
>       FETCH_ARG (4, val);
706,707c783,784
<       (*info->fprintf_func) (info->stream, "%s",
< 			     reg_names[fetch_arg (buffer, place, 3, info)]);
---
>       FETCH_ARG (3, val);
>       (*info->fprintf_func) (info->stream, "%s", reg_names[val]);
711,713c788,789
<       (*info->fprintf_func)
< 	(info->stream, "%s",
< 	 reg_names[fetch_arg (buffer, place, 3, info) + 010]);
---
>       FETCH_ARG (3, val);
>       (*info->fprintf_func) (info->stream, "%s", reg_names[val + 010]);
717,719c793,794
<       (*info->fprintf_func)
< 	(info->stream, "%s",
< 	 reg_names[fetch_arg (buffer, place, 4, info)]);
---
>       FETCH_ARG (4, val);
>       (*info->fprintf_func) (info->stream, "%s", reg_names[val]);
723c798
<       regno = fetch_arg (buffer, place, 4, info);
---
>       FETCH_ARG (4, regno);
731,733c806,807
<       (*info->fprintf_func)
< 	(info->stream, "%%fp%d",
< 	 fetch_arg (buffer, place, 3, info));
---
>       FETCH_ARG (3, val);
>       (*info->fprintf_func) (info->stream, "%%fp%d", val);
737c811
<       val = fetch_arg (buffer, place, 6, info);
---
>       FETCH_ARG (6, val);
745,747c819,820
<       (*info->fprintf_func)
< 	(info->stream, "%s@+",
< 	 reg_names[fetch_arg (buffer, place, 3, info) + 8]);
---
>       FETCH_ARG (3, val);
>       (*info->fprintf_func) (info->stream, "%s@+", reg_names[val + 8]);
751,753c824,825
<       (*info->fprintf_func)
< 	(info->stream, "%s@-",
< 	 reg_names[fetch_arg (buffer, place, 3, info) + 8]);
---
>       FETCH_ARG (3, val);
>       (*info->fprintf_func) (info->stream, "%s@-", reg_names[val + 8]);
758,760c830,833
< 	(*info->fprintf_func)
< 	  (info->stream, "{%s}",
< 	   reg_names[fetch_arg (buffer, place, 3, info)]);
---
> 	{
> 	  FETCH_ARG (3, val);
> 	  (*info->fprintf_func) (info->stream, "{%s}", reg_names[val]);
> 	}
763c836
< 	  val = fetch_arg (buffer, place, 7, info);
---
> 	  FETCH_ARG (7, val);
769c842
< 	return -2;
---
> 	return -1;
776c849
< 	val = fetch_arg (buffer, place, 4, info);
---
> 	FETCH_ARG (4, val);
778c851
< 	val = fetch_arg (buffer, place, 7, info);
---
> 	FETCH_ARG (7, val);
780c853
< 	val = fetch_arg (buffer, place, 3, info);
---
> 	FETCH_ARG (3, val);
782c855
< 	val = fetch_arg (buffer, place, 8, info);
---
> 	FETCH_ARG (8, val);
784c857
< 	val = NEXTBYTE (p1);
---
> 	NEXTBYTE (p1, val);
786c859
< 	val = NEXTWORD (p1);
---
> 	NEXTWORD (p1, val, -3);
788c861
< 	val = NEXTLONG (p1);
---
> 	NEXTLONG (p1, val, -3);
790a864
> 
796c870
< 	disp = NEXTBYTE (p);
---
> 	NEXTBYTE (p, disp);
800c874
< 	disp = NEXTWORD (p);
---
> 	NEXTWORD (p, disp, -3);
802c876
< 	disp = NEXTLONG (p);
---
> 	NEXTLONG (p, disp, -3);
805c879
< 	  disp = NEXTBYTE (buffer);
---
> 	  NEXTBYTE (buffer, disp);
807c881
< 	    disp = NEXTWORD (p);
---
> 	    NEXTWORD (p, disp, -3);
809c883
< 	    disp = NEXTLONG (p);
---
> 	    NEXTLONG (p, disp, -3);
814c888
< 	    disp = NEXTLONG (p);
---
> 	    NEXTLONG (p, disp, -3);
816c890
< 	    disp = NEXTWORD (p);
---
> 	    NEXTWORD (p, disp, -3);
825,829c899,906
<       val = NEXTWORD (p);
<       (*info->fprintf_func)
< 	(info->stream, "%s@(%d)",
< 	 reg_names[fetch_arg (buffer, place, 3, info) + 8], val);
<       break;
---
>       {
> 	int val1;
> 
> 	NEXTWORD (p, val, -3);
> 	FETCH_ARG (3, val1);
> 	(*info->fprintf_func) (info->stream, "%s@(%d)", reg_names[val1 + 8], val);
> 	break;
>       }
832,833c909,910
<       (*info->fprintf_func) (info->stream, "%s",
< 			     fpcr_names[fetch_arg (buffer, place, 3, info)]);
---
>       FETCH_ARG (3, val);
>       (*info->fprintf_func) (info->stream, "%s", fpcr_names[val]);
837c914
<       val = fetch_arg(buffer, place, 2, info);
---
>       FETCH_ARG (2, val);
842,843c919,920
<       val = fetch_arg(buffer, place, 1, info);
<       (*info->fprintf_func) (info->stream, "%%accext%s", val==0 ? "01" : "23");
---
>       FETCH_ARG (1, val);
>       (*info->fprintf_func) (info->stream, "%%accext%s", val == 0 ? "01" : "23");
847c924
<       val = fetch_arg(buffer, place, 2, info);
---
>       FETCH_ARG (2, val);
859c936,937
< 
---
>       if (val < 0)
> 	return -3;
890a969,970
> 	  if (val < 0)
> 	    return -3;
894c974,978
< 	val = fetch_arg (buffer, 's', 6, info);
---
> 	{
> 	  val = fetch_arg (buffer, 's', 6, info);
> 	  if (val < 0)
> 	    return -3;
> 	}
926c1010
< 	  val = NEXTWORD (p);
---
> 	  NEXTWORD (p, val, -3);
931a1016,1017
> 	  if (p == NULL)
> 	    return -3;
938c1024
< 	      val = NEXTWORD (p);
---
> 	      NEXTWORD (p, val, -3);
943c1029
< 	      uval = NEXTULONG (p);
---
> 	      NEXTULONG (p, uval);
948c1034
< 	      val = NEXTWORD (p);
---
> 	      NEXTWORD (p, val, -3);
955a1042,1043
> 	      if (p == NULL)
> 		return -3;
963c1051
< 		  val = NEXTBYTE (p);
---
> 		  NEXTBYTE (p, val);
968c1056
< 		  val = NEXTWORD (p);
---
> 		  NEXTWORD (p, val, -3);
973c1061
< 		  val = NEXTLONG (p);
---
> 		  NEXTLONG (p, val, -3);
990c1078
< 		  flval = NEXTPACKED (p);
---
> 		  NEXTPACKED (p, flval);
1012c1100
< 	  val = fetch_arg (buffer, place, 1, info);
---
> 	  FETCH_ARG (1, val);
1024c1112
< 	    val = NEXTWORD (p1);
---
> 	    NEXTWORD (p1, val, -3);
1065c1153,1154
< 	    val = fetch_arg (buffer, place, 8, info);
---
> 
> 	    FETCH_ARG (8, val);
1098a1188
> 	    FETCH_ARG (3, val);
1100,1102c1190
< 	    (*info->fprintf_func) (info->stream, "%s",
< 				   fpcr_names[fetch_arg (buffer, place, 3,
< 							 info)]);
---
> 	    (*info->fprintf_func) (info->stream, "%s", fpcr_names[val]);
1118c1206
< 	int val = fetch_arg (buffer, place, 5, info);
---
> 	int val;
1120a1209
> 	FETCH_ARG (5, val);
1155c1244
< 	int fc = fetch_arg (buffer, place, 5, info);
---
> 	int fc;
1156a1246
> 	FETCH_ARG (5, fc);
1173c1263
< 	int level = fetch_arg (buffer, place, 3, info);
---
> 	int level;
1174a1265
> 	FETCH_ARG (3, level);
1182c1273
< 	int reg = fetch_arg (buffer, place, 5, info);
---
> 	int reg;
1183a1275
> 	FETCH_ARG (5, reg);
1306c1398
<       else if (eaten == -1)
---
>       else if (eaten == -1 || eaten == -3)
1321c1413
< 			      best->name,  best->args);
---
> 			      best->name, best->args);
1441a1534,1535
> 		      if (val < 0)
> 			return 0;
1482,1488c1576
<   /* Save these printing functions in case we need to restore them
<      later.  */
<   fprintf_ftype save_printer = info->fprintf_func;
<   void (* save_print_address) (bfd_vma, struct disassemble_info *)
<     = info->print_address_func;
< 
<   info->private_data = (PTR) &priv;
---
>   info->private_data = & priv;
1497,1518d1584
<   if (setjmp (priv.bailout) != 0)
<     {
<       /* longjmp may be called while these printing functions are
< 	 temporarily replaced with dummy functions.  Restore them
< 	 before we leave.
< 
< 	 Admittedly, this save-and-restore operation is somewhat ugly
< 	 in that we are exposing the fact that match_insn_m68k
< 	 temporarily replaces insn->fprintf_func and
< 	 insn->print_address_func.  Perhaps, a real fix is to report a
< 	 FETCH_DATA failure with a return value of some sort, without
< 	 using setjmp/longjmp.  A better fix may be to teach the m68k
< 	 disassembler do its job without temporarily replacing
< 	 insn->fprintf_func and insn->print_address_func, but that's a
< 	 task for another day.  */
<       info->fprintf_func = save_printer;
<       info->print_address_func = save_print_address;
< 
<       /* Error return.  */
<       return -1;
<     }
< 
1525,1530c1591,1592
<       if (val)
< 	return val;
< 
<       val = m68k_scan_mask (memaddr, info, mcf_mask);
<       if (val)
< 	return val;
---
>       if (val == 0)
> 	val = m68k_scan_mask (memaddr, info, mcf_mask);
1535,1536d1596
<       if (val)
< 	return val;
1539,1541c1599,1603
<   /* Handle undefined instructions.  */
<   info->fprintf_func (info->stream, "0%o", (buffer[0] << 8) + buffer[1]);
<   return 2;
---
>   if (val == 0)
>     /* Handle undefined instructions.  */
>     info->fprintf_func (info->stream, "0%o", (buffer[0] << 8) + buffer[1]);
> 
>   return val ? val : 2;
Index: opcodes/ppc-opc.c
===================================================================
RCS file: /cvs/src/src/opcodes/ppc-opc.c,v
retrieving revision 1.110
retrieving revision 1.110.2.1
diff -r1.110 -r1.110.2.1
1284,1287c1284,1287
<   if (val <= 3
<       || (val < 0x10 && (insn & 0x100) != 0)
<       || (val - 0x10 > 3
< 	  && (dialect & (PPC_OPCODE_BOOKE | PPC_OPCODE_403)) == 0))
---
>   if ((val - 0x10 > 3 && (dialect & (PPC_OPCODE_BOOKE | PPC_OPCODE_405)) == 0)
>       || (val - 0x10 > 7 && (insn & 0x100) != 0)
>       || val <= 3
>       || (val & 8) != 0)
