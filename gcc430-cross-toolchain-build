Here are notes and scripts and things related to my efforts to build a
cross-toolchain using current tools, by which I mean:

binutils 2.18
gcc 4.3.0
glibc 2.7
gmp 4.2.2
linux 2.6.25 (or, for mips, 2.6.23.16)
mpfr 2.3.1

GMP and MPFR are new pieces of the GNU toolchain; since they are required
in order to build GCC, I think they qualify as components of the toolchain
the same way that glibc does.

This is all built using a sysroot approach, as recommended by the GCC
developers, and WITHOUT using most of the CLFS toolchain build
instructions.  "sysroot" means that a directory on the host system, in our
case /tools, will be set up to contain a subset of the root filesystem of
the target system; include files and libraries will be used only from the
sysroot location, not from the normal host system locations.  That's
perfect for us, since we want to ensure that components of the host system
are ignored by our cross-tools, whether we're doing a real cross-toolchain
or a faux cross-toolchain (like an x86-to-x86 cross).

The patches referred to here are included in the "patches" directory.

Note that we are building our cross-glibc with a "minimum kernel version"
of 2.6.25; that means the actual runtime kernel being used to construct the
real LFS system using the stuff under /tools will have to be a 2.6.25
kernel.  You can adjust the kernel version downward if you are currently
using an older kernel and don't want to upgrade it.  It isn't really a big
deal to build an optimized glibc here; none of the code we are currently
building will wind up on the final system.

Flags for building an x86-to-x86 "faux" cross-toolchain -- put these in the
building user's .bashrc:

export CLFS=/mnt
export LC_ALL=POSIX
export PATH=/cross-tools/bin:/bin:/usr/bin
unset CFLAGS
unset CXXFLAGS
export CLFS_HOST=i686-cross-linux-gnu
export CLFS_TARGET=i686-pc-linux-gnu
export SYSROOT=/tools
export KERNEL_VERSION=2.6.25
unset KERNEL_ARCH
export GLIBCFLAG="-march=$(cut -d- -f1 <<< $CLFS_TARGET) -mtune=generic -g -O2"


Flags for building an x86-to-mipsel cross-toolchain:

export CLFS_TARGET=mipsel-unknown-linux-gnu
export KERNEL_VERSION=2.6.23
export GLIBCFLAG="-g -O2"
export KERNEL_ARCH="ARCH=mips"

For each build step, I am copying the script snippets into a
little script called "b" and then running it with:

time ./b 2>&1 | tee $CLFS/Logs/${NAME_OF_STEP}

where NAME_OF_STEP changes every time, obviously.

gcc, glibc, and binutils MUST all be built from a separate "build"
directory, not the source directory.  Normally, the source directory name
includes the version number (e.g. binutils-2.18); I'm using my git 
repositories for the toolchain components, so the version number isn't in
the directory name.  All of the scriptlets embedded here have configure
commands that work for me, using my git toolchain components; you'll have
to adjust them if you're working from released source tarballs.

STEP 0 host system dependencies

Build and install gmp and mpfr.  I used gmp 4.2.2 and mpfr 2.3.1.  You can
install them anywhere you want, but I went with /usr.  They don't take up
much space, and they might come in handy for something later.

The CLFS book says it's also important to have file at least version 2.41,
so go ahead and upgrade that if necessary.

STEP 1 linux kernel headers

This one doesn't need a separate build directory.

make mrproper &&
make $KERNEL_ARCH headers_check &&
make $KERNEL_ARCH headers_install INSTALL_HDR_PATH=$SYSROOT/usr &&
echo WOOT

[On digad: 0:19 azoth: 0:13]

STEP 2 binutils

Apply the posix and branch_update-3 patches from CLFS.

../binutils/configure --prefix=/cross-tools \
   --build=${CLFS_HOST} --target=${CLFS_TARGET} \
   --disable-nls --enable-shared --disable-multilib \
   --with-sysroot=$SYSROOT --with-build-sysroot=$SYSROOT &&
make configure-host && make && make install &&
cp -v ../binutils*/include/libiberty.h $SYSROOT/usr/include &&
echo WOOT

[On digad: 2:30 azoth 2:00]

STEP 3 glibc headers

Apply the patches: libgcc_eh, localedef_segfault, i586_chk, and
fixup_for_gcc43.  The first three are from CLFS; the last one corrects the
glibc build so it works with GCC 4.3 (and is already in glibc CVS).

After doing this build, get rid of the glibc-build directory but
keep the source directory around for now:  we will need it again a
little later.

CC=gcc ../glibc/configure --prefix=/usr \
  --host=${CLFS_HOST} --build=${CLFS_TARGET} \
  --disable-sanity-checks --enable-kernel=${KERNEL_VERSION} \
  --with-headers=$SYSROOT/usr/include \
  --with-binutils=/cross-tools/${CLFS_TARGET}/bin &&
make cross-compiling=yes install_root=$SYSROOT install-headers &&
cp -v bits/stdio_lim.h $SYSROOT/usr/include/bits &&
touch $SYSROOT/usr/include/gnu/stubs.h &&
cp -v ../glibc*/nptl/sysdeps/pthread/pthread.h $SYSROOT/usr/include &&
cp -v ../glibc*/nptl/sysdeps/unix/sysv/linux/i386/bits/pthreadtypes.h \
    $SYSROOT/usr/include/bits &&
echo WOOT

[On digad: 0:49 azoth: 0:30]

STEP 4 gcc (bare compiler)

Apply only the posix patch from CLFS.

It seems as though it should be unnecessary to mess around with the GCC
specs here.  It is a cross-compiler; if the wrong libraries are linked in,
presumably the thing will simply not work at all, and this compiler is only
going to be used to build glibc anyway.  (We're going to rebuild GCC after
we have a glibc.)

After doing this build, don't get rid of ANYTHING -- we will use the same
build directory later on after we use the bare compiler from here to create
the startup files that are needed to get libgcc compiled.  (If you do
delete the gcc-build directory, don't panic, it will just take a few
minutes to rebuild the bare compiler before the libgcc build happens.)

GCC can't create programs unless it has access to a support library called
libgcc.  (There are other support libraries as well, like libgcc_eh, but I
don't know what they are for.)  We can't build libgcc, because it has to be
linked against some C runtime startup files (crti.o and a couple others)
from glibc.  So all we can do at this point is build a "bare" compiler:
just the gcc program per se.  We can use that bare compiler to produce the
C startup files.

After we build the crt?.o files, we can then build libgcc; and then we'll
be able to build glibc.  After that, we'll build the full gcc.

With the x86 to x86 toolchain, I did not have to specify host.  With the
x86 to mips toolchain, I did.  It's OK to specify it for the faux-cross 
toolchain as well.

The LDFLAGS_FOR_TARGET and CPPFLAGS_FOR_TARGET are from gcc bug #35532 --
they are mentioned by Carlos O'Donell as the way to use all of the sysroot
framework.


../gcc/configure --prefix=/cross-tools \
  --build=${CLFS_HOST} --host=${CLFS_HOST} --target=${CLFS_TARGET} \
  --disable-multilib \
  --disable-nls --disable-shared \
  --disable-libmudflap --disable-libssp \
  --disable-threads --enable-languages=c \
  --with-sysroot=$SYSROOT --with-build-sysroot=$SYSROOT &&
export LDFLAGS_FOR_TARGET="--sysroot=$SYSROOT" &&
export CPPFLAGS_FOR_TARGET="--sysroot=$SYSROOT" &&
make all-gcc && make install-gcc &&
echo WOOT

[On digad: 6:36 azoth: 4:28]


STEP 5 glibc (startup files)

If you kept around the source directory from step 3, just use it again
here.  If not, remember to apply the patches: libgcc_eh,
localedef_segfault, i586_chk, and fixup_for_gcc43.  

The build commands here just build the startup files we need.  We'll build
the rest of glibc after we build libgcc.

Again, when this step is complete, delete the glibc-build directory but
keep the source directory around.


echo "libc_cv_forced_unwind=yes" > config.cache
echo "libc_cv_c_cleanup=yes" >> config.cache
BUILD_CC="gcc" CC="${CLFS_TARGET}-gcc" \
    AR="${CLFS_TARGET}-ar" RANLIB="${CLFS_TARGET}-ranlib" \
    CFLAGS="${GLIBCFLAG}" \
    ../glibc/configure --prefix=/usr \
    --host=${CLFS_TARGET} --build=${CLFS_HOST} \
    --disable-profile --enable-add-ons \
    --with-tls --enable-kernel=${KERNEL_VERSION} --with-__thread \
    --with-binutils=/cross-tools/bin --with-headers=$SYSROOT/usr/include \
    --cache-file=config.cache &&
make -r -C ../glibc/csu objdir=$(pwd) $(pwd)/csu/crt1.o &&
make -r -C ../glibc/csu objdir=$(pwd) $(pwd)/csu/crti.o &&
make -r -C ../glibc/csu objdir=$(pwd) $(pwd)/csu/crtn.o &&
mkdir -p $SYSROOT/lib &&
cp csu/crt{1,i,n}.o $SYSROOT/lib &&
echo WOOT

[On digad: 0:12 azoth: 0:20]


STEP 6 gcc (libgcc)

If you deleted the gcc and/or gcc-build directories from step 4,
reconstruct them now by doing that step again.  After this, trash the
gcc-build directory; but we will want the gcc source directory one more
time.

After we build and install libgcc, we can get rid of the crt object files
we just built in the previous step.  They're going to be rebuilt anyway
when we do the full glibc build.

make all-target-libgcc && make install-target-libgcc && 
rm -f $SYSROOT/lib/crt{1,i,n}.o &&
echo WOOT

[On digad: 0:49 azoth: 0:48]


STEP 7 glibc

Now we have a usable GCC, complete with libgcc, and we can build glibc at
last!  Use the same glibc source directory as before, or re-apply all the
patches that were used previously; but use a fresh glibc-build directory.


echo "libc_cv_forced_unwind=yes" > config.cache
echo "libc_cv_c_cleanup=yes" >> config.cache
BUILD_CC="gcc" CC="${CLFS_TARGET}-gcc" \
    AR="${CLFS_TARGET}-ar" RANLIB="${CLFS_TARGET}-ranlib" \
    CFLAGS="$GLIBCFLAG" \
    ../glibc/configure --prefix=/tools \
    --host=${CLFS_TARGET} --build=${CLFS_HOST} \
    --disable-profile --enable-add-ons \
    --with-tls --enable-kernel=${KERNEL_VERSION} --with-__thread \
    --with-binutils=/cross-tools/bin --with-headers=$SYSROOT/usr/include \
    --cache-file=config.cache &&
make && 
make install_root=/ install && 
echo WOOT

[On digad: 14:07 azoth: 11:00]


STEP 8 gcc (full compiler)

Now we are going to build the full gcc cross-compiler.  The point of this
compiler is to build the temporary tools (under /tools) that will allow us
to build the final LFS system.  When we're using those tools to build the
final system, we want to do a native build of everything, including glibc,
so we want those tools to be independent of any filesystem locations that
will still be present in the final system.  In particular, this includes
/lib.

When the standard GNU toolchain builds an executable, it always links it
against the dynamic link library (which is /lib/ld-linux.so.2).  That's
normally fine, but we want the programs we build under /tools to be
entirely independent of /lib.  So we need to adjust our cross-toolchain so
that the programs it builds look in /tools/lib for their libraries.
Alternatively, we could build everything under /tools as a static
executable, so they would be self-contained and not need any shared
libraries at all; but that option isn't well-supported by glibc.  (Maybe if
we changed the cross-toolchain to be uClibc-based, instead of glibc-based,
we could get that to work.)

We're going to try to adjust things after the build, instead of
applying additional patches now.  Use the same posix patch as earlier, but
no others.

../gcc/configure --prefix=/cross-tools \
  --build=${CLFS_HOST} --host=${CLFS_HOST} --target=${CLFS_TARGET} \
  --disable-multilib \
  --disable-nls --enable-shared \
  --enable-languages=c,c++ --enable-__cxa_atexit \
  --enable-c99 --enable-long-long --enable-threads=posix \
  --with-sysroot=$SYSROOT --with-build-sysroot=$SYSROOT &&
export LDFLAGS_FOR_TARGET="--sysroot=$SYSROOT" &&
export CPPFLAGS_FOR_TARGET="--sysroot=$SYSROOT" &&
make AS_FOR_TARGET="${CLFS_TARGET}-as" LD_FOR_TARGET="${CLFS_TARGET}-ld" &&
make install &&
echo WOOT

[On digad: 11:28 azoth: 9:04]

Wow, it worked.  I didn't expect that to happen.


STEP 9 Adjusting The Toolchain

Spec file editing is a dark art.  You can read all about it in
gcc.info, though, so it's not as intractably dark an art as
building a cross-toolchain from source.

There are specs built into gcc these days (rather than present as
an actual file called specs); you can display them with "gcc
-dumpspecs".  If you put a modified specs file in the same
directory as libgcc.a, then that overrides the built-in specs.

The spec we want to change is the "dynamic-linker" spec.

So:

${CLFS_TARGET}-gcc -dumpspecs | sed -e 's@/lib/ld@/tools/lib/ld@g' > \
   $(dirname $(${CLFS_TARGET}-gcc --print-libgcc-file-name))/specs

Now the binaries built in the next chapter, when we are
constructing the temporary tools, will seek the dynamic linker
under /tools just like we want them to.

