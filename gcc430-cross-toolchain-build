Here are notes and scripts and things related to my efforts to
build a cross-toolchain using current tools, by which I mean:

binutils 2.18
gcc 4.3.0
glibc 2.7
gmp 4.2.2
linux 2.6.25 (or, for mips, 2.6.23.16)
mpfr 2.3.1

GMP and MPFR are new pieces of the GNU toolchain; since they are
required in order to build GCC, I think they qualify as
components of the toolchain the same way that glibc does.

This is all built using a sysroot approach, as recommended by the GCC
developers, and WITHOUT using most of the CLFS toolchain build
instructions.  "sysroot" means that a directory on the host system, in our
case /tools, will be set up to contain a subset of the root filesystem of
the target system; include files and libraries will be used only from the
sysroot location, not from the normal host system locations.  That's
perfect for us, since we want to ensure that components of the host system
are ignored by our cross-tools, whether we're doing a real cross-toolchain
or a faux cross-toolchain (like an x86-to-x86 cross).

The patches referred to here are included in the "patches" directory.

Flags for building an x86-to-x86 "cross" toolchain -- put these in the
building user's .bashrc:

export CLFS=/mnt
export LC_ALL=POSIX
export PATH=/cross-tools/bin:/bin:/usr/bin
unset CFLAGS
unset CXXFLAGS
export CLFS_HOST=i686-cross-linux-gnu
export CLFS_TARGET=i686-pc-linux-gnu
export SYSROOT=/tools
export KERNEL_VERSION=2.6.25
unset KERNEL_ARCH
export GLIBCFLAG="-march=$(cut -d- -f1 <<< $CLFS_TARGET) -mtune=generic -g -O2"


Flags for building an x86-to-mipsel cross-toolchain:

export CLFS_TARGET=mipsel-unknown-linux-gnu
export KERNEL_VERSION=2.6.23
export GLIBCFLAG="-g -O2"
export KERNEL_ARCH="ARCH=mips"

For each build step, I am copying the script snippets into a
little script called "b" and then running it with:

time ./b 2>&1 | tee $CLFS/Logs/${NAME_OF_STEP}

where NAME_OF_STEP changes every time, obviously.

STEP 0 host system dependencies

Build and install gmp and mpfr.  I used gmp 4.2.2 and mpfr 2.3.1.
You can install them anywhere you want, but I went with /usr.

The CLFS book says it's also important to have file at least 
version 2.41, so go ahead and upgrade that if necessary.

STEP 1 linux kernel headers

This one doesn't need a separate build directory.

make mrproper &&
make $KERNEL_ARCH headers_check &&
make $KERNEL_ARCH headers_install INSTALL_HDR_PATH=$SYSROOT/usr &&
echo WOOT

[On digad: 0:19 azoth: 0:13]

STEP 2 binutils

Apply the posix and branch_update-3 patches from CLFS.

../binutils/configure --prefix=/cross-tools \
   --build=${CLFS_HOST} --target=${CLFS_TARGET} \
   --disable-nls --enable-shared --disable-multilib \
   --with-sysroot=$SYSROOT --with-build-sysroot=$SYSROOT &&
make configure-host && make && make install &&
cp -v ../binutils*/include/libiberty.h $SYSROOT/usr/include &&
echo WOOT

[On digad: 2:30 azoth 2:00]

STEP 3 glibc headers

Apply the patches: libgcc_eh, localedef_segfault, i586_chk, and
fixup_for_gcc43.  The first three are from CLFS; the last one corrects the
glibc build so it works with GCC 4.3 (and is already in glibc CVS).

After doing this build, get rid of the glibc-build directory but
keep the source directory around for now:  we will need it again a
little later.

CC=gcc ../glibc/configure --prefix=/usr \
  --host=${CLFS_HOST} --build=${CLFS_TARGET} \
  --disable-sanity-checks --enable-kernel=${KERNEL_VERSION} \
  --with-headers=$SYSROOT/usr/include \
  --with-binutils=/cross-tools/${CLFS_TARGET}/bin &&
make cross-compiling=yes install_root=$SYSROOT install-headers &&
cp -v bits/stdio_lim.h $SYSROOT/usr/include/bits &&
touch $SYSROOT/usr/include/gnu/stubs.h &&
cp -v ../glibc*/nptl/sysdeps/pthread/pthread.h $SYSROOT/usr/include &&
cp -v ../glibc*/nptl/sysdeps/unix/sysv/linux/i386/bits/pthreadtypes.h \
    $SYSROOT/usr/include/bits &&
echo WOOT

[On digad: 0:49 azoth: 0:30]

STEP 4 gcc (bare compiler)

Apply only the posix patch from CLFS.

It seems as though it should be unnecessary to mess around with the GCC
specs here.  It is a cross-compiler; if the wrong libraries are linked in,
presumably the thing will simply not work at all, and this compiler is only
going to be used to build glibc anyway.

After doing this build, don't get rid of ANYTHING -- we will use the same
build directory later on after we use the bare compiler from here to create
the startup files that are needed to get libgcc compiled.  (If you do
delete the gcc-build directory, don't panic, it will just take a few
minutes to rebuild the bare compiler before the libgcc build happens.)

The LDFLAGS_FOR_TARGET and CPPFLAGS_FOR_TARGET are from gcc bug #35532 --
they are mentioned by Carlos O'Donell as the way to use all of the sysroot
framework.

We can't build a full compiler up front, because we need the C runtime
startup files (crti.o and so on) from glibc.  So first we will just build a
bare compiler, which we can use to compile those startup files.

A few GCC and glibc versions ago, the bare compiler produced here was
able to compile the full glibc.  That's no longer the case, alas; these
days, you need the bare compiler (from the all-gcc build target) and also
the support library libgcc (from the all-target-libgcc build target).

After we build the crt?.o files, we can then build libgcc; and then we'll
be able to build glibc.  After that, we'll build the full gcc.

With the x86 to x86 toolchain, I did not have to specify host.  With the
x86 to mips toolchain, I did.  It's OK to specify it for the faux-cross 
toolchain as well.


../gcc/configure --prefix=/cross-tools \
  --build=${CLFS_HOST} --host=${CLFS_HOST} --target=${CLFS_TARGET} \
  --disable-multilib \
  --disable-nls --disable-shared \
  --disable-libmudflap --disable-libssp \
  --disable-threads --enable-languages=c \
  --with-sysroot=$SYSROOT --with-build-sysroot=$SYSROOT &&
export LDFLAGS_FOR_TARGET="--sysroot=$SYSROOT" &&
export CPPFLAGS_FOR_TARGET="--sysroot=$SYSROOT" &&
make all-gcc && make install-gcc &&
echo WOOT

[On digad: 6:36 azoth: 4:28]


STEP 5 glibc (startup files)

If you kept around the source directory from step 3, just use it again
here.  If not, remember to apply the patches: libgcc_eh,
localedef_segfault, i586_chk, and fixup_for_gcc43.  

I don't know how to get the glibc build process just to process the csu
subdirectory and then stop.  So try building the entire library; it will
crash when trying to do a build in the elf directory, and then we can put
the important startup files where gcc expects them.

If you want, you can interrupt the build with ctrl-C a minute or so into
the build, after the crt?.o files have been created -- there's no need to
wait for the build to fail on its own.



UPDATE: that command works well enough to get the startup files built on an
x86-to-x86 build; it may have failed on the mips build only for
environmental reasons (i.e. I may have screwed something up.)  It is worth
trying!

What happened on the x86 attempt is that it built the three startup files
and then quit because it did not know how to build iconv/stamp.o.

Here's the build script to use, possibly replacing the "make lib" line with
something more elegant if you are daring:

echo "libc_cv_forced_unwind=yes" > config.cache
echo "libc_cv_c_cleanup=yes" >> config.cache
BUILD_CC="gcc" CC="${CLFS_TARGET}-gcc" \
    AR="${CLFS_TARGET}-ar" RANLIB="${CLFS_TARGET}-ranlib" \
    CFLAGS="${GLIBCFLAG}" \
    ../glibc/configure --prefix=/usr \
    --host=${CLFS_TARGET} --build=${CLFS_HOST} \
    --disable-profile --enable-add-ons \
    --with-tls --enable-kernel=${KERNEL_VERSION} --with-__thread \
    --with-binutils=/cross-tools/bin --with-headers=$SYSROOT/usr/include \
    --cache-file=config.cache &&
make -r -C ../glibc/csu objdir=$(pwd) $(pwd)/csu/crt1.o &&
make -r -C ../glibc/csu objdir=$(pwd) $(pwd)/csu/crti.o &&
make -r -C ../glibc/csu objdir=$(pwd) $(pwd)/csu/crtn.o &&
mkdir -p $SYSROOT/lib &&
cp csu/crt{1,i,n}.o $SYSROOT/lib &&
echo WOOT

[On digad: 0:12]


STEP 6 gcc (libgcc)

If you deleted the gcc and/or gcc-build directories from step 4,
reconstruct them now by doing that step again.  After this, trash the
gcc-build directory; but we will want the gcc source directory one more
time.

After we build and install libgcc, we can get rid of the crt object files
we just built in the previous step.  They're going to be rebuilt anyway
when we do the full glibc build.

make all-target-libgcc && make install-target-libgcc && 
rm -f $SYSROOT/lib/crt{1,i,n}.o &&
echo WOOT

[On digad: 0:49 azoth: 1:42]

STEP 7 glibc

Now we have a usable GCC, complete with libgcc, and we can build glibc at
last!  Use the same glibc source directory as before, or re-apply all the
patches that were used previously; but use a fresh glibc-build directory.


echo "libc_cv_forced_unwind=yes" > config.cache
echo "libc_cv_c_cleanup=yes" >> config.cache
BUILD_CC="gcc" CC="${CLFS_TARGET}-gcc" \
    AR="${CLFS_TARGET}-ar" RANLIB="${CLFS_TARGET}-ranlib" \
    CFLAGS="$GLIBCFLAG" \
    ../glibc/configure --prefix=/usr \
    --host=${CLFS_TARGET} --build=${CLFS_HOST} \
    --disable-profile --enable-add-ons \
    --with-tls --enable-kernel=${KERNEL_VERSION} --with-__thread \
    --with-binutils=/cross-tools/bin --with-headers=$SYSROOT/usr/include \
    --cache-file=config.cache &&
make && 
make install_root=$SYSROOT install && 
echo WOOT

[On digad: 14:07 azoth: 11:00]


STEP 8 gcc (full compiler)

Now we are going to build the full gcc cross-compiler.  The point of this
compiler is to build the temporary tools (under /tools) that will allow us
to build the final LFS system.  When we're using those tools to build the
final system, we want to do a native build of everything, including glibc,
so we want those tools to be independent of any filesystem locations that
will still be present in the final system.  In particular, this includes
/lib.

When the standard GNU toolchain builds an executable, it always links it
against the dynamic link library (which is /lib/ld-linux.so.2).  That's
normally fine, but we want the programs we build under /tools to be
entirely independent of /lib.  So we need to adjust our cross-toolchain so
that the programs it builds look in /tools/lib for their libraries.
Alternatively, we could build everything under /tools as a static
executable, so they would be self-contained and not need any shared
libraries at all; but that option isn't well-supported by glibc.  (Maybe if
we changed the cross-toolchain to be uClibc-based, instead of glibc-based,
we could get that to work.)

We're going to try to adjust things after the build, instead of
applying additional patches now.

../gcc/configure --prefix=/cross-tools \
  --build=${CLFS_HOST} --host=${CLFS_HOST} --target=${CLFS_TARGET} \
  --disable-multilib \
  --disable-nls --enable-shared \
  --enable-languages=c,c++ --enable-__cxa_atexit \
  --enable-c99 --enable-long-long --enable-threads=posix \
  --with-sysroot=$SYSROOT --with-build-sysroot=$SYSROOT &&
export LDFLAGS_FOR_TARGET="--sysroot=$SYSROOT" &&
export CPPFLAGS_FOR_TARGET="--sysroot=$SYSROOT" &&
make AS_FOR_TARGET="${CLFS_TARGET}-as" LD_FOR_TARGET="${CLFS_TARGET}-ld" &&
make install &&
echo WOOT

[On digad: 11:28 azoth: 11:07]

Wow, it worked.  I didn't expect that to happen.


Now!  We have a couple of options.  First, we can call our
cross-toolchain done and celebrate victory.  Second, we can use
the full compiler we just built to rebuild glibc.

"Why would we do that?!" you ask.

Well, there are some things that didn't get built earlier in the
glibc build, probably because we didn't have some support
libraries like libgcc_eh.  In particular, we don't have programs
like ldd.  We don't strictly need them, but you may want to
rebuild glibc on general principles.  If so, do NOT apply the
libgcc_eh patch!

If you don't want to rebuild glibc, then proceed to:

STEP 9 Adjusting The Toolchain

Spec file editing is a dark art.  You can read all about it in
gcc.info, though, so it's not as intractably dark an art as
building a cross-toolchain from source.

There are specs built into gcc these days (rather than present as
an actual file called specs); you can display them with "gcc
-dumpspecs".  If you put a modified specs file in the same
directory as libgcc.a, then that overrides the built-in specs.

The spec we want to change is the "dynamic-linker" spec.

So:

$CC -dumpspecs | sed -e 's@/lib/ld@/tools/lib/ld@g' > \
   $(dirname $($CC --print-libgcc-file-name))/specs

Now the binaries built in the next chapter, when we are
constructing the temporary tools, will seek the dynamic linker
under /tools just like we want them to.

