PART 1:  Cross-build

a. an NFS-root-mountable filesystem that starts a telnetd and
  gives access to the hard disk
b. a chroot-able tarball to be installed on the internal disk
c. a TRX image containing a kernel that mounts the NFS-root filesystem

Can be automated with anything we please.  I like ruby, personally.

After part 1, the user manually sets up an NFS server, installs the TRX
image using the BIG ORANGE BUTTON rescue mode; boots the device, notes the
mounting of the NFS-root filesystem, telnets to the device, fdisk,
mke2fs's, mkswap, mount, and untar 1b from above.  Then chroots to the
internal disk filesystem.

We could provide scripts to assist in that stuff, but I do not think it is
justified effort.  That stuff is not hard and much of it is open to
customization by the user.

PART 2:  Native Build

Goal:  build simple system using the tools in /tools.

(Basically this is an LFS base system, with some extensions for stuff we need
like openssl, openssh, etc)

This can be automated with bash.  We don't have anything but bash at the
beginning of this process.  We could extend part1 to include ruby in the
chroot bundle, though.

We can also go ahead and build ruby (or whatever else we need) as part of
this process.

PART 3:  Make System Bootable

This is much more involved than usual because we don't have access to a
"normal" bootloader -- the only stage-1 bootloader we can use is CFE, and
CFE doesn't give access to the hard disk.

a. TRX image maintenance utilities
b. A real runtime kernel
c. A uClibc-based toolchain
d. Utilities for the initial (flash) root filesystem (using uClibc)
e. the actual TRX image to be installed in the flash region

This can be automated with anything we please, say for example Ruby.

At this point the user gets the flash image off the system over the 
network somehow.  Maybe by exiting the chroot and copying it to the 
NFS-mounted filesystem.

Now the user usese the BIG ORANGE BUTTON again, this time to install the 
TRX image built natively on the system.

Smoke test.

Have a drink
  ...or...
Get blotto.  Wait until tomorrow.  Go back to step 1.

-------------

automating the process -- fundamentally what we are doing is running a big
pile of shell commands in a particular order, and bailing out if something
fails.  That can be done in bash or ruby (or anything else).  Is ruby apt
to be better than bash?  I'm inclined to think so...it has objects, after
all.

