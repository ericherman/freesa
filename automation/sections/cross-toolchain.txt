This section describes how to build a GNU cross-toolchain that
runs on x86 machines and constructs programs that will run on
MIPS boxes.  The result is composed of current stable versions of
all toolchain components as of May 2008.  That means:

[[package-list]]

A "toolchain" is the set of all of the programs and libraries
required to transform source code into executable programs that
will actually work.  In this case, we are building a C and C++
toolchain:  it will be able to construct programs from C and C++
source code.

The toolchain being built here consists of:  a _compiler_, which
takes C or C++ source code and translates it into assembly
language code; an _assembler_, which takes that assembly code and
translates it into binary object code; a _linker_, which combines
object code produced by the assembler and additional object code
contained in libraries and produces executable programs; and an
implementation of the standard C and C++ libraries, which specify
a large number of functions that may be used by any C or C++
program.

In the GNU toolchain, the compilers are +gcc+ (for C source code)
and +g+++ (for C++ source code), both of which are contained in
the GNU Compiler Collection (gcc) distribution; the assembler and
linker are +as+ and +ld+, and are contained (along with other
programs that operate on object code files) in the binutils
(binary utilities) distribution; and the standard C library is
distributed separately as glibc.  (The standard C++ library is
actually distributed within the gcc distribution.)

Since glibc is a rather large library -- 115 megabytes of source
code, producing shared library files that are in the megabytes --
it is not very well-suited to building programs that must fit in
a compact space such as the 2 MB flash chip in the WL-700gE.  For
those programs, an alternative C library, "uClibc," is more
appropriate.  An uClibc-based toolchain can be produced using a
slight variant of the normal glibc instructions.

A "cross-toolchain" is much like a normal, or "native,"
toolchain.  The difference is that a cross-toolchain runs on a
computer of one type (the "host" system) but builds programs that
will run on a different type (the "target" system).  For the
Freesa project, for example, we use common Intel Core or Pentium
computers to build software that will run on the Asus WL-700gE,
which uses a MIPS-architecture CPU.  (Once you have a working
MIPS native toolchain, which is one of the components of the
final Freesa system, you can build new versions of the Freesa
software using that toolchain instead of the cross-toolchain, if
you wish.)

This same process can be used to build a "faux" cross-toolchain:
a set of tools that runs on Intel computers and builds programs
that will also run on Intel systems, but using the
cross-toolchain build process instead of building a native
toolchain.  That seems pointless, but is useful if you want to
ensure that you are building all system components from source
code and those components are entirely independent of the
original build system.  It's also necessary if you have a
glibc-based system but you want to produce programs that will be
linked against the uClibc library instead.

To build a GNU cross-toolchain, we pass "host," "target," and
"build" options to the "configure" scripts (produced using the
autotools programs) of the toolchain components.  The values
assigned to these options are "target triples" that describe the
computer architecture and operating system for the host and
target systems; for example, i686-pc-linux-gnu is the "target
triple" that corresponds to Intel machines with a CPU more recent
than a Pentium Pro, running GNU/Linux; the "pc" component of the
name doesn't actually do anything, as far as we know.

Different combinations of "host," "target," and "build" are used
for different toolchain components.  Once the cross-toolchain is
built, most programs built using it will be configured with
"build" set to the host computer and "host" set to the target
computer.

The cross-toolchain built here uses the sysroot framework, as
recommended by the GCC developers.  (The upstream source from
which we've adapted these instructions, Cross Linux From Scratch,
still uses non-sysroot builds.  We think that it is a better idea
to use the sysroot framework, because the toolchain developers
recommend doing so.)  The idea behind a sysroot toolchain is:  a
directory on the host system (the "sysroot" directory) is set up
to contain a subset of the root filesystem of the target system:
+/bin+, +/lib+, +/usr/lib+, +/etc+, that sort of thing.  Header
files and libraries will be used only from the sysroot location,
not from the normal host system locations.

EDITPOINT

Flags for building an x86-to-x86 "faux" cross-toolchain -- put
these in the building user's .bashrc:

export CLFS=/home/clfs
export LC_ALL=POSIX
export PATH=/cross-tools/bin:/bin:/usr/bin
unset CFLAGS
unset CXXFLAGS
export CLFS_HOST=i686-cross-linux-gnu
export CLFS_TARGET=i686-pc-linux-gnu
export SYSROOT=$CLFS
export KERNEL_VERSION=2.6.25
unset KERNEL_ARCH
export GLIBCFLAG="-march=$(cut -d- -f1 <<< $CLFS_TARGET) -mtune=generic -g -O2"

Flags for building an x86-to-mipsel cross-toolchain:

export CLFS_TARGET=mipsel-unknown-linux-gnu
export KERNEL_VERSION=2.6.23
export GLIBCFLAG="-g -O2"
export KERNEL_ARCH="ARCH=mips"

steps: glibc
 - [[gmp]]
 - [[mpfr]]
 - [[linux: sysroot headers]]
 - [[binutils]]
 - [[glibc: headers]]
 - [[gcc: bare compiler]]
 - [[glibc: startup files]]
 - [[gcc: libgcc]]
 - [[glibc: full glibc]]
 - [[gcc: full compiler]]

steps: uclibc
 - [[gmp]]
 - [[mpfr]]
 - [[linux: sysroot headers]]
 - [[binutils]]
 - [[uclibc: headers]]
 - [[gcc: bare compiler]]
 - [[uclibc: library]]
 - [[gcc: full compiler]]
 - [[uclibc: utilities]]

