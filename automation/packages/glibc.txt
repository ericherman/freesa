full-name: GNU libc
name: glibc
version: 2.9

glibc is the standard C library produced as part of the GNU
project.  It contains the implementation for all of the functions
that are assumed to be available in C programs: +printf+ and so
on.  It also provides a dynamic loader, which almost all programs
use to find shared libraries at runtime, and a few miscellaneous
utility programs.

Since all C and C++ programs link against the C library, glibc is
by far the most deeply-embedded component of a GNU/Linux
installation.  Upgrading the Linux kernel is a relatively trivial
operation compared to upgrading the C library installed on a
computer.

There are alternative C libraries that can be used instead of
glibc.  However, glibc is the standard C library used by the vast
majority of GNU/Linux systems; using an alternative library like
uClibc as the primary C library may cause problems somewhere
down the line.

[This next section might belong in a phase like 'cross-glibc
headers' since it is only accurate during the build of the
initial cross-glibc, not the final system glibc. -ed.]

Note that we are building our glibc with a "minimum kernel
version" set to the version of the actual runtime kernel that we
will use to construct the final system using the programs in the
temporary tools directory.  According to the glibc documentation,
the higher the kernel version number, the less unnecessary
compatibility code is built into the C library.  It's kind of
unnecessary to worry about optimizing the glibc here that way,
since it won't wind up on the final system, but it won't hurt
anything and is good practice in general.

The libgcc_eh patch that we apply is very important:  it allows
glibc to be built without the libgcc_eh library provided as part
of GCC.  That library is not built except during a full GCC
build, but isn't actually required -- even though the standard
glibc build process crashes if it is not available.  (Perhaps the
functions that are normally provided in libgcc_eh are built into
one of the other GCC libraries when a partial GCC build is done.)
The patch allows the glibc build to complete successfully even if
libgcc_eh is not available.

The other patch we apply prevents the localedef function from
failing with segmentation faults on some machine architectures.
It's probably not particularly important for our purposes, but it
doesn't hurt anything to apply it.

patches:
 - libgcc_eh-1
 - localedef_segfault-1

phase: headers

build-dir: ../build-glibc

configure-commands:
 - CC=gcc PARAM[SOURCE_DIR]/configure --prefix=/usr
    --host=PARAM[HOST] --build=PARAM[TARGET]
    --disable-sanity-checks --enable-kernel=PARAM[KERNEL_VERSION]
    --with-headers=PARAM[SYSROOT]/usr/include
    --with-binutils=PARAM[TOOL_PREFIX]/PARAM[TARGET]/bin

make-commands:

test-commands:

install-commands:
 - make cross-compiling=yes install_root=PARAM[SYSROOT] install-headers
 - cp -v bits/stdio_lim.h PARAM[SYSROOT]/usr/include/bits
 - touch PARAM[SYSROOT]/usr/include/gnu/stubs.h
 - cp -v PARAM[SOURCE_DIR]/nptl/sysdeps/pthread/pthread.h 
     PARAM[SYSROOT]/usr/include
 - cp -v PARAM[SOURCE_DIR]/nptl/sysdeps/unix/sysv/linux/i386/bits/pthreadtypes.h
     PARAM[SYSROOT]/usr/include/bits


phase: startup files

In this phase we just build the startup files that we need in
order to build libgcc.  We'll build the rest of glibc later, once
we have libgcc.

build-dir: ../build-glibc-2

configure-commands:
 - echo "libc_cv_forced_unwind=yes" > config.cache
 - echo "libc_cv_c_cleanup=yes" >> config.cache
 - BUILD_CC="gcc" CC="PARAM[TARGET]-gcc"
      AR="PARAM[TARGET]-ar" RANLIB="PARAM[TARGET]-ranlib"
      CFLAGS="PARAM[GLIBCFLAG]"
      PARAM[SOURCE_DIR]/configure --prefix=/usr
      --host=PARAM[TARGET] --build=PARAM[HOST]
      --disable-profile --enable-add-ons --with-tls
      --enable-kernel=PARAM[KERNEL_VERSION] --with-__thread
      --with-binutils=PARAM[TOOL_PREFIX]/bin
      --with-headers=PARAM[SYSROOT]/usr/include
      --cache-file=config.cache

make-commands:
 - make -r -C PARAM[SOURCE_DIR]/csu objdir=$(pwd) $(pwd)/csu/crt1.o
 - make -r -C PARAM[SOURCE_DIR]/csu objdir=$(pwd) $(pwd)/csu/crti.o
 - make -r -C PARAM[SOURCE_DIR]/csu objdir=$(pwd) $(pwd)/csu/crtn.o

test-commands:

install-commands:
 - mkdir -p PARAM[SYSROOT]/lib
 - bash -c 'cp csu/crt{1,i,n}.o PARAM[SYSROOT]/lib'


phase: full glibc

Now we have a usable GCC, complete with libgcc, and we can build
glibc at last!

build-dir: ../build-glibc-3

configure-commands:
 - echo "libc_cv_forced_unwind=yes" > config.cache
 - echo "libc_cv_c_cleanup=yes" >> config.cache
 - BUILD_CC="gcc" CC="PARAM[TARGET]-gcc"
      AR="PARAM[TARGET]-ar" RANLIB="PARAM[TARGET]-ranlib"
      CFLAGS="PARAM[GLIBCFLAG]"
      PARAM[SOURCE_DIR]/configure --prefix=/usr
      --host=PARAM[TARGET] --build=PARAM[HOST]
      --disable-profile --enable-add-ons --with-tls
      --enable-kernel=PARAM[KERNEL_VERSION] --with-__thread
      --with-binutils=PARAM[TOOL_PREFIX]/bin
      --with-headers=PARAM[SYSROOT]/usr/include
      --cache-file=config.cache

test-commands:

install-commands:
 - make install_root=PARAM[SYSROOT] install

phase: temporary tool glibc

The glibc built as part of the cross-toolchain builds executables
with the standard runtime linking paths -- that is, it links
programs against +/lib/ld-linux.so.2+, and that +ld-linux.so.2+
library looks for other libraries (like +libc.so.6+) in +/lib+
and +/usr/lib+.  That's the right assumption when the sysroot
directory structure is copied to the root directory of the
runtime device, but that's not the way we want to do things with
our from-source bootstrap:  we want the temporary tools to be
self-contained within the temporary tools directory, so they
don't conflict with the files we build as part of the file
system.  That means they must link against the
+lib/ld-linux.so.2+ in the temporary tools directory, and that
+ld-linux.so.2+ library must look for other libraries only in the
+lib and +usr/lib+ directories under that directory.

The temporary tools location needs to be present with the same
absolute path on both the build system and the final runtime
system.

We can control the dynamic linker location easily by overriding
the default GCC +dynamic_linker+ spec, but we don't know how to
change the runtime library lookup path used by the dynamic
linker we've already built.

The other reason we want to build an entirely new glibc here is
that this is the first time we're building glibc when the
libgcc_eh library is actually available.

build-dir: ../build-glibc-4

configure-commands:
 - echo "libc_cv_forced_unwind=yes" > config.cache
 - echo "libc_cv_c_cleanup=yes" >> config.cache
 - BUILD_CC="gcc" CC="PARAM[TARGET]-gcc"
      AR="PARAM[TARGET]-ar" RANLIB="PARAM[TARGET]-ranlib"
      CFLAGS="PARAM[GLIBCFLAG]"
      PARAM[SOURCE_DIR]/configure --prefix=PARAM[TMPTOOLS]
      --host=PARAM[TARGET] --build=PARAM[HOST]
      --disable-profile --enable-add-ons --with-tls
      --enable-kernel=PARAM[KERNEL_VERSION] --with-__thread
      --with-binutils=PARAM[TOOL_PREFIX]/bin
      --with-headers=PARAM[TMPTOOLS]/include
      --cache-file=config.cache

test-commands:

The +install_root+ is specified as +/+ for this installation
because that causes the installation to occur directly in the
prefix specified in configure, rather than a subdirectory of it.
Since the build user can write to the temporary tools directory,
this winds up doing the right thing.

install-commands:
 - make install_root=/ install
