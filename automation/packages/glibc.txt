full-name: GNU libc
name: glibc
version: "2.16"

glibc is the standard C library produced as part of the GNU
project.  It contains the implementation for all of the functions
that are assumed to be available in C programs: +printf+ and so
on.  It also provides a dynamic loader, which almost all programs
use to find shared libraries at runtime, and a few miscellaneous
utility programs.

Since all C and C++ userspace programs link against the C
library, glibc is by far the most deeply-embedded component of a
GNU/Linux installation.  Upgrading the Linux kernel is a
relatively trivial operation compared to upgrading the C library
installed on a computer.

There are alternative C libraries that can be used instead of
glibc.  However, glibc is the standard C library used by the vast
majority of GNU/Linux systems; using an alternative library like
uClibc as the primary C library may cause problems somewhere
down the line.

[This next section might belong in a phase like 'cross-glibc
headers' since it is only accurate during the build of the
initial cross-glibc, not the final system glibc. -ed.]

Note that we are building our glibc with a "minimum kernel
version" set to the version of the actual runtime kernel that we
will use to construct the final system using the programs in the
temporary tools directory.  According to the glibc documentation,
the higher the kernel version number, the less unnecessary
compatibility code is built into the C library.  It's not really
necessary to worry about optimizing the glibc here that way,
since it won't wind up on the final system, but it won't hurt
anything and is good practice in general.

The libgcc_eh patch that we apply is very important:  it allows
glibc to be built without requiring the libgcc_eh library
provided as part of GCC.  That library is only built during a
full GCC build, which we can't do until after we have a working
glibc, so it introduces a cyclical dependency into the toolchain
build process.  However, even though the standard glibc build
process crashes when libgcc_eh is not available, the library is
not actually required to do a glibc build.  The patch modifies
the build machinery so that the glibc build can complete
successfully even when there is no libgcc_eh available.

Another patch we apply prevents the localedef function from
failing with segmentation faults on some machine architectures.
It's probably not particularly important for our purposes, but it
doesn't hurt anything to apply it.

The final patch corrects a configure script so that glibc can be
built using gcc 4.5.0 or later -- without it, the glibc configure
script reports that cpuid.h exists but cannot be used.

patches:
 - libgcc_eh-1
 - localedef_segfault-1

phase: sysroot glibc

This builds a completely standard sysroot libc.

build-dir: ../build-glibc-1

configure-commands:
 - echo "libc_cv_forced_unwind=yes" > config.cache
 - echo "libc_cv_c_cleanup=yes" >> config.cache
 - echo "libc_cv_gnu89_inline=yes" >> config.cache
 - echo "libc_cv_ctors_header=yes" >> config.cache
 - echo "libc_cv_ssp=no" >> config.cache
 - BUILD_CC="gcc" CC="PARAM[TARGET]-gcc" AR="PARAM[TARGET]-ar" 
      RANLIB="PARAM[TARGET]-ranlib" CFLAGS="PARAM[GLIBCFLAG]"
      PARAM[SOURCE_DIR]/configure --prefix=/usr
      --host=PARAM[TARGET] --build=PARAM[HOST]
      --disable-profile --enable-add-ons --with-tls
      --enable-kernel=PARAM[KERNEL_VERSION] --with-__thread
      --with-binutils=PARAM[TOOL_PREFIX]/bin
      --with-headers=PARAM[SYSROOT]/usr/include
      --cache-file=config.cache

test-commands:

install-commands:
 - make install_root=PARAM[SYSROOT] install

phase: temporary tool glibc

The glibc built as part of the cross-toolchain builds executables
with the standard runtime linking paths -- that is, it links
programs against +/lib/ld-linux.so.2+, and that +ld-linux.so.2+
library looks for other libraries (like +libc.so.6+) in +/lib+
and +/usr/lib+.  That's the right assumption when the sysroot
directory structure is copied to the root directory of the
runtime device, but that's not the way we want to do things with
our from-source bootstrap:  we want the temporary tools to be
self-contained within the temporary tools directory, so they
don't conflict with the files we build as part of the file
system.  That means they must link against the
+lib/ld-linux.so.2+ in the temporary tools directory, and that
+ld-linux.so.2+ library must look for other libraries only in
+lib+ and +usr/lib+ under that directory.

The temporary tools location needs to be present with the same
absolute path on both the build system and the final runtime
system.

We can control the dynamic linker location easily by overriding
the default GCC +dynamic_linker+ spec, but we don't know how to
change the runtime library lookup path used by the dynamic linker
we've already built.

The other reason we want to build an entirely new glibc here is
that this is the first time we're building glibc when gcc is
available in its normal configuration, with a shared libgcc,
libgcc_eh, and so on.

build-dir: ../build-glibc-2

configure-commands:
 - echo "libc_cv_forced_unwind=yes" > config.cache
 - echo "libc_cv_c_cleanup=yes" >> config.cache
 - echo "libc_cv_gnu89_inline=yes" >> config.cache
 - BUILD_CC="gcc" CC="PARAM[TARGET]-gcc" AR="PARAM[TARGET]-ar" 
      RANLIB="PARAM[TARGET]-ranlib" CFLAGS="PARAM[GLIBCFLAG]"
      PARAM[SOURCE_DIR]/configure --prefix=PARAM[TMPTOOLS]
      --host=PARAM[TARGET] --build=PARAM[HOST]
      --disable-profile --enable-add-ons --with-tls
      --enable-kernel=PARAM[KERNEL_VERSION] --with-__thread
      --with-binutils=PARAM[TOOL_PREFIX]/bin
      --with-headers=PARAM[TMPTOOLS]/include
      --cache-file=config.cache

test-commands:

The +install_root+ is specified as +/+ for this installation
because that causes the installation to occur directly in the
prefix specified in configure, rather than a subdirectory of it.
This winds up doing the right thing.  In glibc 2.15, this got a
little more complicated:  the installation winds up trying to
clobber a system file when +install_root+ is set to +/+, so it's
also necessary to specify +inst_vardbdir+.

install-commands:
 - make install_root=/ inst_vardbdir=PARAM[TMPTOOLS]/var/db install
