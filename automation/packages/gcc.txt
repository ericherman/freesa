full-name: GNU Compiler Collection
name: gcc
version: 4.4.0
project-url: http://gcc.gnu.org/

GCC is the GNU Compiler Collection.  The most important compiler
in the collection, for purposes of bootstrapping a system, is the
C compiler; but GCC also includes compilers for C++, Fortran,
Java, Ada, and probably other languages as well.

The job of a compiler is to translate source code in a high-level
language into assembler code.  GCC does that, but it also acts as
a driver program that invokes other programs like +as+ and +ld+
(from the binutils package) as necessary to produce libraries and
executables.  GCC as a driver program is configured by a "specs"
file that tells it what other programs to invoke and how to
invoke them.  The specs file format is documented in the GCC
documentation (which is maintained in texinfo format) in section
3.15.

Oh, I almost forgot.  The GCC package also includes the C
pre-processor (+cpp+).

Bootstrapping GCC as part of a cross-toolchain is tricky.  The
only thing that can be built without a working C library (libc)
is a plain compiler, but that compiler won't be able to produce
executable programs:  GCC can only create programs if it has
access to a support library called libgcc.  (That's because
sometimes, when GCC is compiling C code, it generates references
to functions defined in libgcc, rather than assembler code; and
GCC can't produce libgcc unless it has access to some C runtime
startup files -- object files -- the source for which is
distributed as part of the C library rather than GCC itself.)

The C libraries that are useful for our purposes -- glibc and
uClibc -- can't be built unless libgcc is available.  That's
where the trickiness comes from:  we have to produce the bare
compiler, then use it (along with +as+ from the binutils package)
to compile the C runtime files from the C library, then use those
files and the bare compiler to produce libgcc, and then use the
compiler plus libgcc to build the C library itself.  At that
point we can finally build the full GCC.

GCC can be built as part of a cross-toolchain by using the
"sysroot" framework.  To perform a sysroot build, the configure
options +--with-sysroot+ and +--with-build-sysroot+ must be
specified; and when building GCC, the environment variables
LDFLAGS_FOR_TARGET and CPPFLAGS_FOR_TARGET should be set to
+--sysroot=${SYSROOT}+.  At least, that's what Carlos O'Donell
said in a comment on GCC bug #35532.  The documentation on
sysroot builds is not particularly easy to find -- or at least,
it wasn't when this was written.  (If you know where sysroot
builds are documented, please tell us!)

A few dependencies were added to gcc in recent releases (4.3 and
higher):  the GMP and MPFR libraries are required for all
compiler builds, and a few loop optimizations are only available
if the Parma Polyhedra Library (PPL) and a version of the Chunky
Loop Generator using that library (cloog-ppl) are available.
Those latter two aren't hard dependencies, though; you only need
those to be available if you want to enable three specific
optimizations.  (The optimizations in question are
loop-interchange, loop-strip-mine, and loop-block.  It's not
clear to us whether or not those optimizations are particularly
valuable, but we're certainly not worried about them for a
cross-toolchain build.)

No patches are strictly required for gcc.  The one patch we apply
converts an archaic invocation syntax for programs like +head+
and +tail+ to the POSIX-standard syntax.

patches:
 - posix-1

phase: bare compiler

After doing this part of the build, keep the build directory
around; it should be used again when building libgcc.

environment:
 CPPFLAGS_FOR_TARGET: --sysroot=PARAM[SYSROOT]
 LDFLAGS_FOR_TARGET: --sysroot=PARAM[SYSROOT]

build-dir: ../build-gcc

configure-commands:
 - PARAM[SOURCE_DIR]/configure --prefix=PARAM[TOOL_PREFIX]
     --build=PARAM[HOST] --host=PARAM[HOST] --target=PARAM[TARGET]
     --disable-multilib --disable-nls --disable-shared
     --disable-libmudflap --disable-libssp
     --disable-threads --enable-languages=c
     --with-sysroot=PARAM[SYSROOT] --with-build-sysroot=PARAM[SYSROOT]

make-commands:
 - make all-gcc

test-commands:

install-commands:
 - make install-gcc


phase: libgcc

Now we can build and install libgcc, after which we can get rid
of the crt* object files from the C library.  (They're going to be
rebuilt as part of the full C library build.)

environment:
 CPPFLAGS_FOR_TARGET: --sysroot=PARAM[SYSROOT]
 LDFLAGS_FOR_TARGET: --sysroot=PARAM[SYSROOT]

build-dir: ../build-gcc

configure-commands:

make-commands:
 - make all-target-libgcc

test-commands:

install-commands:
 - make install-target-libgcc
 - rm -f PARAM[SYSROOT]/lib/crt{1,i,n}.o


phase: full compiler

Now that we can finally do a full GCC build, we will build both
the C and C++ compilers, and enable multi-threaded code.  Other
than that, the configuration is fairly similar to the partial
builds we've done so far.

build-dir: ../build-gcc-2

environment:
 CPPFLAGS_FOR_TARGET: --sysroot=PARAM[SYSROOT]
 LDFLAGS_FOR_TARGET: --sysroot=PARAM[SYSROOT]

configure-commands:
 - PARAM[SOURCE_DIR]/configure --prefix=PARAM[TOOL_PREFIX]
    --build=PARAM[HOST] --host=PARAM[HOST] --target=PARAM[TARGET]
    --disable-multilib --disable-nls --enable-shared
    --enable-languages=c,c++ --enable-__cxa_atexit
    --enable-c99 --enable-long-long --enable-threads=posix
    --with-sysroot=PARAM[SYSROOT] --with-build-sysroot=PARAM[SYSROOT]

make-commands:
 - make AS_FOR_TARGET="PARAM[TARGET]-as" LD_FOR_TARGET="PARAM[TARGET]-ld"

test-commands:

install-commands:
 - make install
