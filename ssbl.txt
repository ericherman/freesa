After building a uclibc-based native toolchain on the freesa box,
we have to use that toolchain to build all of the stuff that will
wind up in flash (except for the kernel image and kernel modules,
which are built using the normal toolchain).

Previously, the only thing we could get to work was a trx image
containing a kernel and a separate squashfs root filesystem.
These days, though, we can get an initramfs-based early userspace
to work.  That's a better approach:  it means that we only need
the boot loader to load one thing (the kernel image), and no part
of it needs to be writable.  It also means that we can do test
boots of the device without flashing an image at all when using a
serial console, because the CFE can download and boot a kernel
with the root filesystem already attached to it.

We call the flash image "ssbl" because it is the second-stage
boot loader -- CFE does the primary boot; it loads the linux
kernel, which then expands its attached root filesystem archive
into a ramfs and launches the init script from it.  The init
script spins up the hard disk, mounts the root filesystem, and
does the pivot-root mojo that you probably all remember from your
rescue CDs.

The components we need to build the SSBL are:

1. loader.gz, a tiny bootstrap program that loads and decompresses
   the LZMA-compressed kernel file (just like in the net-boot
   kernel)
2. lzma, which is used to LZMA-compress the kernel (also just like
   in the nfs-boot kernel)
3. The "diag" kernel module, used to spin the hard disk in the
   WL-700gE (by activating a GPIO pin)
4. Busybox (which provides all of the programs within the SSBL
   root filesystem)
5. uClibc (which is the libc used by busybox) -- you should
   already have built a uClibc toolchain, which includes this
6. An init script that does the stuff we mentioned above, about
   loading modules and doing the pivot-root and so on
7. trx, which assembles the loader.gz and kernel into a
   flashable TRX image (again, just like when you built the
   net-boot firmware)
8. The linux kernel (which includes the root filesystem as an
   initramfs)

The kernel build has to happen last because the root filesystem
is created and attached as part of the kernel build. However, it
has to be /configured/ earlier so that the diag module (and other
modules that are loaded after boot, like the IDE drivers) can be
built.

This file describes how to build and assemble all that stuff.

Under normal circumstances, we recommend that you build all of
this stuff in a net-booted and NFS-root-filesystem'ed freesa box,
so that you can use the final native toolchain and uClibc
toolchain for all the compilations.  If you're cross-compiling
the SSBL on a different box, note that the only components that
actually run on the build system are lzma-alone and trx.
Everything else needs to be built with a cross-compiler.

The way we figured out how to do all this was by
reverse-engineering the OpenWRT build process. If we haven't
mentioned this earlier, the OpenWRT guys are awesome.  That's not
a very hard thing to do, because make usually announces what it's
doing as it's doing it; however, some parts of the OpenWRT build
use "make -s" to stop echoing recipes.  We used a modified GNU
Make that ignores the "silent" option entirely.

Ready?  LET'S GO.

1. linux configuration and modules

We need to configure the kernel and build modules before we build
the actual kernel per se.  The kernel configuration we use is in
the config directory as kernel-3.0.12-ssbl1.

If cross-compiling from a different box, use

CROSS="ARCH=mips CROSS_COMPILE=mipsel-unknown-linux-uclibc-"

(otherwise, don't set CROSS.)

make $CROSS oldconfig
make $CROSS headers_check
make $CROSS headers_install
make $CROSS modules_prepare
make $CROSS modules

We'll need a couple of modules during the SSBL boot process --
otherwise, freesa won't be able to access the hard disk.  Go
ahead and copy them to where we'll want them:

mkdir -p ${SSBL}/modules
cp drivers/ide/{ide-core,ide-gd_mod}.ko ${SSBL}/modules
cp drivers/ide/aec62xx.ko ${SSBL}/modules

TODO: the ide and aec62xx modules are old and deprecated.  There
may be up-to-date drivers that will work -- that's something
we'll want to try.

See all those kernel modules that got built?  If you're not doing
a native build, you'll need to move them to the hard disk in the
freesa box.  First, install them to a temporary directory:

make $CROSS INSTALL_MOD_PATH=/tmp/freesa-mods modules_install

(The "depmod" part will probably fail, but don't worry about
that.)

If you did a native build like you should have, just do 
"make modules_install" and be done with it.

Then tar up the contents of that temporary directory and put them
on the NFS server; and then use the freesa box command prompt to
extract them from the NFS root filesystem to the chrooted hard
disk filesystem (which will be the freesa box root filesystem in
just a few minutes).

You're NOT done with the kernel source yet!  Don't mess with it!

2. loader.gz

Look at section 1.c in firmware-build-notes.txt.

3. lzma

Look at section 1.a in firmware-build-notes.txt.  (There's no
particular reason we're going in a different order this time.)

4. diag.ko

Start by going to your linux kernel source directory.  Note that
the magic incantation to build out-of-tree kernel modules has
changed sometime between 2.6.20 and 3.0...

pushd ${FREESAGIT}/diag
make $CROSS -C $(dirs +1) M=$PWD
cp diag.ko ${SSBL}/modules
popd

5. Busybox

Use busybox 1.19.3, or whatever is latest-stable when you feel
experimental.  There's a config file in configs you can start
with.

The prefix where Busybox will install itself is in the
configuration file, and you should set it to be the ssbl build
directory -- where you assemble everything that will become part
of the initramfs.

If you are going to put any executable programs in the ssbl that
aren't part of busybox, you should link busybox dynamically and
include the required .so files in SSBL.  However, we don't think
there's any point in doing that, so we do a static build.

g. uClibc

We don't actually need to do anything here, since we statically
linked busybox and don't have any other binaries.  Just let your
eyes slide down to the next step.

7. init

In addition to setting ROOT properly in the init-ssbl script, and
copying it to /tmp/ssbl/init, you need to set up some directories
there.

mkdir -p ${SSBL}/dev
mkdir -p ${SSBL}/mnt
mkdir -p ${SSBL}/proc
mkdir -p ${SSBL}/sys

Now that everything else is in the temporary SSBL directory, you
need to create a couple of node files.  Normally, only root can
do this!  Sorry about that.

sudo mknod -m 600 ${SSBL}/dev/console c 5 1
sudo mknod -m 666 ${SSBL}/dev/null c 1 3

4. Linux kernel

We couldn't build the kernel before because we needed to set up
the root filesystem contents (which are attached to the kernel as
a CPIO archive and expanded into the initramfs after it's created).

make $CROSS 

The kernel itself is vmlinux.  We need to convert it to a raw
binary like we did with the nfs-boot kernel:


objcopy -O binary -R .reginfo -R .notes -R .note -R .comment \
  -R .mdebug -R .note.gnu.build-id -S vmlinux fixed-vmlinux

(or the cross-objcopy if you're cross-compiling)

Now, use the lzma_alone program you built in step 2 to compress
the kernel:

cat fixed-vmlinux | 
    lzma_alone e -si -so -eos -lc1 -lp2 -pb2 > vmlinux.lzma

This should all be hauntingly familiar.
 
Put vmlinux.lzma somewhere you'll be able to find it later.

9. trx

Look at section 1b of firmware-build-notes.txt.

Now we can build the actual ssbl image.  Gather all your
components to one place and:

trx -o freesa-ssbl.trx -f loader.gz -f vmlinux.lzma 

Now reboot freesa with that orange EZ-setup button pressed, and
use TFTP to send it freesa-ssbl.trx for flashing.  Remember to
set *binary* transfer mode.

Reboot, and ... sniff, sniff?  Is that smoke?

