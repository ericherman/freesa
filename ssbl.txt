After building a uclibc-based native toolchain on the freesa box,
we have to use that toolchain to build all of the stuff that will
wind up in flash (except for the kernel image and kernel modules,
which are built using the normal toolchain).

-- NOTE IMPORTANT CHANGE IN PLANS --

Because it seems to be surprisingly difficult to set up a flash
image that has a kernel and separate squashfs image, we are going
to try using initramfs, as described in
Documentation/early_userspace/README (in the kernel source).
OpenWRT already contains a patch that causes the initramfs
archive to be compressed with LZMA rather than gzip.

The way that initramfs works is: a CPIO-format archive is
attached to the kernel.  At boot time, rather than mounting a
root filesystem normally, the kernel notices that it has an
initramfs archive attached to it; it decompresses the archive and
extracts its contents into a ramfs.  Then it runs the program
/init (which it expects to have been created during the archive
extraction).

There are a couple of benefits of this approach.

First:  the kernel doesn't have to find a separate filesystem
partition on the flash chip; when the kernel is loaded from flash
(or TFTP), the initramfs archive is loaded as part of it.

Second:  we don't have to be root for any part of the kernel
image build, because we can tell the kernel to add node entries
for /dev/null and /dev/console to the initramfs archive.

Third:  we don't need to build squashfs-lzma at all, and the
kernel doesn't need squashfs support to be built in at all.

Fourth:  we may be able to test the full boot using TFTP, rather
than needing to flash a TRX image onto the box to test the boot.

(I guess there are several benefits, rather than a couple.)

The other consequence of this approach is that we won't have a
separate "ssbl" user at all -- instead, the stuff that will live
in the ssbl will be built as the kernel user, along with the
kernel per se.  The kernel build process becomes:

* Unpack the kernel sources
* Compile busybox
* Install busybox, uclibc runtime files, and everything else we
  need into the initramfs source directory
* Build the kernel itself (which will construct the initramfs
  archive automatically).

1. Prepare the ssbl directory

This contains the same stuff that the squashfs was going to
contain, except that it does not contain device nodes.

- build busybox
- install busybox to a "ssbl" directory (the contents of which
  will become the root directory of the initramfs)
- ensure that the init program is at exactly "ssbl/init"
- create a file "ssbl-nodes.txt" with directives to create the
  /dev/console and /dev/null nodes
- configure the kernel, giving it CONFIG_INITRAMFS_SOURCE
  including both "ssbl" and "ssbl-nodes.txt". (Don't know what
  the base directory for these source locations is. Maybe give it
  absolute paths.)
  - also configure INITRAMFS_ROOT_UID and INITRAMFS_ROOT_GID to
    be the kernel user UID and GID, so that the stuff in the
    initramfs is owned by root:root
- build the "diag.ko" module and other modules needed to boot the
  system, if any (see =MODULES= below)
- build the LZMA SDK so that the kernel can lzma-compress the
  CPIO image (the same thing will be used to compress the kernel
  image itself)
- build the kernel

ssbl-nodes.txt should contain:
----
dir /dev 0755 0 0
nod /dev/console 600 0 0 c 5 1
nod /dev/null 666 0 0 c 1 3
----

After building the kernel and lzma-compressing it, ensure that it
is 1728kb or less in size.  (Actually it needs to be a little
less than 1728kb, since lzma-loader must also fit.)  If so,
package it as a trx:

1) lzma the kernel

2) build lzma-loader

3) build trx

4) create the trx file:

    trx -o woohoo.trx -f loader.gz -f vmlinux.lzma

5) flash that sucker.

= SCRIPTY PART =

This is how to build the ssbl, more or less.

export SSBL=/tmp/ssbl
export FREESAGIT=~/gits/freesa

To build modules before the kernel image is built:

prepare the kernel source and build modules with:

(the ARCH and CROSS_COMPILE are only needed if cross-compiling of
course)

make ARCH=mips CROSS_COMPILE=mipsel-unknown-linux-uclibc- oldconfig
make ARCH=mips CROSS_COMPILE=mipsel-unknown-linux-uclibc- prepare scripts
make ARCH=mips CROSS_COMPILE=mipsel-unknown-linux-uclibc- modules
cp drivers/ide/{aec62xx,ide-core,ide-gd_mod}.ko ${SSBL}/modules

# Then, for external modules:

pushd ${FREESAGIT}/diag
make ARCH=mips CROSS_COMPILE=mipsel-unknown-linux-uclibc- KERNELDIR=$(dirs +1)
cp diag.ko ${SSBL}/modules
popd

cat > ${SSBL}-nodes.txt <<HERE
dir /dev 0755 0 0
nod /dev/console 600 0 0 c 5 1
nod /dev/null 666 0 0 c 1 3
HERE

# Finish preparing ssbl (create directories, install init), then:

make ARCH=mips CROSS_COMPILE=mipsel-unknown-linux-uclibc- vmlinux

# fixup vmlinux so it is bootable...

mipsel-unknown-linux-uclibc-objcopy -O binary -R .reginfo \
  -R .note -R .comment -R .mdebug -S vmlinux fixed-vmlinux


