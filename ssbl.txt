After building a uclibc-based native toolchain on the freesa box,
we have to use that toolchain to build all of the stuff that will
wind up in flash (except for the kernel image and kernel modules,
which are built using the normal toolchain).

Like OpenWRT, we are building a trx image that contains a kernel
and a separate squashfs root filesystem.  Unlike OpenWRT, we're
not separating the root filesystem into a read-only squashfs and
a separate JFFS2 writeable filesystem -- we don't ever want to
write to flash unless we're flashing a new firmware; we can write
to the hard disk instead.

We call the flash image "ssbl" because it is the second-stage
boot loader -- CFE does the primary boot; it loads the linux
kernel and the squashfs root filesystem, and then the init script
in the squashfs spins up the hard disk, mounts the root
filesystem, and does the pivot-root mojo that you probably all
remember from your rescue CDs.

The components we need to build the SSBL are:

1. loader.gz, a tiny bootstrap program that loads and decompresses
   the LZMA-compressed kernel file (just like in the net-boot
   kernel)
2. lzma, which is used to LZMA-compress the kernel (also just like
   in the nfs-boot kernel)
3. The linux kernel
4. The "diag" kernel module, used to spin the hard disk in the
   WL-700gE (by activating a GPIO pin)
5. Busybox (which provides all of the programs within the SSBL
   root filesystem)
6. uClibc (which is the libc used by busybox) -- you should
   already have built a uClibc toolchain, which includes this
7. An init script that does the stuff we mentioned above, about
   loading modules and doing the pivot-root and so on
8. squashfs-lzma, used to construct the LZMA-compressed squashfs
   root filesystem
9. trx, which assembles the loader.gz, kernel, and squashfs into a
   flashable TRX image (again, just like when you built the
   net-boot firmware)

This file describes how to build and run all that stuff.

Under normal circumstances, we recommend that you build all of
this stuff in a net-booted and NFS-root-filesystem'ed freesa box,
so that you can use the final native toolchain and uClibc
toolchain for all the compilations.  If you're cross-compiling
the SSBL on a different box, note that the only components that
actually run on the build system are lzma-alone, squashfs-lzma,
and trx.  Everything else needs to be built with a
cross-compiler.

Ready?  LET'S GO.

1. loader.gz

Look at section 1.c in firmware-build-notes.txt.

2. lzma

Look at section 1.a in firmware-build-notes.txt.  Hey, look at
that!  We're going in a different order this time!  It's totally
arbitrary.

3. linux

The kernel configuration we use is in the config directory as
kernel-2.6.23-ssbl1.

If cross-compiling from a different box, use

CROSS="ARCH=mips CROSS_COMPILE=mipsel-unknown-linux-uclibc-"

(otherwise, don't set CROSS.)

make $CROSS oldconfig
make $CROSS

We'll need a couple of modules during the SSBL boot process --
otherwise, freesa won't be able to access the hard disk.  Go
ahead and copy them to where we'll want them:

mkdir -p ${SSBL}/modules
cp drivers/ide/{ide-core,ide-gd_mod}.ko ${SSBL}/modules
cp drivers/ide/aec62xx.ko ${SSBL}/modules

See all those kernel modules that got built?  If you're not doing
a native build, you'll need to move them to the hard disk in the
freesa box.  First, install them to a temporary directory:

make $CROSS INSTALL_MOD_PATH=/tmp/freesa-mods modules_install

(The "depmod" part will probably fail, but don't worry about
that.)

If you did a native build like you should have, just do 
"make modules_install" and be done with it.

Then tar up the contents of that temporary directory and put them
on the NFS server; and then use the freesa box command prompt to
extract them from the NFS root filesystem to the chrooted hard
disk filesystem (which will be the freesa box root filesystem in
just a few minutes).

You're NOT done with the kernel source yet!  Don't mess with it!

The kernel itself is vmlinux.  We need to convert it to a raw
binary like we did with the nfs-boot kernel:

objcopy -O binary -R .reginfo \
  -R .note -R .comment -R .mdebug -S vmlinux fixed-vmlinux

(or the cross-objcopy if you're cross-compiling)

Now, use the lzma_alone program you built in step 2 to compress
the kernel:

cat fixed-vmlinux | 
    lzma_alone e -si -so -eos -lc1 -lp2 -pb2 > vmlinux.lzma

This should all be hauntingly familiar.
/
Put vmlinux.lzma somewhere you'll be able to find it later.

4. diag.ko

Are you still in your linux source directory?  Good.

pushd ${FREESAGIT}/diag
make $CROSS KERNELDIR=$(dirs +1)
cp diag.ko ${SSBL}/modules
popd

Now you're done with the linux source directory.  You can trash
it if you want.  If you're building all this stuff natively,
though, you might want to keep it around -- every so often you
might find that some program wants to look at the current
kernel's source tree.

5. Busybox

Use busybox 1.15.3, or whatever is latest-stable when you feel
experimental.  There's a config file in configs you can start
with.

The prefix where Busybox will install itself is in the
configuration file, and you should set it to be the ssbl build
directory -- where you assemble everything that will become part
of the squashfs.

If you are going to put any executable programs in the ssbl that
aren't part of busybox, you should link busybox dynamically and
include the required .so files in SSBL.  However, we don't think
there's any point in doing that, so we do a static build.

6. uClibc

We don't actually need to do anything here, since we statically
linked busybox and don't have any other binaries.  Just let your
eyes slide down to the next step.

7. init

In addition to setting ROOT properly in the init-ssbl script, and
copying it to /tmp/ssbl/init, you need to set up some directories
there.

mkdir -p ${SSBL}/dev
mkdir -p ${SSBL}/mnt
mkdir -p ${SSBL}/proc
mkdir -p ${SSBL}/sys

Now that everything else is in the temporary SSBL directory, you
need to create a couple of node files.  Normally, only root can
do this!  Sorry about that.

sudo mknod -m 600 ${SSBL}/dev/console c 5 1
sudo mknod -m 666 ${SSBL}/dev/null c 1 3

8. squashfs-lzma

We're building squashfs 3.0, with a patch that adds LZMA support.
Because it uses lzma compression, you need to provide a path to
the LZMA library.  Unfortunately the one we built earlier, 4.65,
doesn't work with squashfs 3.  We need to build 4.32.
Irritating, I know...also, the patch only applies properly on the
badly-tarred version lzma432.tar.bz2.  Feel free to improve the
situation.

So, lzma 4.32.  Apply lzma-4.32-zlib-1.patch, and then:

make -C C/7zip/Compress/LZMA_Lib

Now squashfs 3.0:

LZMADIR=/tmp/lzma-4.32/C/7zip/Compress/LZMA_Lib
make -C squashfs-tools LZMAPATH=${LZMADIR} mksquashfs-lzma

And now create the squashfs itself:

mksquashfs-lzma $SSBL ssbl.squashfs -nopad -noappend -root-owned -le

9. trx

Look at section 1b of firmware-build-notes.txt.

Now we can build the actual ssbl image.  See the TEMPFILE stuff
just below this?  You can actually skip it.

TEMPFILE=$(mktemp)
echo -ne '\xde\xad\xc0\xde' > $TEMPFILE
dd if=$TEMPFILE of=fs_mark bs=64k conv=sync
echo -ne '\xde\xad\xc0\xde' >> fs_mark
rm $TEMPFILE

Gather all your components to one place and:

trx -o freesa-ssbl.trx -f loader.gz -f vmlinux.lzma -a 1024 -f ssbl.squashfs

Now reboot freesa with that orange EZ-setup button pressed, and
use TFTP to send it freesa-ssbl.trx for flashing.  Remember to
set *binary* transfer mode.

Reboot, and ... sniff, sniff?  Is that smoke?

